/*!
 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 * 
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["OktaSignIn"] = factory(require("jquery"));
	else
		root["OktaSignIn"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*globals module */
	/*jshint unused:false, camelcase: false */

	var OktaSignIn = (function () {

	  var config  = __webpack_require__(1),
	      _ = __webpack_require__(2);

	  function getProperties(authClient, LoginRouter, Util, config) {

	    /**
	     * Check if a session exists
	     * @param callback - callback function invoked with 'true'/'false' as the argument.
	     */
	    function checkSession(callback) {
	      authClient.session.exists().then(callback);
	    }

	    /**
	     * Close the current session (sign-out). Callback is invoked with an error message
	     * if the operation was not successful.
	     * @param callback - function to invoke after closing the session.
	     */
	    function closeSession(callback) {
	      authClient.session.close().then(callback)
	      .fail(function () {
	        callback('There was a problem closing the session');
	      });
	    }

	    /**
	     * Keep-alive for the session. The callback is invoked with the object containing
	     * the session if successful and {status: 'INACTIVE'} if it is not successful.
	     * @param callback - function to invoke after refreshing the session.
	     */
	    function refreshSession(callback) {
	      authClient.session.refresh().then(callback)
	      .fail(function() {
	        callback({status: 'INACTIVE'});
	      });
	    }

	    /**
	     * Refresh the idToken
	     * @param idToken - idToken generated from the OAUTH call
	     * @param callback - function to invoke after refreshing the idToken.
	     *        The callback will be passed a new idToken if successful and
	     *        an error message if not.
	     * @param opts - OAUTH options to refresh the idToken
	     */
	    function refreshIdToken(idToken, callback, opts) {
	      authClient.idToken.refresh(opts).then(callback)
	      .fail(function () {
	        callback('There was a problem refreshing the id_token');
	      });
	    }

	    /**
	     * Check if there is an active session. If there is one, the callback is invoked with
	     * the session and user information (similar to calling the global success callback)
	     * and if not, the callback is invoked with {status: 'INACTIVE'}, at which point,
	     * the widget can be rendered using renderEl().
	     * @param callback - function to invoke after checking if there is an active session.
	     */
	    function getSession(callback) {
	      authClient.session.get()
	      .then(function(res) {
	        if (res.status === 'ACTIVE' && res.user) {
	          // only include the attributes that are passed into the successFn on primary auth.
	          res.user = _.pick(res.user, 'id', 'profile', 'passwordChanged');
	        }
	        callback(res);
	      });
	    }

	    /**
	     * Render the sign in widget to an element.
	     * @param options - options for the signin widget.
	     *        Must have an el or $el property to render the widget to.
	     * @param success - success callback function
	     * @param error - error callback function
	     */
	    function render(options, success, error) {
	      var router = new LoginRouter(_.extend({}, config, options, {
	        authClient: authClient,
	        globalSuccessFn: success,
	        globalErrorFn: error
	      }));
	      router.start();
	    }

	    /**
	     * Check if tokens have been passed back into the url, which happens in
	     * the social auth IDP redirect flow.
	     */
	    function hasTokensInUrl() {
	      return Util.hasTokensInHash(window.location.hash);
	    }

	    /**
	     * Parses tokens from the url.
	     * @param success - success callback function (usually the same as passed to render)
	     * @param error - error callback function (usually the same as passed to render)
	     */
	    function parseTokensFromUrl(success, error) {
	      authClient.token.parseFromUrl()
	      .then(success)
	      .fail(error);
	    }

	    // Properties exposed on OktaSignIn object.
	    return {
	      renderEl: render,
	      signOut: closeSession,
	      idToken: {
	        refresh: refreshIdToken
	      },
	      session: {
	        close: closeSession,
	        exists: checkSession,
	        get: getSession,
	        refresh: refreshSession
	      },
	      token: {
	        hasTokensInUrl: hasTokensInUrl,
	        parseTokensFromUrl: parseTokensFromUrl
	      },
	      tokenManager: authClient.tokenManager
	    };
	  }

	  function OktaSignIn(options) {
	    var OktaAuth, Util, authClient, LoginRouter;

	    // Modify the underscore, handlebars, and jquery modules
	    // Remove once these are explicitly required in Courage
	    __webpack_require__(3);
	    __webpack_require__(5);
	    __webpack_require__(17);

	    OktaAuth = __webpack_require__(18);
	    Util = __webpack_require__(40);
	    LoginRouter = __webpack_require__(102);

	    authClient = new OktaAuth({
	      url: options.baseUrl,
	      transformErrorXHR: Util.transformErrorXHR,
	      headers: {
	        'X-Okta-User-Agent-Extended': 'okta-signin-widget-' + config.version
	      },
	      clientId: options.clientId,
	      redirectUri: options.redirectUri
	    });
	    _.extend(this, LoginRouter.prototype.Events, getProperties(authClient, LoginRouter, Util, options));

	    // Triggers the event up the chain so it is available to the consumers of the widget.
	    this.listenTo(LoginRouter.prototype, 'all', this.trigger);

	  }

	  return OktaSignIn;

	})();

	module.exports = OktaSignIn;


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = {
		"version": "1.10.0",
		"supportedLanguages": [
			"en",
			"cs",
			"da",
			"de",
			"es",
			"fi",
			"fr",
			"hu",
			"id",
			"in",
			"it",
			"ja",
			"ko",
			"ms",
			"nl-NL",
			"pl",
			"pt-BR",
			"ro",
			"ru",
			"sv",
			"th",
			"uk",
			"zh-CN",
			"zh-TW"
		]
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (underscore, Handlebars) {

	  var _ = underscore.noConflict();

	  _.mixin({

	    resultCtx: function (object, property, context, defaultValue) {
	      var value = _.isObject(object) ? object[property] : void 0;
	      if (_.isFunction(value)) {
	        value = value.call(context || object);
	      }
	      if (value) {
	        return value;
	      }
	      else {
	        return !_.isUndefined(defaultValue) ? defaultValue : value;
	      }
	    },

	    isInteger: function (x) {
	      return _.isNumber(x) && (x % 1 === 0);
	    },

	    template: function (source, data) {
	      var template = Handlebars.compile(source);
	      return data ? template(data) : function (data) { return template(data); };
	    }

	  });

	  return _;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*!

	 handlebars v4.0.5

	Copyright (C) 2011-2015 by Yehuda Katz

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.

	@license
	*/
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Handlebars"] = factory();
		else
			root["Handlebars"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _handlebarsRuntime = __webpack_require__(2);

		var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

		// Compiler imports

		var _handlebarsCompilerAst = __webpack_require__(21);

		var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

		var _handlebarsCompilerBase = __webpack_require__(22);

		var _handlebarsCompilerCompiler = __webpack_require__(27);

		var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);

		var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

		var _handlebarsCompilerVisitor = __webpack_require__(25);

		var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

		var _handlebarsNoConflict = __webpack_require__(20);

		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

		var _create = _handlebarsRuntime2['default'].create;
		function create() {
		  var hb = _create();

		  hb.compile = function (input, options) {
		    return _handlebarsCompilerCompiler.compile(input, options, hb);
		  };
		  hb.precompile = function (input, options) {
		    return _handlebarsCompilerCompiler.precompile(input, options, hb);
		  };

		  hb.AST = _handlebarsCompilerAst2['default'];
		  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
		  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
		  hb.Parser = _handlebarsCompilerBase.parser;
		  hb.parse = _handlebarsCompilerBase.parse;

		  return hb;
		}

		var inst = create();
		inst.create = create;

		_handlebarsNoConflict2['default'](inst);

		inst.Visitor = _handlebarsCompilerVisitor2['default'];

		inst['default'] = inst;

		exports['default'] = inst;
		module.exports = exports['default'];

	/***/ },
	/* 1 */
	/***/ function(module, exports) {

		"use strict";

		exports["default"] = function (obj) {
		  return obj && obj.__esModule ? obj : {
		    "default": obj
		  };
		};

		exports.__esModule = true;

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireWildcard = __webpack_require__(3)['default'];

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _handlebarsBase = __webpack_require__(4);

		var base = _interopRequireWildcard(_handlebarsBase);

		// Each of these augment the Handlebars object. No need to setup here.
		// (This is done to easily share code between commonjs and browse envs)

		var _handlebarsSafeString = __webpack_require__(18);

		var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

		var _handlebarsException = __webpack_require__(6);

		var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

		var _handlebarsUtils = __webpack_require__(5);

		var Utils = _interopRequireWildcard(_handlebarsUtils);

		var _handlebarsRuntime = __webpack_require__(19);

		var runtime = _interopRequireWildcard(_handlebarsRuntime);

		var _handlebarsNoConflict = __webpack_require__(20);

		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

		// For compatibility and usage outside of module systems, make the Handlebars object a namespace
		function create() {
		  var hb = new base.HandlebarsEnvironment();

		  Utils.extend(hb, base);
		  hb.SafeString = _handlebarsSafeString2['default'];
		  hb.Exception = _handlebarsException2['default'];
		  hb.Utils = Utils;
		  hb.escapeExpression = Utils.escapeExpression;

		  hb.VM = runtime;
		  hb.template = function (spec) {
		    return runtime.template(spec, hb);
		  };

		  return hb;
		}

		var inst = create();
		inst.create = create;

		_handlebarsNoConflict2['default'](inst);

		inst['default'] = inst;

		exports['default'] = inst;
		module.exports = exports['default'];

	/***/ },
	/* 3 */
	/***/ function(module, exports) {

		"use strict";

		exports["default"] = function (obj) {
		  if (obj && obj.__esModule) {
		    return obj;
		  } else {
		    var newObj = {};

		    if (obj != null) {
		      for (var key in obj) {
		        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
		      }
		    }

		    newObj["default"] = obj;
		    return newObj;
		  }
		};

		exports.__esModule = true;

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.HandlebarsEnvironment = HandlebarsEnvironment;

		var _utils = __webpack_require__(5);

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		var _helpers = __webpack_require__(7);

		var _decorators = __webpack_require__(15);

		var _logger = __webpack_require__(17);

		var _logger2 = _interopRequireDefault(_logger);

		var VERSION = '4.0.5';
		exports.VERSION = VERSION;
		var COMPILER_REVISION = 7;

		exports.COMPILER_REVISION = COMPILER_REVISION;
		var REVISION_CHANGES = {
		  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
		  2: '== 1.0.0-rc.3',
		  3: '== 1.0.0-rc.4',
		  4: '== 1.x.x',
		  5: '== 2.0.0-alpha.x',
		  6: '>= 2.0.0-beta.1',
		  7: '>= 4.0.0'
		};

		exports.REVISION_CHANGES = REVISION_CHANGES;
		var objectType = '[object Object]';

		function HandlebarsEnvironment(helpers, partials, decorators) {
		  this.helpers = helpers || {};
		  this.partials = partials || {};
		  this.decorators = decorators || {};

		  _helpers.registerDefaultHelpers(this);
		  _decorators.registerDefaultDecorators(this);
		}

		HandlebarsEnvironment.prototype = {
		  constructor: HandlebarsEnvironment,

		  logger: _logger2['default'],
		  log: _logger2['default'].log,

		  registerHelper: function registerHelper(name, fn) {
		    if (_utils.toString.call(name) === objectType) {
		      if (fn) {
		        throw new _exception2['default']('Arg not supported with multiple helpers');
		      }
		      _utils.extend(this.helpers, name);
		    } else {
		      this.helpers[name] = fn;
		    }
		  },
		  unregisterHelper: function unregisterHelper(name) {
		    delete this.helpers[name];
		  },

		  registerPartial: function registerPartial(name, partial) {
		    if (_utils.toString.call(name) === objectType) {
		      _utils.extend(this.partials, name);
		    } else {
		      if (typeof partial === 'undefined') {
		        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
		      }
		      this.partials[name] = partial;
		    }
		  },
		  unregisterPartial: function unregisterPartial(name) {
		    delete this.partials[name];
		  },

		  registerDecorator: function registerDecorator(name, fn) {
		    if (_utils.toString.call(name) === objectType) {
		      if (fn) {
		        throw new _exception2['default']('Arg not supported with multiple decorators');
		      }
		      _utils.extend(this.decorators, name);
		    } else {
		      this.decorators[name] = fn;
		    }
		  },
		  unregisterDecorator: function unregisterDecorator(name) {
		    delete this.decorators[name];
		  }
		};

		var log = _logger2['default'].log;

		exports.log = log;
		exports.createFrame = _utils.createFrame;
		exports.logger = _logger2['default'];

	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		'use strict';

		exports.__esModule = true;
		exports.extend = extend;
		exports.indexOf = indexOf;
		exports.escapeExpression = escapeExpression;
		exports.isEmpty = isEmpty;
		exports.createFrame = createFrame;
		exports.blockParams = blockParams;
		exports.appendContextPath = appendContextPath;
		var escape = {
		  '&': '&amp;',
		  '<': '&lt;',
		  '>': '&gt;',
		  '"': '&quot;',
		  "'": '&#x27;',
		  '`': '&#x60;',
		  '=': '&#x3D;'
		};

		var badChars = /[&<>"'`=]/g,
		    possible = /[&<>"'`=]/;

		function escapeChar(chr) {
		  return escape[chr];
		}

		function extend(obj /* , ...source */) {
		  for (var i = 1; i < arguments.length; i++) {
		    for (var key in arguments[i]) {
		      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
		        obj[key] = arguments[i][key];
		      }
		    }
		  }

		  return obj;
		}

		var toString = Object.prototype.toString;

		exports.toString = toString;
		// Sourced from lodash
		// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
		/* eslint-disable func-style */
		var isFunction = function isFunction(value) {
		  return typeof value === 'function';
		};
		// fallback for older versions of Chrome and Safari
		/* istanbul ignore next */
		if (isFunction(/x/)) {
		  exports.isFunction = isFunction = function (value) {
		    return typeof value === 'function' && toString.call(value) === '[object Function]';
		  };
		}
		exports.isFunction = isFunction;

		/* eslint-enable func-style */

		/* istanbul ignore next */
		var isArray = Array.isArray || function (value) {
		  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
		};

		exports.isArray = isArray;
		// Older IE versions do not directly support indexOf so we must implement our own, sadly.

		function indexOf(array, value) {
		  for (var i = 0, len = array.length; i < len; i++) {
		    if (array[i] === value) {
		      return i;
		    }
		  }
		  return -1;
		}

		function escapeExpression(string) {
		  if (typeof string !== 'string') {
		    // don't escape SafeStrings, since they're already safe
		    if (string && string.toHTML) {
		      return string.toHTML();
		    } else if (string == null) {
		      return '';
		    } else if (!string) {
		      return string + '';
		    }

		    // Force a string conversion as this will be done by the append regardless and
		    // the regex test will do this transparently behind the scenes, causing issues if
		    // an object's to string has escaped characters in it.
		    string = '' + string;
		  }

		  if (!possible.test(string)) {
		    return string;
		  }
		  return string.replace(badChars, escapeChar);
		}

		function isEmpty(value) {
		  if (!value && value !== 0) {
		    return true;
		  } else if (isArray(value) && value.length === 0) {
		    return true;
		  } else {
		    return false;
		  }
		}

		function createFrame(object) {
		  var frame = extend({}, object);
		  frame._parent = object;
		  return frame;
		}

		function blockParams(params, ids) {
		  params.path = ids;
		  return params;
		}

		function appendContextPath(contextPath, id) {
		  return (contextPath ? contextPath + '.' : '') + id;
		}

	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		'use strict';

		exports.__esModule = true;

		var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

		function Exception(message, node) {
		  var loc = node && node.loc,
		      line = undefined,
		      column = undefined;
		  if (loc) {
		    line = loc.start.line;
		    column = loc.start.column;

		    message += ' - ' + line + ':' + column;
		  }

		  var tmp = Error.prototype.constructor.call(this, message);

		  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
		  for (var idx = 0; idx < errorProps.length; idx++) {
		    this[errorProps[idx]] = tmp[errorProps[idx]];
		  }

		  /* istanbul ignore else */
		  if (Error.captureStackTrace) {
		    Error.captureStackTrace(this, Exception);
		  }

		  if (loc) {
		    this.lineNumber = line;
		    this.column = column;
		  }
		}

		Exception.prototype = new Error();

		exports['default'] = Exception;
		module.exports = exports['default'];

	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.registerDefaultHelpers = registerDefaultHelpers;

		var _helpersBlockHelperMissing = __webpack_require__(8);

		var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

		var _helpersEach = __webpack_require__(9);

		var _helpersEach2 = _interopRequireDefault(_helpersEach);

		var _helpersHelperMissing = __webpack_require__(10);

		var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

		var _helpersIf = __webpack_require__(11);

		var _helpersIf2 = _interopRequireDefault(_helpersIf);

		var _helpersLog = __webpack_require__(12);

		var _helpersLog2 = _interopRequireDefault(_helpersLog);

		var _helpersLookup = __webpack_require__(13);

		var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

		var _helpersWith = __webpack_require__(14);

		var _helpersWith2 = _interopRequireDefault(_helpersWith);

		function registerDefaultHelpers(instance) {
		  _helpersBlockHelperMissing2['default'](instance);
		  _helpersEach2['default'](instance);
		  _helpersHelperMissing2['default'](instance);
		  _helpersIf2['default'](instance);
		  _helpersLog2['default'](instance);
		  _helpersLookup2['default'](instance);
		  _helpersWith2['default'](instance);
		}

	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		exports['default'] = function (instance) {
		  instance.registerHelper('blockHelperMissing', function (context, options) {
		    var inverse = options.inverse,
		        fn = options.fn;

		    if (context === true) {
		      return fn(this);
		    } else if (context === false || context == null) {
		      return inverse(this);
		    } else if (_utils.isArray(context)) {
		      if (context.length > 0) {
		        if (options.ids) {
		          options.ids = [options.name];
		        }

		        return instance.helpers.each(context, options);
		      } else {
		        return inverse(this);
		      }
		    } else {
		      if (options.data && options.ids) {
		        var data = _utils.createFrame(options.data);
		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
		        options = { data: data };
		      }

		      return fn(context, options);
		    }
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('each', function (context, options) {
		    if (!options) {
		      throw new _exception2['default']('Must pass iterator to #each');
		    }

		    var fn = options.fn,
		        inverse = options.inverse,
		        i = 0,
		        ret = '',
		        data = undefined,
		        contextPath = undefined;

		    if (options.data && options.ids) {
		      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
		    }

		    if (_utils.isFunction(context)) {
		      context = context.call(this);
		    }

		    if (options.data) {
		      data = _utils.createFrame(options.data);
		    }

		    function execIteration(field, index, last) {
		      if (data) {
		        data.key = field;
		        data.index = index;
		        data.first = index === 0;
		        data.last = !!last;

		        if (contextPath) {
		          data.contextPath = contextPath + field;
		        }
		      }

		      ret = ret + fn(context[field], {
		        data: data,
		        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
		      });
		    }

		    if (context && typeof context === 'object') {
		      if (_utils.isArray(context)) {
		        for (var j = context.length; i < j; i++) {
		          if (i in context) {
		            execIteration(i, i, i === context.length - 1);
		          }
		        }
		      } else {
		        var priorKey = undefined;

		        for (var key in context) {
		          if (context.hasOwnProperty(key)) {
		            // We're running the iterations one step out of sync so we can detect
		            // the last iteration without have to scan the object twice and create
		            // an itermediate keys array.
		            if (priorKey !== undefined) {
		              execIteration(priorKey, i - 1);
		            }
		            priorKey = key;
		            i++;
		          }
		        }
		        if (priorKey !== undefined) {
		          execIteration(priorKey, i - 1, true);
		        }
		      }
		    }

		    if (i === 0) {
		      ret = inverse(this);
		    }

		    return ret;
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		exports['default'] = function (instance) {
		  instance.registerHelper('helperMissing', function () /* [args, ]options */{
		    if (arguments.length === 1) {
		      // A missing field in a {{foo}} construct.
		      return undefined;
		    } else {
		      // Someone is actually trying to call something, blow up.
		      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
		    }
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		exports['default'] = function (instance) {
		  instance.registerHelper('if', function (conditional, options) {
		    if (_utils.isFunction(conditional)) {
		      conditional = conditional.call(this);
		    }

		    // Default behavior is to render the positive path if the value is truthy and not empty.
		    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
		    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
		    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
		      return options.inverse(this);
		    } else {
		      return options.fn(this);
		    }
		  });

		  instance.registerHelper('unless', function (conditional, options) {
		    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 12 */
	/***/ function(module, exports) {

		'use strict';

		exports.__esModule = true;

		exports['default'] = function (instance) {
		  instance.registerHelper('log', function () /* message, options */{
		    var args = [undefined],
		        options = arguments[arguments.length - 1];
		    for (var i = 0; i < arguments.length - 1; i++) {
		      args.push(arguments[i]);
		    }

		    var level = 1;
		    if (options.hash.level != null) {
		      level = options.hash.level;
		    } else if (options.data && options.data.level != null) {
		      level = options.data.level;
		    }
		    args[0] = level;

		    instance.log.apply(instance, args);
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 13 */
	/***/ function(module, exports) {

		'use strict';

		exports.__esModule = true;

		exports['default'] = function (instance) {
		  instance.registerHelper('lookup', function (obj, field) {
		    return obj && obj[field];
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		exports['default'] = function (instance) {
		  instance.registerHelper('with', function (context, options) {
		    if (_utils.isFunction(context)) {
		      context = context.call(this);
		    }

		    var fn = options.fn;

		    if (!_utils.isEmpty(context)) {
		      var data = options.data;
		      if (options.data && options.ids) {
		        data = _utils.createFrame(options.data);
		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
		      }

		      return fn(context, {
		        data: data,
		        blockParams: _utils.blockParams([context], [data && data.contextPath])
		      });
		    } else {
		      return options.inverse(this);
		    }
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.registerDefaultDecorators = registerDefaultDecorators;

		var _decoratorsInline = __webpack_require__(16);

		var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

		function registerDefaultDecorators(instance) {
		  _decoratorsInline2['default'](instance);
		}

	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		exports['default'] = function (instance) {
		  instance.registerDecorator('inline', function (fn, props, container, options) {
		    var ret = fn;
		    if (!props.partials) {
		      props.partials = {};
		      ret = function (context, options) {
		        // Create a new partials stack frame prior to exec.
		        var original = container.partials;
		        container.partials = _utils.extend({}, original, props.partials);
		        var ret = fn(context, options);
		        container.partials = original;
		        return ret;
		      };
		    }

		    props.partials[options.args[0]] = options.fn;

		    return ret;
		  });
		};

		module.exports = exports['default'];

	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		var logger = {
		  methodMap: ['debug', 'info', 'warn', 'error'],
		  level: 'info',

		  // Maps a given level value to the `methodMap` indexes above.
		  lookupLevel: function lookupLevel(level) {
		    if (typeof level === 'string') {
		      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
		      if (levelMap >= 0) {
		        level = levelMap;
		      } else {
		        level = parseInt(level, 10);
		      }
		    }

		    return level;
		  },

		  // Can be overridden in the host environment
		  log: function log(level) {
		    level = logger.lookupLevel(level);

		    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
		      var method = logger.methodMap[level];
		      if (!console[method]) {
		        // eslint-disable-line no-console
		        method = 'log';
		      }

		      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		        message[_key - 1] = arguments[_key];
		      }

		      console[method].apply(console, message); // eslint-disable-line no-console
		    }
		  }
		};

		exports['default'] = logger;
		module.exports = exports['default'];

	/***/ },
	/* 18 */
	/***/ function(module, exports) {

		// Build out our basic SafeString type
		'use strict';

		exports.__esModule = true;
		function SafeString(string) {
		  this.string = string;
		}

		SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
		  return '' + this.string;
		};

		exports['default'] = SafeString;
		module.exports = exports['default'];

	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireWildcard = __webpack_require__(3)['default'];

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.checkRevision = checkRevision;
		exports.template = template;
		exports.wrapProgram = wrapProgram;
		exports.resolvePartial = resolvePartial;
		exports.invokePartial = invokePartial;
		exports.noop = noop;

		var _utils = __webpack_require__(5);

		var Utils = _interopRequireWildcard(_utils);

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		var _base = __webpack_require__(4);

		function checkRevision(compilerInfo) {
		  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
		      currentRevision = _base.COMPILER_REVISION;

		  if (compilerRevision !== currentRevision) {
		    if (compilerRevision < currentRevision) {
		      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
		          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
		      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
		    } else {
		      // Use the embedded version info since the runtime doesn't know about this revision yet
		      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
		    }
		  }
		}

		function template(templateSpec, env) {
		  /* istanbul ignore next */
		  if (!env) {
		    throw new _exception2['default']('No environment passed to template');
		  }
		  if (!templateSpec || !templateSpec.main) {
		    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
		  }

		  templateSpec.main.decorator = templateSpec.main_d;

		  // Note: Using env.VM references rather than local var references throughout this section to allow
		  // for external users to override these as psuedo-supported APIs.
		  env.VM.checkRevision(templateSpec.compiler);

		  function invokePartialWrapper(partial, context, options) {
		    if (options.hash) {
		      context = Utils.extend({}, context, options.hash);
		      if (options.ids) {
		        options.ids[0] = true;
		      }
		    }

		    partial = env.VM.resolvePartial.call(this, partial, context, options);
		    var result = env.VM.invokePartial.call(this, partial, context, options);

		    if (result == null && env.compile) {
		      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
		      result = options.partials[options.name](context, options);
		    }
		    if (result != null) {
		      if (options.indent) {
		        var lines = result.split('\n');
		        for (var i = 0, l = lines.length; i < l; i++) {
		          if (!lines[i] && i + 1 === l) {
		            break;
		          }

		          lines[i] = options.indent + lines[i];
		        }
		        result = lines.join('\n');
		      }
		      return result;
		    } else {
		      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
		    }
		  }

		  // Just add water
		  var container = {
		    strict: function strict(obj, name) {
		      if (!(name in obj)) {
		        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
		      }
		      return obj[name];
		    },
		    lookup: function lookup(depths, name) {
		      var len = depths.length;
		      for (var i = 0; i < len; i++) {
		        if (depths[i] && depths[i][name] != null) {
		          return depths[i][name];
		        }
		      }
		    },
		    lambda: function lambda(current, context) {
		      return typeof current === 'function' ? current.call(context) : current;
		    },

		    escapeExpression: Utils.escapeExpression,
		    invokePartial: invokePartialWrapper,

		    fn: function fn(i) {
		      var ret = templateSpec[i];
		      ret.decorator = templateSpec[i + '_d'];
		      return ret;
		    },

		    programs: [],
		    program: function program(i, data, declaredBlockParams, blockParams, depths) {
		      var programWrapper = this.programs[i],
		          fn = this.fn(i);
		      if (data || depths || blockParams || declaredBlockParams) {
		        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
		      } else if (!programWrapper) {
		        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
		      }
		      return programWrapper;
		    },

		    data: function data(value, depth) {
		      while (value && depth--) {
		        value = value._parent;
		      }
		      return value;
		    },
		    merge: function merge(param, common) {
		      var obj = param || common;

		      if (param && common && param !== common) {
		        obj = Utils.extend({}, common, param);
		      }

		      return obj;
		    },

		    noop: env.VM.noop,
		    compilerInfo: templateSpec.compiler
		  };

		  function ret(context) {
		    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    var data = options.data;

		    ret._setup(options);
		    if (!options.partial && templateSpec.useData) {
		      data = initData(context, data);
		    }
		    var depths = undefined,
		        blockParams = templateSpec.useBlockParams ? [] : undefined;
		    if (templateSpec.useDepths) {
		      if (options.depths) {
		        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
		      } else {
		        depths = [context];
		      }
		    }

		    function main(context /*, options*/) {
		      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
		    }
		    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
		    return main(context, options);
		  }
		  ret.isTop = true;

		  ret._setup = function (options) {
		    if (!options.partial) {
		      container.helpers = container.merge(options.helpers, env.helpers);

		      if (templateSpec.usePartial) {
		        container.partials = container.merge(options.partials, env.partials);
		      }
		      if (templateSpec.usePartial || templateSpec.useDecorators) {
		        container.decorators = container.merge(options.decorators, env.decorators);
		      }
		    } else {
		      container.helpers = options.helpers;
		      container.partials = options.partials;
		      container.decorators = options.decorators;
		    }
		  };

		  ret._child = function (i, data, blockParams, depths) {
		    if (templateSpec.useBlockParams && !blockParams) {
		      throw new _exception2['default']('must pass block params');
		    }
		    if (templateSpec.useDepths && !depths) {
		      throw new _exception2['default']('must pass parent depths');
		    }

		    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
		  };
		  return ret;
		}

		function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
		  function prog(context) {
		    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		    var currentDepths = depths;
		    if (depths && context !== depths[0]) {
		      currentDepths = [context].concat(depths);
		    }

		    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
		  }

		  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

		  prog.program = i;
		  prog.depth = depths ? depths.length : 0;
		  prog.blockParams = declaredBlockParams || 0;
		  return prog;
		}

		function resolvePartial(partial, context, options) {
		  if (!partial) {
		    if (options.name === '@partial-block') {
		      partial = options.data['partial-block'];
		    } else {
		      partial = options.partials[options.name];
		    }
		  } else if (!partial.call && !options.name) {
		    // This is a dynamic partial that returned a string
		    options.name = partial;
		    partial = options.partials[partial];
		  }
		  return partial;
		}

		function invokePartial(partial, context, options) {
		  options.partial = true;
		  if (options.ids) {
		    options.data.contextPath = options.ids[0] || options.data.contextPath;
		  }

		  var partialBlock = undefined;
		  if (options.fn && options.fn !== noop) {
		    options.data = _base.createFrame(options.data);
		    partialBlock = options.data['partial-block'] = options.fn;

		    if (partialBlock.partials) {
		      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
		    }
		  }

		  if (partial === undefined && partialBlock) {
		    partial = partialBlock;
		  }

		  if (partial === undefined) {
		    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
		  } else if (partial instanceof Function) {
		    return partial(context, options);
		  }
		}

		function noop() {
		  return '';
		}

		function initData(context, data) {
		  if (!data || !('root' in data)) {
		    data = data ? _base.createFrame(data) : {};
		    data.root = context;
		  }
		  return data;
		}

		function executeDecorators(fn, prog, container, depths, data, blockParams) {
		  if (fn.decorator) {
		    var props = {};
		    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
		    Utils.extend(prog, props);
		  }
		  return prog;
		}

	/***/ },
	/* 20 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {/* global window */
		'use strict';

		exports.__esModule = true;

		exports['default'] = function (Handlebars) {
		  /* istanbul ignore next */
		  var root = typeof global !== 'undefined' ? global : window,
		      $Handlebars = root.Handlebars;
		  /* istanbul ignore next */
		  Handlebars.noConflict = function () {
		    if (root.Handlebars === Handlebars) {
		      root.Handlebars = $Handlebars;
		    }
		    return Handlebars;
		  };
		};

		module.exports = exports['default'];
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 21 */
	/***/ function(module, exports) {

		'use strict';

		exports.__esModule = true;
		var AST = {
		  // Public API used to evaluate derived attributes regarding AST nodes
		  helpers: {
		    // a mustache is definitely a helper if:
		    // * it is an eligible helper, and
		    // * it has at least one parameter or hash segment
		    helperExpression: function helperExpression(node) {
		      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
		    },

		    scopedId: function scopedId(path) {
		      return (/^\.|this\b/.test(path.original)
		      );
		    },

		    // an ID is simple if it only has one part, and that part is not
		    // `..` or `this`.
		    simpleId: function simpleId(path) {
		      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
		    }
		  }
		};

		// Must be exported as an object rather than the root of the module as the jison lexer
		// must modify the object to operate properly.
		exports['default'] = AST;
		module.exports = exports['default'];

	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		var _interopRequireWildcard = __webpack_require__(3)['default'];

		exports.__esModule = true;
		exports.parse = parse;

		var _parser = __webpack_require__(23);

		var _parser2 = _interopRequireDefault(_parser);

		var _whitespaceControl = __webpack_require__(24);

		var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

		var _helpers = __webpack_require__(26);

		var Helpers = _interopRequireWildcard(_helpers);

		var _utils = __webpack_require__(5);

		exports.parser = _parser2['default'];

		var yy = {};
		_utils.extend(yy, Helpers);

		function parse(input, options) {
		  // Just return if an already-compiled AST was passed in.
		  if (input.type === 'Program') {
		    return input;
		  }

		  _parser2['default'].yy = yy;

		  // Altering the shared object here, but this is ok as parser is a sync operation
		  yy.locInfo = function (locInfo) {
		    return new yy.SourceLocation(options && options.srcName, locInfo);
		  };

		  var strip = new _whitespaceControl2['default'](options);
		  return strip.accept(_parser2['default'].parse(input));
		}

	/***/ },
	/* 23 */
	/***/ function(module, exports) {

		/* istanbul ignore next */
		/* Jison generated parser */
		"use strict";

		var handlebars = (function () {
		    var parser = { trace: function trace() {},
		        yy: {},
		        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
		        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
		        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
		        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
		        /**/) {

		            var $0 = $$.length - 1;
		            switch (yystate) {
		                case 1:
		                    return $$[$0 - 1];
		                    break;
		                case 2:
		                    this.$ = yy.prepareProgram($$[$0]);
		                    break;
		                case 3:
		                    this.$ = $$[$0];
		                    break;
		                case 4:
		                    this.$ = $$[$0];
		                    break;
		                case 5:
		                    this.$ = $$[$0];
		                    break;
		                case 6:
		                    this.$ = $$[$0];
		                    break;
		                case 7:
		                    this.$ = $$[$0];
		                    break;
		                case 8:
		                    this.$ = $$[$0];
		                    break;
		                case 9:
		                    this.$ = {
		                        type: 'CommentStatement',
		                        value: yy.stripComment($$[$0]),
		                        strip: yy.stripFlags($$[$0], $$[$0]),
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 10:
		                    this.$ = {
		                        type: 'ContentStatement',
		                        original: $$[$0],
		                        value: $$[$0],
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 11:
		                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
		                    break;
		                case 12:
		                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
		                    break;
		                case 13:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
		                    break;
		                case 14:
		                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
		                    break;
		                case 15:
		                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 16:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 17:
		                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
		                    break;
		                case 18:
		                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
		                    break;
		                case 19:
		                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
		                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
		                    program.chained = true;

		                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

		                    break;
		                case 20:
		                    this.$ = $$[$0];
		                    break;
		                case 21:
		                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
		                    break;
		                case 22:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 23:
		                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
		                    break;
		                case 24:
		                    this.$ = {
		                        type: 'PartialStatement',
		                        name: $$[$0 - 3],
		                        params: $$[$0 - 2],
		                        hash: $$[$0 - 1],
		                        indent: '',
		                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 25:
		                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
		                    break;
		                case 26:
		                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
		                    break;
		                case 27:
		                    this.$ = $$[$0];
		                    break;
		                case 28:
		                    this.$ = $$[$0];
		                    break;
		                case 29:
		                    this.$ = {
		                        type: 'SubExpression',
		                        path: $$[$0 - 3],
		                        params: $$[$0 - 2],
		                        hash: $$[$0 - 1],
		                        loc: yy.locInfo(this._$)
		                    };

		                    break;
		                case 30:
		                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 31:
		                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 32:
		                    this.$ = yy.id($$[$0 - 1]);
		                    break;
		                case 33:
		                    this.$ = $$[$0];
		                    break;
		                case 34:
		                    this.$ = $$[$0];
		                    break;
		                case 35:
		                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
		                    break;
		                case 36:
		                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
		                    break;
		                case 37:
		                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
		                    break;
		                case 38:
		                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
		                    break;
		                case 39:
		                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
		                    break;
		                case 40:
		                    this.$ = $$[$0];
		                    break;
		                case 41:
		                    this.$ = $$[$0];
		                    break;
		                case 42:
		                    this.$ = yy.preparePath(true, $$[$0], this._$);
		                    break;
		                case 43:
		                    this.$ = yy.preparePath(false, $$[$0], this._$);
		                    break;
		                case 44:
		                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
		                    break;
		                case 45:
		                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
		                    break;
		                case 46:
		                    this.$ = [];
		                    break;
		                case 47:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 48:
		                    this.$ = [$$[$0]];
		                    break;
		                case 49:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 50:
		                    this.$ = [];
		                    break;
		                case 51:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 58:
		                    this.$ = [];
		                    break;
		                case 59:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 64:
		                    this.$ = [];
		                    break;
		                case 65:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 70:
		                    this.$ = [];
		                    break;
		                case 71:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 78:
		                    this.$ = [];
		                    break;
		                case 79:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 82:
		                    this.$ = [];
		                    break;
		                case 83:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 86:
		                    this.$ = [];
		                    break;
		                case 87:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 90:
		                    this.$ = [];
		                    break;
		                case 91:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 94:
		                    this.$ = [];
		                    break;
		                case 95:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 98:
		                    this.$ = [$$[$0]];
		                    break;
		                case 99:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		                case 100:
		                    this.$ = [$$[$0]];
		                    break;
		                case 101:
		                    $$[$0 - 1].push($$[$0]);
		                    break;
		            }
		        },
		        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
		        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
		        parseError: function parseError(str, hash) {
		            throw new Error(str);
		        },
		        parse: function parse(input) {
		            var self = this,
		                stack = [0],
		                vstack = [null],
		                lstack = [],
		                table = this.table,
		                yytext = "",
		                yylineno = 0,
		                yyleng = 0,
		                recovering = 0,
		                TERROR = 2,
		                EOF = 1;
		            this.lexer.setInput(input);
		            this.lexer.yy = this.yy;
		            this.yy.lexer = this.lexer;
		            this.yy.parser = this;
		            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
		            var yyloc = this.lexer.yylloc;
		            lstack.push(yyloc);
		            var ranges = this.lexer.options && this.lexer.options.ranges;
		            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
		            function popStack(n) {
		                stack.length = stack.length - 2 * n;
		                vstack.length = vstack.length - n;
		                lstack.length = lstack.length - n;
		            }
		            function lex() {
		                var token;
		                token = self.lexer.lex() || 1;
		                if (typeof token !== "number") {
		                    token = self.symbols_[token] || token;
		                }
		                return token;
		            }
		            var symbol,
		                preErrorSymbol,
		                state,
		                action,
		                a,
		                r,
		                yyval = {},
		                p,
		                len,
		                newState,
		                expected;
		            while (true) {
		                state = stack[stack.length - 1];
		                if (this.defaultActions[state]) {
		                    action = this.defaultActions[state];
		                } else {
		                    if (symbol === null || typeof symbol == "undefined") {
		                        symbol = lex();
		                    }
		                    action = table[state] && table[state][symbol];
		                }
		                if (typeof action === "undefined" || !action.length || !action[0]) {
		                    var errStr = "";
		                    if (!recovering) {
		                        expected = [];
		                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
		                            expected.push("'" + this.terminals_[p] + "'");
		                        }
		                        if (this.lexer.showPosition) {
		                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
		                        } else {
		                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
		                        }
		                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
		                    }
		                }
		                if (action[0] instanceof Array && action.length > 1) {
		                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
		                }
		                switch (action[0]) {
		                    case 1:
		                        stack.push(symbol);
		                        vstack.push(this.lexer.yytext);
		                        lstack.push(this.lexer.yylloc);
		                        stack.push(action[1]);
		                        symbol = null;
		                        if (!preErrorSymbol) {
		                            yyleng = this.lexer.yyleng;
		                            yytext = this.lexer.yytext;
		                            yylineno = this.lexer.yylineno;
		                            yyloc = this.lexer.yylloc;
		                            if (recovering > 0) recovering--;
		                        } else {
		                            symbol = preErrorSymbol;
		                            preErrorSymbol = null;
		                        }
		                        break;
		                    case 2:
		                        len = this.productions_[action[1]][1];
		                        yyval.$ = vstack[vstack.length - len];
		                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
		                        if (ranges) {
		                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
		                        }
		                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
		                        if (typeof r !== "undefined") {
		                            return r;
		                        }
		                        if (len) {
		                            stack = stack.slice(0, -1 * len * 2);
		                            vstack = vstack.slice(0, -1 * len);
		                            lstack = lstack.slice(0, -1 * len);
		                        }
		                        stack.push(this.productions_[action[1]][0]);
		                        vstack.push(yyval.$);
		                        lstack.push(yyval._$);
		                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
		                        stack.push(newState);
		                        break;
		                    case 3:
		                        return true;
		                }
		            }
		            return true;
		        }
		    };
		    /* Jison generated lexer */
		    var lexer = (function () {
		        var lexer = { EOF: 1,
		            parseError: function parseError(str, hash) {
		                if (this.yy.parser) {
		                    this.yy.parser.parseError(str, hash);
		                } else {
		                    throw new Error(str);
		                }
		            },
		            setInput: function setInput(input) {
		                this._input = input;
		                this._more = this._less = this.done = false;
		                this.yylineno = this.yyleng = 0;
		                this.yytext = this.matched = this.match = '';
		                this.conditionStack = ['INITIAL'];
		                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
		                if (this.options.ranges) this.yylloc.range = [0, 0];
		                this.offset = 0;
		                return this;
		            },
		            input: function input() {
		                var ch = this._input[0];
		                this.yytext += ch;
		                this.yyleng++;
		                this.offset++;
		                this.match += ch;
		                this.matched += ch;
		                var lines = ch.match(/(?:\r\n?|\n).*/g);
		                if (lines) {
		                    this.yylineno++;
		                    this.yylloc.last_line++;
		                } else {
		                    this.yylloc.last_column++;
		                }
		                if (this.options.ranges) this.yylloc.range[1]++;

		                this._input = this._input.slice(1);
		                return ch;
		            },
		            unput: function unput(ch) {
		                var len = ch.length;
		                var lines = ch.split(/(?:\r\n?|\n)/g);

		                this._input = ch + this._input;
		                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
		                //this.yyleng -= len;
		                this.offset -= len;
		                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
		                this.match = this.match.substr(0, this.match.length - 1);
		                this.matched = this.matched.substr(0, this.matched.length - 1);

		                if (lines.length - 1) this.yylineno -= lines.length - 1;
		                var r = this.yylloc.range;

		                this.yylloc = { first_line: this.yylloc.first_line,
		                    last_line: this.yylineno + 1,
		                    first_column: this.yylloc.first_column,
		                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
		                };

		                if (this.options.ranges) {
		                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
		                }
		                return this;
		            },
		            more: function more() {
		                this._more = true;
		                return this;
		            },
		            less: function less(n) {
		                this.unput(this.match.slice(n));
		            },
		            pastInput: function pastInput() {
		                var past = this.matched.substr(0, this.matched.length - this.match.length);
		                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
		            },
		            upcomingInput: function upcomingInput() {
		                var next = this.match;
		                if (next.length < 20) {
		                    next += this._input.substr(0, 20 - next.length);
		                }
		                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
		            },
		            showPosition: function showPosition() {
		                var pre = this.pastInput();
		                var c = new Array(pre.length + 1).join("-");
		                return pre + this.upcomingInput() + "\n" + c + "^";
		            },
		            next: function next() {
		                if (this.done) {
		                    return this.EOF;
		                }
		                if (!this._input) this.done = true;

		                var token, match, tempMatch, index, col, lines;
		                if (!this._more) {
		                    this.yytext = '';
		                    this.match = '';
		                }
		                var rules = this._currentRules();
		                for (var i = 0; i < rules.length; i++) {
		                    tempMatch = this._input.match(this.rules[rules[i]]);
		                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
		                        match = tempMatch;
		                        index = i;
		                        if (!this.options.flex) break;
		                    }
		                }
		                if (match) {
		                    lines = match[0].match(/(?:\r\n?|\n).*/g);
		                    if (lines) this.yylineno += lines.length;
		                    this.yylloc = { first_line: this.yylloc.last_line,
		                        last_line: this.yylineno + 1,
		                        first_column: this.yylloc.last_column,
		                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
		                    this.yytext += match[0];
		                    this.match += match[0];
		                    this.matches = match;
		                    this.yyleng = this.yytext.length;
		                    if (this.options.ranges) {
		                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
		                    }
		                    this._more = false;
		                    this._input = this._input.slice(match[0].length);
		                    this.matched += match[0];
		                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
		                    if (this.done && this._input) this.done = false;
		                    if (token) return token;else return;
		                }
		                if (this._input === "") {
		                    return this.EOF;
		                } else {
		                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
		                }
		            },
		            lex: function lex() {
		                var r = this.next();
		                if (typeof r !== 'undefined') {
		                    return r;
		                } else {
		                    return this.lex();
		                }
		            },
		            begin: function begin(condition) {
		                this.conditionStack.push(condition);
		            },
		            popState: function popState() {
		                return this.conditionStack.pop();
		            },
		            _currentRules: function _currentRules() {
		                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
		            },
		            topState: function topState() {
		                return this.conditionStack[this.conditionStack.length - 2];
		            },
		            pushState: function begin(condition) {
		                this.begin(condition);
		            } };
		        lexer.options = {};
		        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
		        /**/) {

		            function strip(start, end) {
		                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
		            }

		            var YYSTATE = YY_START;
		            switch ($avoiding_name_collisions) {
		                case 0:
		                    if (yy_.yytext.slice(-2) === "\\\\") {
		                        strip(0, 1);
		                        this.begin("mu");
		                    } else if (yy_.yytext.slice(-1) === "\\") {
		                        strip(0, 1);
		                        this.begin("emu");
		                    } else {
		                        this.begin("mu");
		                    }
		                    if (yy_.yytext) return 15;

		                    break;
		                case 1:
		                    return 15;
		                    break;
		                case 2:
		                    this.popState();
		                    return 15;

		                    break;
		                case 3:
		                    this.begin('raw');return 15;
		                    break;
		                case 4:
		                    this.popState();
		                    // Should be using `this.topState()` below, but it currently
		                    // returns the second top instead of the first top. Opened an
		                    // issue about it at https://github.com/zaach/jison/issues/291
		                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
		                        return 15;
		                    } else {
		                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
		                        return 'END_RAW_BLOCK';
		                    }

		                    break;
		                case 5:
		                    return 15;
		                    break;
		                case 6:
		                    this.popState();
		                    return 14;

		                    break;
		                case 7:
		                    return 65;
		                    break;
		                case 8:
		                    return 68;
		                    break;
		                case 9:
		                    return 19;
		                    break;
		                case 10:
		                    this.popState();
		                    this.begin('raw');
		                    return 23;

		                    break;
		                case 11:
		                    return 55;
		                    break;
		                case 12:
		                    return 60;
		                    break;
		                case 13:
		                    return 29;
		                    break;
		                case 14:
		                    return 47;
		                    break;
		                case 15:
		                    this.popState();return 44;
		                    break;
		                case 16:
		                    this.popState();return 44;
		                    break;
		                case 17:
		                    return 34;
		                    break;
		                case 18:
		                    return 39;
		                    break;
		                case 19:
		                    return 51;
		                    break;
		                case 20:
		                    return 48;
		                    break;
		                case 21:
		                    this.unput(yy_.yytext);
		                    this.popState();
		                    this.begin('com');

		                    break;
		                case 22:
		                    this.popState();
		                    return 14;

		                    break;
		                case 23:
		                    return 48;
		                    break;
		                case 24:
		                    return 73;
		                    break;
		                case 25:
		                    return 72;
		                    break;
		                case 26:
		                    return 72;
		                    break;
		                case 27:
		                    return 87;
		                    break;
		                case 28:
		                    // ignore whitespace
		                    break;
		                case 29:
		                    this.popState();return 54;
		                    break;
		                case 30:
		                    this.popState();return 33;
		                    break;
		                case 31:
		                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
		                    break;
		                case 32:
		                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
		                    break;
		                case 33:
		                    return 85;
		                    break;
		                case 34:
		                    return 82;
		                    break;
		                case 35:
		                    return 82;
		                    break;
		                case 36:
		                    return 83;
		                    break;
		                case 37:
		                    return 84;
		                    break;
		                case 38:
		                    return 81;
		                    break;
		                case 39:
		                    return 75;
		                    break;
		                case 40:
		                    return 77;
		                    break;
		                case 41:
		                    return 72;
		                    break;
		                case 42:
		                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
		                    break;
		                case 43:
		                    return 'INVALID';
		                    break;
		                case 44:
		                    return 5;
		                    break;
		            }
		        };
		        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
		        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
		        return lexer;
		    })();
		    parser.lexer = lexer;
		    function Parser() {
		        this.yy = {};
		    }Parser.prototype = parser;parser.Parser = Parser;
		    return new Parser();
		})();exports.__esModule = true;
		exports['default'] = handlebars;

	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _visitor = __webpack_require__(25);

		var _visitor2 = _interopRequireDefault(_visitor);

		function WhitespaceControl() {
		  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		  this.options = options;
		}
		WhitespaceControl.prototype = new _visitor2['default']();

		WhitespaceControl.prototype.Program = function (program) {
		  var doStandalone = !this.options.ignoreStandalone;

		  var isRoot = !this.isRootSeen;
		  this.isRootSeen = true;

		  var body = program.body;
		  for (var i = 0, l = body.length; i < l; i++) {
		    var current = body[i],
		        strip = this.accept(current);

		    if (!strip) {
		      continue;
		    }

		    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
		        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
		        openStandalone = strip.openStandalone && _isPrevWhitespace,
		        closeStandalone = strip.closeStandalone && _isNextWhitespace,
		        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

		    if (strip.close) {
		      omitRight(body, i, true);
		    }
		    if (strip.open) {
		      omitLeft(body, i, true);
		    }

		    if (doStandalone && inlineStandalone) {
		      omitRight(body, i);

		      if (omitLeft(body, i)) {
		        // If we are on a standalone node, save the indent info for partials
		        if (current.type === 'PartialStatement') {
		          // Pull out the whitespace from the final line
		          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
		        }
		      }
		    }
		    if (doStandalone && openStandalone) {
		      omitRight((current.program || current.inverse).body);

		      // Strip out the previous content node if it's whitespace only
		      omitLeft(body, i);
		    }
		    if (doStandalone && closeStandalone) {
		      // Always strip the next node
		      omitRight(body, i);

		      omitLeft((current.inverse || current.program).body);
		    }
		  }

		  return program;
		};

		WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
		  this.accept(block.program);
		  this.accept(block.inverse);

		  // Find the inverse program that is involed with whitespace stripping.
		  var program = block.program || block.inverse,
		      inverse = block.program && block.inverse,
		      firstInverse = inverse,
		      lastInverse = inverse;

		  if (inverse && inverse.chained) {
		    firstInverse = inverse.body[0].program;

		    // Walk the inverse chain to find the last inverse that is actually in the chain.
		    while (lastInverse.chained) {
		      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
		    }
		  }

		  var strip = {
		    open: block.openStrip.open,
		    close: block.closeStrip.close,

		    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
		    // so our parent can determine if we actually are standalone
		    openStandalone: isNextWhitespace(program.body),
		    closeStandalone: isPrevWhitespace((firstInverse || program).body)
		  };

		  if (block.openStrip.close) {
		    omitRight(program.body, null, true);
		  }

		  if (inverse) {
		    var inverseStrip = block.inverseStrip;

		    if (inverseStrip.open) {
		      omitLeft(program.body, null, true);
		    }

		    if (inverseStrip.close) {
		      omitRight(firstInverse.body, null, true);
		    }
		    if (block.closeStrip.open) {
		      omitLeft(lastInverse.body, null, true);
		    }

		    // Find standalone else statments
		    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
		      omitLeft(program.body);
		      omitRight(firstInverse.body);
		    }
		  } else if (block.closeStrip.open) {
		    omitLeft(program.body, null, true);
		  }

		  return strip;
		};

		WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
		  return mustache.strip;
		};

		WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
		  /* istanbul ignore next */
		  var strip = node.strip || {};
		  return {
		    inlineStandalone: true,
		    open: strip.open,
		    close: strip.close
		  };
		};

		function isPrevWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = body.length;
		  }

		  // Nodes that end with newlines are considered whitespace (but are special
		  // cased for strip operations)
		  var prev = body[i - 1],
		      sibling = body[i - 2];
		  if (!prev) {
		    return isRoot;
		  }

		  if (prev.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
		  }
		}
		function isNextWhitespace(body, i, isRoot) {
		  if (i === undefined) {
		    i = -1;
		  }

		  var next = body[i + 1],
		      sibling = body[i + 2];
		  if (!next) {
		    return isRoot;
		  }

		  if (next.type === 'ContentStatement') {
		    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
		  }
		}

		// Marks the node to the right of the position as omitted.
		// I.e. {{foo}}' ' will mark the ' ' node as omitted.
		//
		// If i is undefined, then the first child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitRight(body, i, multiple) {
		  var current = body[i == null ? 0 : i + 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
		    return;
		  }

		  var original = current.value;
		  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
		  current.rightStripped = current.value !== original;
		}

		// Marks the node to the left of the position as omitted.
		// I.e. ' '{{foo}} will mark the ' ' node as omitted.
		//
		// If i is undefined then the last child will be marked as such.
		//
		// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
		// content is met.
		function omitLeft(body, i, multiple) {
		  var current = body[i == null ? body.length - 1 : i - 1];
		  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
		    return;
		  }

		  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
		  var original = current.value;
		  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
		  current.leftStripped = current.value !== original;
		  return current.leftStripped;
		}

		exports['default'] = WhitespaceControl;
		module.exports = exports['default'];

	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		function Visitor() {
		  this.parents = [];
		}

		Visitor.prototype = {
		  constructor: Visitor,
		  mutating: false,

		  // Visits a given value. If mutating, will replace the value if necessary.
		  acceptKey: function acceptKey(node, name) {
		    var value = this.accept(node[name]);
		    if (this.mutating) {
		      // Hacky sanity check: This may have a few false positives for type for the helper
		      // methods but will generally do the right thing without a lot of overhead.
		      if (value && !Visitor.prototype[value.type]) {
		        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
		      }
		      node[name] = value;
		    }
		  },

		  // Performs an accept operation with added sanity check to ensure
		  // required keys are not removed.
		  acceptRequired: function acceptRequired(node, name) {
		    this.acceptKey(node, name);

		    if (!node[name]) {
		      throw new _exception2['default'](node.type + ' requires ' + name);
		    }
		  },

		  // Traverses a given array. If mutating, empty respnses will be removed
		  // for child elements.
		  acceptArray: function acceptArray(array) {
		    for (var i = 0, l = array.length; i < l; i++) {
		      this.acceptKey(array, i);

		      if (!array[i]) {
		        array.splice(i, 1);
		        i--;
		        l--;
		      }
		    }
		  },

		  accept: function accept(object) {
		    if (!object) {
		      return;
		    }

		    /* istanbul ignore next: Sanity code */
		    if (!this[object.type]) {
		      throw new _exception2['default']('Unknown type: ' + object.type, object);
		    }

		    if (this.current) {
		      this.parents.unshift(this.current);
		    }
		    this.current = object;

		    var ret = this[object.type](object);

		    this.current = this.parents.shift();

		    if (!this.mutating || ret) {
		      return ret;
		    } else if (ret !== false) {
		      return object;
		    }
		  },

		  Program: function Program(program) {
		    this.acceptArray(program.body);
		  },

		  MustacheStatement: visitSubExpression,
		  Decorator: visitSubExpression,

		  BlockStatement: visitBlock,
		  DecoratorBlock: visitBlock,

		  PartialStatement: visitPartial,
		  PartialBlockStatement: function PartialBlockStatement(partial) {
		    visitPartial.call(this, partial);

		    this.acceptKey(partial, 'program');
		  },

		  ContentStatement: function ContentStatement() /* content */{},
		  CommentStatement: function CommentStatement() /* comment */{},

		  SubExpression: visitSubExpression,

		  PathExpression: function PathExpression() /* path */{},

		  StringLiteral: function StringLiteral() /* string */{},
		  NumberLiteral: function NumberLiteral() /* number */{},
		  BooleanLiteral: function BooleanLiteral() /* bool */{},
		  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
		  NullLiteral: function NullLiteral() /* literal */{},

		  Hash: function Hash(hash) {
		    this.acceptArray(hash.pairs);
		  },
		  HashPair: function HashPair(pair) {
		    this.acceptRequired(pair, 'value');
		  }
		};

		function visitSubExpression(mustache) {
		  this.acceptRequired(mustache, 'path');
		  this.acceptArray(mustache.params);
		  this.acceptKey(mustache, 'hash');
		}
		function visitBlock(block) {
		  visitSubExpression.call(this, block);

		  this.acceptKey(block, 'program');
		  this.acceptKey(block, 'inverse');
		}
		function visitPartial(partial) {
		  this.acceptRequired(partial, 'name');
		  this.acceptArray(partial.params);
		  this.acceptKey(partial, 'hash');
		}

		exports['default'] = Visitor;
		module.exports = exports['default'];

	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.SourceLocation = SourceLocation;
		exports.id = id;
		exports.stripFlags = stripFlags;
		exports.stripComment = stripComment;
		exports.preparePath = preparePath;
		exports.prepareMustache = prepareMustache;
		exports.prepareRawBlock = prepareRawBlock;
		exports.prepareBlock = prepareBlock;
		exports.prepareProgram = prepareProgram;
		exports.preparePartialBlock = preparePartialBlock;

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		function validateClose(open, close) {
		  close = close.path ? close.path.original : close;

		  if (open.path.original !== close) {
		    var errorNode = { loc: open.path.loc };

		    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
		  }
		}

		function SourceLocation(source, locInfo) {
		  this.source = source;
		  this.start = {
		    line: locInfo.first_line,
		    column: locInfo.first_column
		  };
		  this.end = {
		    line: locInfo.last_line,
		    column: locInfo.last_column
		  };
		}

		function id(token) {
		  if (/^\[.*\]$/.test(token)) {
		    return token.substr(1, token.length - 2);
		  } else {
		    return token;
		  }
		}

		function stripFlags(open, close) {
		  return {
		    open: open.charAt(2) === '~',
		    close: close.charAt(close.length - 3) === '~'
		  };
		}

		function stripComment(comment) {
		  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
		}

		function preparePath(data, parts, loc) {
		  loc = this.locInfo(loc);

		  var original = data ? '@' : '',
		      dig = [],
		      depth = 0,
		      depthString = '';

		  for (var i = 0, l = parts.length; i < l; i++) {
		    var part = parts[i].part,

		    // If we have [] syntax then we do not treat path references as operators,
		    // i.e. foo.[this] resolves to approximately context.foo['this']
		    isLiteral = parts[i].original !== part;
		    original += (parts[i].separator || '') + part;

		    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
		      if (dig.length > 0) {
		        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
		      } else if (part === '..') {
		        depth++;
		        depthString += '../';
		      }
		    } else {
		      dig.push(part);
		    }
		  }

		  return {
		    type: 'PathExpression',
		    data: data,
		    depth: depth,
		    parts: dig,
		    original: original,
		    loc: loc
		  };
		}

		function prepareMustache(path, params, hash, open, strip, locInfo) {
		  // Must use charAt to support IE pre-10
		  var escapeFlag = open.charAt(3) || open.charAt(2),
		      escaped = escapeFlag !== '{' && escapeFlag !== '&';

		  var decorator = /\*/.test(open);
		  return {
		    type: decorator ? 'Decorator' : 'MustacheStatement',
		    path: path,
		    params: params,
		    hash: hash,
		    escaped: escaped,
		    strip: strip,
		    loc: this.locInfo(locInfo)
		  };
		}

		function prepareRawBlock(openRawBlock, contents, close, locInfo) {
		  validateClose(openRawBlock, close);

		  locInfo = this.locInfo(locInfo);
		  var program = {
		    type: 'Program',
		    body: contents,
		    strip: {},
		    loc: locInfo
		  };

		  return {
		    type: 'BlockStatement',
		    path: openRawBlock.path,
		    params: openRawBlock.params,
		    hash: openRawBlock.hash,
		    program: program,
		    openStrip: {},
		    inverseStrip: {},
		    closeStrip: {},
		    loc: locInfo
		  };
		}

		function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
		  if (close && close.path) {
		    validateClose(openBlock, close);
		  }

		  var decorator = /\*/.test(openBlock.open);

		  program.blockParams = openBlock.blockParams;

		  var inverse = undefined,
		      inverseStrip = undefined;

		  if (inverseAndProgram) {
		    if (decorator) {
		      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
		    }

		    if (inverseAndProgram.chain) {
		      inverseAndProgram.program.body[0].closeStrip = close.strip;
		    }

		    inverseStrip = inverseAndProgram.strip;
		    inverse = inverseAndProgram.program;
		  }

		  if (inverted) {
		    inverted = inverse;
		    inverse = program;
		    program = inverted;
		  }

		  return {
		    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
		    path: openBlock.path,
		    params: openBlock.params,
		    hash: openBlock.hash,
		    program: program,
		    inverse: inverse,
		    openStrip: openBlock.strip,
		    inverseStrip: inverseStrip,
		    closeStrip: close && close.strip,
		    loc: this.locInfo(locInfo)
		  };
		}

		function prepareProgram(statements, loc) {
		  if (!loc && statements.length) {
		    var firstLoc = statements[0].loc,
		        lastLoc = statements[statements.length - 1].loc;

		    /* istanbul ignore else */
		    if (firstLoc && lastLoc) {
		      loc = {
		        source: firstLoc.source,
		        start: {
		          line: firstLoc.start.line,
		          column: firstLoc.start.column
		        },
		        end: {
		          line: lastLoc.end.line,
		          column: lastLoc.end.column
		        }
		      };
		    }
		  }

		  return {
		    type: 'Program',
		    body: statements,
		    strip: {},
		    loc: loc
		  };
		}

		function preparePartialBlock(open, program, close, locInfo) {
		  validateClose(open, close);

		  return {
		    type: 'PartialBlockStatement',
		    name: open.path,
		    params: open.params,
		    hash: open.hash,
		    program: program,
		    openStrip: open.strip,
		    closeStrip: close && close.strip,
		    loc: this.locInfo(locInfo)
		  };
		}

	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {

		/* eslint-disable new-cap */

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;
		exports.Compiler = Compiler;
		exports.precompile = precompile;
		exports.compile = compile;

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		var _utils = __webpack_require__(5);

		var _ast = __webpack_require__(21);

		var _ast2 = _interopRequireDefault(_ast);

		var slice = [].slice;

		function Compiler() {}

		// the foundHelper register will disambiguate helper lookup from finding a
		// function in a context. This is necessary for mustache compatibility, which
		// requires that context functions in blocks are evaluated by blockHelperMissing,
		// and then proceed as if the resulting value was provided to blockHelperMissing.

		Compiler.prototype = {
		  compiler: Compiler,

		  equals: function equals(other) {
		    var len = this.opcodes.length;
		    if (other.opcodes.length !== len) {
		      return false;
		    }

		    for (var i = 0; i < len; i++) {
		      var opcode = this.opcodes[i],
		          otherOpcode = other.opcodes[i];
		      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
		        return false;
		      }
		    }

		    // We know that length is the same between the two arrays because they are directly tied
		    // to the opcode behavior above.
		    len = this.children.length;
		    for (var i = 0; i < len; i++) {
		      if (!this.children[i].equals(other.children[i])) {
		        return false;
		      }
		    }

		    return true;
		  },

		  guid: 0,

		  compile: function compile(program, options) {
		    this.sourceNode = [];
		    this.opcodes = [];
		    this.children = [];
		    this.options = options;
		    this.stringParams = options.stringParams;
		    this.trackIds = options.trackIds;

		    options.blockParams = options.blockParams || [];

		    // These changes will propagate to the other compiler components
		    var knownHelpers = options.knownHelpers;
		    options.knownHelpers = {
		      'helperMissing': true,
		      'blockHelperMissing': true,
		      'each': true,
		      'if': true,
		      'unless': true,
		      'with': true,
		      'log': true,
		      'lookup': true
		    };
		    if (knownHelpers) {
		      for (var _name in knownHelpers) {
		        /* istanbul ignore else */
		        if (_name in knownHelpers) {
		          options.knownHelpers[_name] = knownHelpers[_name];
		        }
		      }
		    }

		    return this.accept(program);
		  },

		  compileProgram: function compileProgram(program) {
		    var childCompiler = new this.compiler(),
		        // eslint-disable-line new-cap
		    result = childCompiler.compile(program, this.options),
		        guid = this.guid++;

		    this.usePartial = this.usePartial || result.usePartial;

		    this.children[guid] = result;
		    this.useDepths = this.useDepths || result.useDepths;

		    return guid;
		  },

		  accept: function accept(node) {
		    /* istanbul ignore next: Sanity code */
		    if (!this[node.type]) {
		      throw new _exception2['default']('Unknown type: ' + node.type, node);
		    }

		    this.sourceNode.unshift(node);
		    var ret = this[node.type](node);
		    this.sourceNode.shift();
		    return ret;
		  },

		  Program: function Program(program) {
		    this.options.blockParams.unshift(program.blockParams);

		    var body = program.body,
		        bodyLength = body.length;
		    for (var i = 0; i < bodyLength; i++) {
		      this.accept(body[i]);
		    }

		    this.options.blockParams.shift();

		    this.isSimple = bodyLength === 1;
		    this.blockParams = program.blockParams ? program.blockParams.length : 0;

		    return this;
		  },

		  BlockStatement: function BlockStatement(block) {
		    transformLiteralToPath(block);

		    var program = block.program,
		        inverse = block.inverse;

		    program = program && this.compileProgram(program);
		    inverse = inverse && this.compileProgram(inverse);

		    var type = this.classifySexpr(block);

		    if (type === 'helper') {
		      this.helperSexpr(block, program, inverse);
		    } else if (type === 'simple') {
		      this.simpleSexpr(block);

		      // now that the simple mustache is resolved, we need to
		      // evaluate it by executing `blockHelperMissing`
		      this.opcode('pushProgram', program);
		      this.opcode('pushProgram', inverse);
		      this.opcode('emptyHash');
		      this.opcode('blockValue', block.path.original);
		    } else {
		      this.ambiguousSexpr(block, program, inverse);

		      // now that the simple mustache is resolved, we need to
		      // evaluate it by executing `blockHelperMissing`
		      this.opcode('pushProgram', program);
		      this.opcode('pushProgram', inverse);
		      this.opcode('emptyHash');
		      this.opcode('ambiguousBlockValue');
		    }

		    this.opcode('append');
		  },

		  DecoratorBlock: function DecoratorBlock(decorator) {
		    var program = decorator.program && this.compileProgram(decorator.program);
		    var params = this.setupFullMustacheParams(decorator, program, undefined),
		        path = decorator.path;

		    this.useDecorators = true;
		    this.opcode('registerDecorator', params.length, path.original);
		  },

		  PartialStatement: function PartialStatement(partial) {
		    this.usePartial = true;

		    var program = partial.program;
		    if (program) {
		      program = this.compileProgram(partial.program);
		    }

		    var params = partial.params;
		    if (params.length > 1) {
		      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
		    } else if (!params.length) {
		      if (this.options.explicitPartialContext) {
		        this.opcode('pushLiteral', 'undefined');
		      } else {
		        params.push({ type: 'PathExpression', parts: [], depth: 0 });
		      }
		    }

		    var partialName = partial.name.original,
		        isDynamic = partial.name.type === 'SubExpression';
		    if (isDynamic) {
		      this.accept(partial.name);
		    }

		    this.setupFullMustacheParams(partial, program, undefined, true);

		    var indent = partial.indent || '';
		    if (this.options.preventIndent && indent) {
		      this.opcode('appendContent', indent);
		      indent = '';
		    }

		    this.opcode('invokePartial', isDynamic, partialName, indent);
		    this.opcode('append');
		  },
		  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
		    this.PartialStatement(partialBlock);
		  },

		  MustacheStatement: function MustacheStatement(mustache) {
		    this.SubExpression(mustache);

		    if (mustache.escaped && !this.options.noEscape) {
		      this.opcode('appendEscaped');
		    } else {
		      this.opcode('append');
		    }
		  },
		  Decorator: function Decorator(decorator) {
		    this.DecoratorBlock(decorator);
		  },

		  ContentStatement: function ContentStatement(content) {
		    if (content.value) {
		      this.opcode('appendContent', content.value);
		    }
		  },

		  CommentStatement: function CommentStatement() {},

		  SubExpression: function SubExpression(sexpr) {
		    transformLiteralToPath(sexpr);
		    var type = this.classifySexpr(sexpr);

		    if (type === 'simple') {
		      this.simpleSexpr(sexpr);
		    } else if (type === 'helper') {
		      this.helperSexpr(sexpr);
		    } else {
		      this.ambiguousSexpr(sexpr);
		    }
		  },
		  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
		    var path = sexpr.path,
		        name = path.parts[0],
		        isBlock = program != null || inverse != null;

		    this.opcode('getContext', path.depth);

		    this.opcode('pushProgram', program);
		    this.opcode('pushProgram', inverse);

		    path.strict = true;
		    this.accept(path);

		    this.opcode('invokeAmbiguous', name, isBlock);
		  },

		  simpleSexpr: function simpleSexpr(sexpr) {
		    var path = sexpr.path;
		    path.strict = true;
		    this.accept(path);
		    this.opcode('resolvePossibleLambda');
		  },

		  helperSexpr: function helperSexpr(sexpr, program, inverse) {
		    var params = this.setupFullMustacheParams(sexpr, program, inverse),
		        path = sexpr.path,
		        name = path.parts[0];

		    if (this.options.knownHelpers[name]) {
		      this.opcode('invokeKnownHelper', params.length, name);
		    } else if (this.options.knownHelpersOnly) {
		      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
		    } else {
		      path.strict = true;
		      path.falsy = true;

		      this.accept(path);
		      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
		    }
		  },

		  PathExpression: function PathExpression(path) {
		    this.addDepth(path.depth);
		    this.opcode('getContext', path.depth);

		    var name = path.parts[0],
		        scoped = _ast2['default'].helpers.scopedId(path),
		        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

		    if (blockParamId) {
		      this.opcode('lookupBlockParam', blockParamId, path.parts);
		    } else if (!name) {
		      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
		      this.opcode('pushContext');
		    } else if (path.data) {
		      this.options.data = true;
		      this.opcode('lookupData', path.depth, path.parts, path.strict);
		    } else {
		      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
		    }
		  },

		  StringLiteral: function StringLiteral(string) {
		    this.opcode('pushString', string.value);
		  },

		  NumberLiteral: function NumberLiteral(number) {
		    this.opcode('pushLiteral', number.value);
		  },

		  BooleanLiteral: function BooleanLiteral(bool) {
		    this.opcode('pushLiteral', bool.value);
		  },

		  UndefinedLiteral: function UndefinedLiteral() {
		    this.opcode('pushLiteral', 'undefined');
		  },

		  NullLiteral: function NullLiteral() {
		    this.opcode('pushLiteral', 'null');
		  },

		  Hash: function Hash(hash) {
		    var pairs = hash.pairs,
		        i = 0,
		        l = pairs.length;

		    this.opcode('pushHash');

		    for (; i < l; i++) {
		      this.pushParam(pairs[i].value);
		    }
		    while (i--) {
		      this.opcode('assignToHash', pairs[i].key);
		    }
		    this.opcode('popHash');
		  },

		  // HELPERS
		  opcode: function opcode(name) {
		    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
		  },

		  addDepth: function addDepth(depth) {
		    if (!depth) {
		      return;
		    }

		    this.useDepths = true;
		  },

		  classifySexpr: function classifySexpr(sexpr) {
		    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

		    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

		    // a mustache is an eligible helper if:
		    // * its id is simple (a single part, not `this` or `..`)
		    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

		    // if a mustache is an eligible helper but not a definite
		    // helper, it is ambiguous, and will be resolved in a later
		    // pass or at runtime.
		    var isEligible = !isBlockParam && (isHelper || isSimple);

		    // if ambiguous, we can possibly resolve the ambiguity now
		    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
		    if (isEligible && !isHelper) {
		      var _name2 = sexpr.path.parts[0],
		          options = this.options;

		      if (options.knownHelpers[_name2]) {
		        isHelper = true;
		      } else if (options.knownHelpersOnly) {
		        isEligible = false;
		      }
		    }

		    if (isHelper) {
		      return 'helper';
		    } else if (isEligible) {
		      return 'ambiguous';
		    } else {
		      return 'simple';
		    }
		  },

		  pushParams: function pushParams(params) {
		    for (var i = 0, l = params.length; i < l; i++) {
		      this.pushParam(params[i]);
		    }
		  },

		  pushParam: function pushParam(val) {
		    var value = val.value != null ? val.value : val.original || '';

		    if (this.stringParams) {
		      if (value.replace) {
		        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
		      }

		      if (val.depth) {
		        this.addDepth(val.depth);
		      }
		      this.opcode('getContext', val.depth || 0);
		      this.opcode('pushStringParam', value, val.type);

		      if (val.type === 'SubExpression') {
		        // SubExpressions get evaluated and passed in
		        // in string params mode.
		        this.accept(val);
		      }
		    } else {
		      if (this.trackIds) {
		        var blockParamIndex = undefined;
		        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
		          blockParamIndex = this.blockParamIndex(val.parts[0]);
		        }
		        if (blockParamIndex) {
		          var blockParamChild = val.parts.slice(1).join('.');
		          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
		        } else {
		          value = val.original || value;
		          if (value.replace) {
		            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
		          }

		          this.opcode('pushId', val.type, value);
		        }
		      }
		      this.accept(val);
		    }
		  },

		  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
		    var params = sexpr.params;
		    this.pushParams(params);

		    this.opcode('pushProgram', program);
		    this.opcode('pushProgram', inverse);

		    if (sexpr.hash) {
		      this.accept(sexpr.hash);
		    } else {
		      this.opcode('emptyHash', omitEmpty);
		    }

		    return params;
		  },

		  blockParamIndex: function blockParamIndex(name) {
		    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
		      var blockParams = this.options.blockParams[depth],
		          param = blockParams && _utils.indexOf(blockParams, name);
		      if (blockParams && param >= 0) {
		        return [depth, param];
		      }
		    }
		  }
		};

		function precompile(input, options, env) {
		  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
		    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
		  }

		  options = options || {};
		  if (!('data' in options)) {
		    options.data = true;
		  }
		  if (options.compat) {
		    options.useDepths = true;
		  }

		  var ast = env.parse(input, options),
		      environment = new env.Compiler().compile(ast, options);
		  return new env.JavaScriptCompiler().compile(environment, options);
		}

		function compile(input, options, env) {
		  if (options === undefined) options = {};

		  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
		    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
		  }

		  if (!('data' in options)) {
		    options.data = true;
		  }
		  if (options.compat) {
		    options.useDepths = true;
		  }

		  var compiled = undefined;

		  function compileInput() {
		    var ast = env.parse(input, options),
		        environment = new env.Compiler().compile(ast, options),
		        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
		    return env.template(templateSpec);
		  }

		  // Template is only compiled on first use and cached after that point.
		  function ret(context, execOptions) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled.call(this, context, execOptions);
		  }
		  ret._setup = function (setupOptions) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled._setup(setupOptions);
		  };
		  ret._child = function (i, data, blockParams, depths) {
		    if (!compiled) {
		      compiled = compileInput();
		    }
		    return compiled._child(i, data, blockParams, depths);
		  };
		  return ret;
		}

		function argEquals(a, b) {
		  if (a === b) {
		    return true;
		  }

		  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
		    for (var i = 0; i < a.length; i++) {
		      if (!argEquals(a[i], b[i])) {
		        return false;
		      }
		    }
		    return true;
		  }
		}

		function transformLiteralToPath(sexpr) {
		  if (!sexpr.path.parts) {
		    var literal = sexpr.path;
		    // Casting to string here to make false and 0 literal values play nicely with the rest
		    // of the system.
		    sexpr.path = {
		      type: 'PathExpression',
		      data: false,
		      depth: 0,
		      parts: [literal.original + ''],
		      original: literal.original + '',
		      loc: literal.loc
		    };
		  }
		}

	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var _interopRequireDefault = __webpack_require__(1)['default'];

		exports.__esModule = true;

		var _base = __webpack_require__(4);

		var _exception = __webpack_require__(6);

		var _exception2 = _interopRequireDefault(_exception);

		var _utils = __webpack_require__(5);

		var _codeGen = __webpack_require__(29);

		var _codeGen2 = _interopRequireDefault(_codeGen);

		function Literal(value) {
		  this.value = value;
		}

		function JavaScriptCompiler() {}

		JavaScriptCompiler.prototype = {
		  // PUBLIC API: You can override these methods in a subclass to provide
		  // alternative compiled forms for name lookup and buffering semantics
		  nameLookup: function nameLookup(parent, name /* , type*/) {
		    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
		      return [parent, '.', name];
		    } else {
		      return [parent, '[', JSON.stringify(name), ']'];
		    }
		  },
		  depthedLookup: function depthedLookup(name) {
		    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
		  },

		  compilerInfo: function compilerInfo() {
		    var revision = _base.COMPILER_REVISION,
		        versions = _base.REVISION_CHANGES[revision];
		    return [revision, versions];
		  },

		  appendToBuffer: function appendToBuffer(source, location, explicit) {
		    // Force a source as this simplifies the merge logic.
		    if (!_utils.isArray(source)) {
		      source = [source];
		    }
		    source = this.source.wrap(source, location);

		    if (this.environment.isSimple) {
		      return ['return ', source, ';'];
		    } else if (explicit) {
		      // This is a case where the buffer operation occurs as a child of another
		      // construct, generally braces. We have to explicitly output these buffer
		      // operations to ensure that the emitted code goes in the correct location.
		      return ['buffer += ', source, ';'];
		    } else {
		      source.appendToBuffer = true;
		      return source;
		    }
		  },

		  initializeBuffer: function initializeBuffer() {
		    return this.quotedString('');
		  },
		  // END PUBLIC API

		  compile: function compile(environment, options, context, asObject) {
		    this.environment = environment;
		    this.options = options;
		    this.stringParams = this.options.stringParams;
		    this.trackIds = this.options.trackIds;
		    this.precompile = !asObject;

		    this.name = this.environment.name;
		    this.isChild = !!context;
		    this.context = context || {
		      decorators: [],
		      programs: [],
		      environments: []
		    };

		    this.preamble();

		    this.stackSlot = 0;
		    this.stackVars = [];
		    this.aliases = {};
		    this.registers = { list: [] };
		    this.hashes = [];
		    this.compileStack = [];
		    this.inlineStack = [];
		    this.blockParams = [];

		    this.compileChildren(environment, options);

		    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
		    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

		    var opcodes = environment.opcodes,
		        opcode = undefined,
		        firstLoc = undefined,
		        i = undefined,
		        l = undefined;

		    for (i = 0, l = opcodes.length; i < l; i++) {
		      opcode = opcodes[i];

		      this.source.currentLocation = opcode.loc;
		      firstLoc = firstLoc || opcode.loc;
		      this[opcode.opcode].apply(this, opcode.args);
		    }

		    // Flush any trailing content that might be pending.
		    this.source.currentLocation = firstLoc;
		    this.pushSource('');

		    /* istanbul ignore next */
		    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
		      throw new _exception2['default']('Compile completed with content left on stack');
		    }

		    if (!this.decorators.isEmpty()) {
		      this.useDecorators = true;

		      this.decorators.prepend('var decorators = container.decorators;\n');
		      this.decorators.push('return fn;');

		      if (asObject) {
		        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
		      } else {
		        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
		        this.decorators.push('}\n');
		        this.decorators = this.decorators.merge();
		      }
		    } else {
		      this.decorators = undefined;
		    }

		    var fn = this.createFunctionContext(asObject);
		    if (!this.isChild) {
		      var ret = {
		        compiler: this.compilerInfo(),
		        main: fn
		      };

		      if (this.decorators) {
		        ret.main_d = this.decorators; // eslint-disable-line camelcase
		        ret.useDecorators = true;
		      }

		      var _context = this.context;
		      var programs = _context.programs;
		      var decorators = _context.decorators;

		      for (i = 0, l = programs.length; i < l; i++) {
		        if (programs[i]) {
		          ret[i] = programs[i];
		          if (decorators[i]) {
		            ret[i + '_d'] = decorators[i];
		            ret.useDecorators = true;
		          }
		        }
		      }

		      if (this.environment.usePartial) {
		        ret.usePartial = true;
		      }
		      if (this.options.data) {
		        ret.useData = true;
		      }
		      if (this.useDepths) {
		        ret.useDepths = true;
		      }
		      if (this.useBlockParams) {
		        ret.useBlockParams = true;
		      }
		      if (this.options.compat) {
		        ret.compat = true;
		      }

		      if (!asObject) {
		        ret.compiler = JSON.stringify(ret.compiler);

		        this.source.currentLocation = { start: { line: 1, column: 0 } };
		        ret = this.objectLiteral(ret);

		        if (options.srcName) {
		          ret = ret.toStringWithSourceMap({ file: options.destName });
		          ret.map = ret.map && ret.map.toString();
		        } else {
		          ret = ret.toString();
		        }
		      } else {
		        ret.compilerOptions = this.options;
		      }

		      return ret;
		    } else {
		      return fn;
		    }
		  },

		  preamble: function preamble() {
		    // track the last context pushed into place to allow skipping the
		    // getContext opcode when it would be a noop
		    this.lastContext = 0;
		    this.source = new _codeGen2['default'](this.options.srcName);
		    this.decorators = new _codeGen2['default'](this.options.srcName);
		  },

		  createFunctionContext: function createFunctionContext(asObject) {
		    var varDeclarations = '';

		    var locals = this.stackVars.concat(this.registers.list);
		    if (locals.length > 0) {
		      varDeclarations += ', ' + locals.join(', ');
		    }

		    // Generate minimizer alias mappings
		    //
		    // When using true SourceNodes, this will update all references to the given alias
		    // as the source nodes are reused in situ. For the non-source node compilation mode,
		    // aliases will not be used, but this case is already being run on the client and
		    // we aren't concern about minimizing the template size.
		    var aliasCount = 0;
		    for (var alias in this.aliases) {
		      // eslint-disable-line guard-for-in
		      var node = this.aliases[alias];

		      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
		        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
		        node.children[0] = 'alias' + aliasCount;
		      }
		    }

		    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

		    if (this.useBlockParams || this.useDepths) {
		      params.push('blockParams');
		    }
		    if (this.useDepths) {
		      params.push('depths');
		    }

		    // Perform a second pass over the output to merge content when possible
		    var source = this.mergeSource(varDeclarations);

		    if (asObject) {
		      params.push(source);

		      return Function.apply(this, params);
		    } else {
		      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
		    }
		  },
		  mergeSource: function mergeSource(varDeclarations) {
		    var isSimple = this.environment.isSimple,
		        appendOnly = !this.forceBuffer,
		        appendFirst = undefined,
		        sourceSeen = undefined,
		        bufferStart = undefined,
		        bufferEnd = undefined;
		    this.source.each(function (line) {
		      if (line.appendToBuffer) {
		        if (bufferStart) {
		          line.prepend('  + ');
		        } else {
		          bufferStart = line;
		        }
		        bufferEnd = line;
		      } else {
		        if (bufferStart) {
		          if (!sourceSeen) {
		            appendFirst = true;
		          } else {
		            bufferStart.prepend('buffer += ');
		          }
		          bufferEnd.add(';');
		          bufferStart = bufferEnd = undefined;
		        }

		        sourceSeen = true;
		        if (!isSimple) {
		          appendOnly = false;
		        }
		      }
		    });

		    if (appendOnly) {
		      if (bufferStart) {
		        bufferStart.prepend('return ');
		        bufferEnd.add(';');
		      } else if (!sourceSeen) {
		        this.source.push('return "";');
		      }
		    } else {
		      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

		      if (bufferStart) {
		        bufferStart.prepend('return buffer + ');
		        bufferEnd.add(';');
		      } else {
		        this.source.push('return buffer;');
		      }
		    }

		    if (varDeclarations) {
		      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
		    }

		    return this.source.merge();
		  },

		  // [blockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // On stack, after: return value of blockHelperMissing
		  //
		  // The purpose of this opcode is to take a block of the form
		  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
		  // replace it on the stack with the result of properly
		  // invoking blockHelperMissing.
		  blockValue: function blockValue(name) {
		    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs(name, 0, params);

		    var blockName = this.popStack();
		    params.splice(1, 0, blockName);

		    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
		  },

		  // [ambiguousBlockValue]
		  //
		  // On stack, before: hash, inverse, program, value
		  // Compiler value, before: lastHelper=value of last found helper, if any
		  // On stack, after, if no lastHelper: same as [blockValue]
		  // On stack, after, if lastHelper: value
		  ambiguousBlockValue: function ambiguousBlockValue() {
		    // We're being a bit cheeky and reusing the options value from the prior exec
		    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
		        params = [this.contextName(0)];
		    this.setupHelperArgs('', 0, params, true);

		    this.flushInline();

		    var current = this.topStack();
		    params.splice(1, 0, current);

		    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
		  },

		  // [appendContent]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  //
		  // Appends the string value of `content` to the current buffer
		  appendContent: function appendContent(content) {
		    if (this.pendingContent) {
		      content = this.pendingContent + content;
		    } else {
		      this.pendingLocation = this.source.currentLocation;
		    }

		    this.pendingContent = content;
		  },

		  // [append]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Coerces `value` to a String and appends it to the current buffer.
		  //
		  // If `value` is truthy, or 0, it is coerced into a string and appended
		  // Otherwise, the empty string is appended
		  append: function append() {
		    if (this.isInline()) {
		      this.replaceStack(function (current) {
		        return [' != null ? ', current, ' : ""'];
		      });

		      this.pushSource(this.appendToBuffer(this.popStack()));
		    } else {
		      var local = this.popStack();
		      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
		      if (this.environment.isSimple) {
		        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
		      }
		    }
		  },

		  // [appendEscaped]
		  //
		  // On stack, before: value, ...
		  // On stack, after: ...
		  //
		  // Escape `value` and append it to the buffer
		  appendEscaped: function appendEscaped() {
		    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
		  },

		  // [getContext]
		  //
		  // On stack, before: ...
		  // On stack, after: ...
		  // Compiler value, after: lastContext=depth
		  //
		  // Set the value of the `lastContext` compiler value to the depth
		  getContext: function getContext(depth) {
		    this.lastContext = depth;
		  },

		  // [pushContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext, ...
		  //
		  // Pushes the value of the current context onto the stack.
		  pushContext: function pushContext() {
		    this.pushStackLiteral(this.contextName(this.lastContext));
		  },

		  // [lookupOnContext]
		  //
		  // On stack, before: ...
		  // On stack, after: currentContext[name], ...
		  //
		  // Looks up the value of `name` on the current context and pushes
		  // it onto the stack.
		  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
		    var i = 0;

		    if (!scoped && this.options.compat && !this.lastContext) {
		      // The depthed query is expected to handle the undefined logic for the root level that
		      // is implemented below, so we evaluate that directly in compat mode
		      this.push(this.depthedLookup(parts[i++]));
		    } else {
		      this.pushContext();
		    }

		    this.resolvePath('context', parts, i, falsy, strict);
		  },

		  // [lookupBlockParam]
		  //
		  // On stack, before: ...
		  // On stack, after: blockParam[name], ...
		  //
		  // Looks up the value of `parts` on the given block param and pushes
		  // it onto the stack.
		  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
		    this.useBlockParams = true;

		    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
		    this.resolvePath('context', parts, 1);
		  },

		  // [lookupData]
		  //
		  // On stack, before: ...
		  // On stack, after: data, ...
		  //
		  // Push the data lookup operator
		  lookupData: function lookupData(depth, parts, strict) {
		    if (!depth) {
		      this.pushStackLiteral('data');
		    } else {
		      this.pushStackLiteral('container.data(data, ' + depth + ')');
		    }

		    this.resolvePath('data', parts, 0, true, strict);
		  },

		  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
		    // istanbul ignore next

		    var _this = this;

		    if (this.options.strict || this.options.assumeObjects) {
		      this.push(strictLookup(this.options.strict && strict, this, parts, type));
		      return;
		    }

		    var len = parts.length;
		    for (; i < len; i++) {
		      /* eslint-disable no-loop-func */
		      this.replaceStack(function (current) {
		        var lookup = _this.nameLookup(current, parts[i], type);
		        // We want to ensure that zero and false are handled properly if the context (falsy flag)
		        // needs to have the special handling for these values.
		        if (!falsy) {
		          return [' != null ? ', lookup, ' : ', current];
		        } else {
		          // Otherwise we can use generic falsy handling
		          return [' && ', lookup];
		        }
		      });
		      /* eslint-enable no-loop-func */
		    }
		  },

		  // [resolvePossibleLambda]
		  //
		  // On stack, before: value, ...
		  // On stack, after: resolved value, ...
		  //
		  // If the `value` is a lambda, replace it on the stack by
		  // the return value of the lambda
		  resolvePossibleLambda: function resolvePossibleLambda() {
		    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
		  },

		  // [pushStringParam]
		  //
		  // On stack, before: ...
		  // On stack, after: string, currentContext, ...
		  //
		  // This opcode is designed for use in string mode, which
		  // provides the string value of a parameter along with its
		  // depth rather than resolving it immediately.
		  pushStringParam: function pushStringParam(string, type) {
		    this.pushContext();
		    this.pushString(type);

		    // If it's a subexpression, the string result
		    // will be pushed after this opcode.
		    if (type !== 'SubExpression') {
		      if (typeof string === 'string') {
		        this.pushString(string);
		      } else {
		        this.pushStackLiteral(string);
		      }
		    }
		  },

		  emptyHash: function emptyHash(omitEmpty) {
		    if (this.trackIds) {
		      this.push('{}'); // hashIds
		    }
		    if (this.stringParams) {
		      this.push('{}'); // hashContexts
		      this.push('{}'); // hashTypes
		    }
		    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
		  },
		  pushHash: function pushHash() {
		    if (this.hash) {
		      this.hashes.push(this.hash);
		    }
		    this.hash = { values: [], types: [], contexts: [], ids: [] };
		  },
		  popHash: function popHash() {
		    var hash = this.hash;
		    this.hash = this.hashes.pop();

		    if (this.trackIds) {
		      this.push(this.objectLiteral(hash.ids));
		    }
		    if (this.stringParams) {
		      this.push(this.objectLiteral(hash.contexts));
		      this.push(this.objectLiteral(hash.types));
		    }

		    this.push(this.objectLiteral(hash.values));
		  },

		  // [pushString]
		  //
		  // On stack, before: ...
		  // On stack, after: quotedString(string), ...
		  //
		  // Push a quoted version of `string` onto the stack
		  pushString: function pushString(string) {
		    this.pushStackLiteral(this.quotedString(string));
		  },

		  // [pushLiteral]
		  //
		  // On stack, before: ...
		  // On stack, after: value, ...
		  //
		  // Pushes a value onto the stack. This operation prevents
		  // the compiler from creating a temporary variable to hold
		  // it.
		  pushLiteral: function pushLiteral(value) {
		    this.pushStackLiteral(value);
		  },

		  // [pushProgram]
		  //
		  // On stack, before: ...
		  // On stack, after: program(guid), ...
		  //
		  // Push a program expression onto the stack. This takes
		  // a compile-time guid and converts it into a runtime-accessible
		  // expression.
		  pushProgram: function pushProgram(guid) {
		    if (guid != null) {
		      this.pushStackLiteral(this.programExpression(guid));
		    } else {
		      this.pushStackLiteral(null);
		    }
		  },

		  // [registerDecorator]
		  //
		  // On stack, before: hash, program, params..., ...
		  // On stack, after: ...
		  //
		  // Pops off the decorator's parameters, invokes the decorator,
		  // and inserts the decorator into the decorators list.
		  registerDecorator: function registerDecorator(paramSize, name) {
		    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
		        options = this.setupHelperArgs(name, paramSize);

		    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
		  },

		  // [invokeHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // Pops off the helper's parameters, invokes the helper,
		  // and pushes the helper's return value onto the stack.
		  //
		  // If the helper is not found, `helperMissing` is called.
		  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
		    var nonHelper = this.popStack(),
		        helper = this.setupHelper(paramSize, name),
		        simple = isSimple ? [helper.name, ' || '] : '';

		    var lookup = ['('].concat(simple, nonHelper);
		    if (!this.options.strict) {
		      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
		    }
		    lookup.push(')');

		    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
		  },

		  // [invokeKnownHelper]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of helper invocation
		  //
		  // This operation is used when the helper is known to exist,
		  // so a `helperMissing` fallback is not required.
		  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
		    var helper = this.setupHelper(paramSize, name);
		    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
		  },

		  // [invokeAmbiguous]
		  //
		  // On stack, before: hash, inverse, program, params..., ...
		  // On stack, after: result of disambiguation
		  //
		  // This operation is used when an expression like `{{foo}}`
		  // is provided, but we don't know at compile-time whether it
		  // is a helper or a path.
		  //
		  // This operation emits more code than the other options,
		  // and can be avoided by passing the `knownHelpers` and
		  // `knownHelpersOnly` flags at compile-time.
		  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
		    this.useRegister('helper');

		    var nonHelper = this.popStack();

		    this.emptyHash();
		    var helper = this.setupHelper(0, name, helperCall);

		    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

		    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
		    if (!this.options.strict) {
		      lookup[0] = '(helper = ';
		      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
		    }

		    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
		  },

		  // [invokePartial]
		  //
		  // On stack, before: context, ...
		  // On stack after: result of partial invocation
		  //
		  // This operation pops off a context, invokes a partial with that context,
		  // and pushes the result of the invocation back.
		  invokePartial: function invokePartial(isDynamic, name, indent) {
		    var params = [],
		        options = this.setupParams(name, 1, params);

		    if (isDynamic) {
		      name = this.popStack();
		      delete options.name;
		    }

		    if (indent) {
		      options.indent = JSON.stringify(indent);
		    }
		    options.helpers = 'helpers';
		    options.partials = 'partials';
		    options.decorators = 'container.decorators';

		    if (!isDynamic) {
		      params.unshift(this.nameLookup('partials', name, 'partial'));
		    } else {
		      params.unshift(name);
		    }

		    if (this.options.compat) {
		      options.depths = 'depths';
		    }
		    options = this.objectLiteral(options);
		    params.push(options);

		    this.push(this.source.functionCall('container.invokePartial', '', params));
		  },

		  // [assignToHash]
		  //
		  // On stack, before: value, ..., hash, ...
		  // On stack, after: ..., hash, ...
		  //
		  // Pops a value off the stack and assigns it to the current hash
		  assignToHash: function assignToHash(key) {
		    var value = this.popStack(),
		        context = undefined,
		        type = undefined,
		        id = undefined;

		    if (this.trackIds) {
		      id = this.popStack();
		    }
		    if (this.stringParams) {
		      type = this.popStack();
		      context = this.popStack();
		    }

		    var hash = this.hash;
		    if (context) {
		      hash.contexts[key] = context;
		    }
		    if (type) {
		      hash.types[key] = type;
		    }
		    if (id) {
		      hash.ids[key] = id;
		    }
		    hash.values[key] = value;
		  },

		  pushId: function pushId(type, name, child) {
		    if (type === 'BlockParam') {
		      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
		    } else if (type === 'PathExpression') {
		      this.pushString(name);
		    } else if (type === 'SubExpression') {
		      this.pushStackLiteral('true');
		    } else {
		      this.pushStackLiteral('null');
		    }
		  },

		  // HELPERS

		  compiler: JavaScriptCompiler,

		  compileChildren: function compileChildren(environment, options) {
		    var children = environment.children,
		        child = undefined,
		        compiler = undefined;

		    for (var i = 0, l = children.length; i < l; i++) {
		      child = children[i];
		      compiler = new this.compiler(); // eslint-disable-line new-cap

		      var index = this.matchExistingProgram(child);

		      if (index == null) {
		        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
		        index = this.context.programs.length;
		        child.index = index;
		        child.name = 'program' + index;
		        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
		        this.context.decorators[index] = compiler.decorators;
		        this.context.environments[index] = child;

		        this.useDepths = this.useDepths || compiler.useDepths;
		        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
		      } else {
		        child.index = index;
		        child.name = 'program' + index;

		        this.useDepths = this.useDepths || child.useDepths;
		        this.useBlockParams = this.useBlockParams || child.useBlockParams;
		      }
		    }
		  },
		  matchExistingProgram: function matchExistingProgram(child) {
		    for (var i = 0, len = this.context.environments.length; i < len; i++) {
		      var environment = this.context.environments[i];
		      if (environment && environment.equals(child)) {
		        return i;
		      }
		    }
		  },

		  programExpression: function programExpression(guid) {
		    var child = this.environment.children[guid],
		        programParams = [child.index, 'data', child.blockParams];

		    if (this.useBlockParams || this.useDepths) {
		      programParams.push('blockParams');
		    }
		    if (this.useDepths) {
		      programParams.push('depths');
		    }

		    return 'container.program(' + programParams.join(', ') + ')';
		  },

		  useRegister: function useRegister(name) {
		    if (!this.registers[name]) {
		      this.registers[name] = true;
		      this.registers.list.push(name);
		    }
		  },

		  push: function push(expr) {
		    if (!(expr instanceof Literal)) {
		      expr = this.source.wrap(expr);
		    }

		    this.inlineStack.push(expr);
		    return expr;
		  },

		  pushStackLiteral: function pushStackLiteral(item) {
		    this.push(new Literal(item));
		  },

		  pushSource: function pushSource(source) {
		    if (this.pendingContent) {
		      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		      this.pendingContent = undefined;
		    }

		    if (source) {
		      this.source.push(source);
		    }
		  },

		  replaceStack: function replaceStack(callback) {
		    var prefix = ['('],
		        stack = undefined,
		        createdStack = undefined,
		        usedLiteral = undefined;

		    /* istanbul ignore next */
		    if (!this.isInline()) {
		      throw new _exception2['default']('replaceStack on non-inline');
		    }

		    // We want to merge the inline statement into the replacement statement via ','
		    var top = this.popStack(true);

		    if (top instanceof Literal) {
		      // Literals do not need to be inlined
		      stack = [top.value];
		      prefix = ['(', stack];
		      usedLiteral = true;
		    } else {
		      // Get or create the current stack name for use by the inline
		      createdStack = true;
		      var _name = this.incrStack();

		      prefix = ['((', this.push(_name), ' = ', top, ')'];
		      stack = this.topStack();
		    }

		    var item = callback.call(this, stack);

		    if (!usedLiteral) {
		      this.popStack();
		    }
		    if (createdStack) {
		      this.stackSlot--;
		    }
		    this.push(prefix.concat(item, ')'));
		  },

		  incrStack: function incrStack() {
		    this.stackSlot++;
		    if (this.stackSlot > this.stackVars.length) {
		      this.stackVars.push('stack' + this.stackSlot);
		    }
		    return this.topStackName();
		  },
		  topStackName: function topStackName() {
		    return 'stack' + this.stackSlot;
		  },
		  flushInline: function flushInline() {
		    var inlineStack = this.inlineStack;
		    this.inlineStack = [];
		    for (var i = 0, len = inlineStack.length; i < len; i++) {
		      var entry = inlineStack[i];
		      /* istanbul ignore if */
		      if (entry instanceof Literal) {
		        this.compileStack.push(entry);
		      } else {
		        var stack = this.incrStack();
		        this.pushSource([stack, ' = ', entry, ';']);
		        this.compileStack.push(stack);
		      }
		    }
		  },
		  isInline: function isInline() {
		    return this.inlineStack.length;
		  },

		  popStack: function popStack(wrapped) {
		    var inline = this.isInline(),
		        item = (inline ? this.inlineStack : this.compileStack).pop();

		    if (!wrapped && item instanceof Literal) {
		      return item.value;
		    } else {
		      if (!inline) {
		        /* istanbul ignore next */
		        if (!this.stackSlot) {
		          throw new _exception2['default']('Invalid stack pop');
		        }
		        this.stackSlot--;
		      }
		      return item;
		    }
		  },

		  topStack: function topStack() {
		    var stack = this.isInline() ? this.inlineStack : this.compileStack,
		        item = stack[stack.length - 1];

		    /* istanbul ignore if */
		    if (item instanceof Literal) {
		      return item.value;
		    } else {
		      return item;
		    }
		  },

		  contextName: function contextName(context) {
		    if (this.useDepths && context) {
		      return 'depths[' + context + ']';
		    } else {
		      return 'depth' + context;
		    }
		  },

		  quotedString: function quotedString(str) {
		    return this.source.quotedString(str);
		  },

		  objectLiteral: function objectLiteral(obj) {
		    return this.source.objectLiteral(obj);
		  },

		  aliasable: function aliasable(name) {
		    var ret = this.aliases[name];
		    if (ret) {
		      ret.referenceCount++;
		      return ret;
		    }

		    ret = this.aliases[name] = this.source.wrap(name);
		    ret.aliasable = true;
		    ret.referenceCount = 1;

		    return ret;
		  },

		  setupHelper: function setupHelper(paramSize, name, blockHelper) {
		    var params = [],
		        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
		    var foundHelper = this.nameLookup('helpers', name, 'helper'),
		        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');

		    return {
		      params: params,
		      paramsInit: paramsInit,
		      name: foundHelper,
		      callParams: [callContext].concat(params)
		    };
		  },

		  setupParams: function setupParams(helper, paramSize, params) {
		    var options = {},
		        contexts = [],
		        types = [],
		        ids = [],
		        objectArgs = !params,
		        param = undefined;

		    if (objectArgs) {
		      params = [];
		    }

		    options.name = this.quotedString(helper);
		    options.hash = this.popStack();

		    if (this.trackIds) {
		      options.hashIds = this.popStack();
		    }
		    if (this.stringParams) {
		      options.hashTypes = this.popStack();
		      options.hashContexts = this.popStack();
		    }

		    var inverse = this.popStack(),
		        program = this.popStack();

		    // Avoid setting fn and inverse if neither are set. This allows
		    // helpers to do a check for `if (options.fn)`
		    if (program || inverse) {
		      options.fn = program || 'container.noop';
		      options.inverse = inverse || 'container.noop';
		    }

		    // The parameters go on to the stack in order (making sure that they are evaluated in order)
		    // so we need to pop them off the stack in reverse order
		    var i = paramSize;
		    while (i--) {
		      param = this.popStack();
		      params[i] = param;

		      if (this.trackIds) {
		        ids[i] = this.popStack();
		      }
		      if (this.stringParams) {
		        types[i] = this.popStack();
		        contexts[i] = this.popStack();
		      }
		    }

		    if (objectArgs) {
		      options.args = this.source.generateArray(params);
		    }

		    if (this.trackIds) {
		      options.ids = this.source.generateArray(ids);
		    }
		    if (this.stringParams) {
		      options.types = this.source.generateArray(types);
		      options.contexts = this.source.generateArray(contexts);
		    }

		    if (this.options.data) {
		      options.data = 'data';
		    }
		    if (this.useBlockParams) {
		      options.blockParams = 'blockParams';
		    }
		    return options;
		  },

		  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
		    var options = this.setupParams(helper, paramSize, params);
		    options = this.objectLiteral(options);
		    if (useRegister) {
		      this.useRegister('options');
		      params.push('options');
		      return ['options=', options];
		    } else if (params) {
		      params.push(options);
		      return '';
		    } else {
		      return options;
		    }
		  }
		};

		(function () {
		  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

		  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

		  for (var i = 0, l = reservedWords.length; i < l; i++) {
		    compilerWords[reservedWords[i]] = true;
		  }
		})();

		JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
		  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
		};

		function strictLookup(requireTerminal, compiler, parts, type) {
		  var stack = compiler.popStack(),
		      i = 0,
		      len = parts.length;
		  if (requireTerminal) {
		    len--;
		  }

		  for (; i < len; i++) {
		    stack = compiler.nameLookup(stack, parts[i], type);
		  }

		  if (requireTerminal) {
		    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
		  } else {
		    return stack;
		  }
		}

		exports['default'] = JavaScriptCompiler;
		module.exports = exports['default'];

	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {

		/* global define */
		'use strict';

		exports.__esModule = true;

		var _utils = __webpack_require__(5);

		var SourceNode = undefined;

		try {
		  /* istanbul ignore next */
		  if (false) {
		    // We don't support this in AMD environments. For these environments, we asusme that
		    // they are running on the browser and thus have no need for the source-map library.
		    var SourceMap = require('source-map');
		    SourceNode = SourceMap.SourceNode;
		  }
		} catch (err) {}
		/* NOP */

		/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
		if (!SourceNode) {
		  SourceNode = function (line, column, srcFile, chunks) {
		    this.src = '';
		    if (chunks) {
		      this.add(chunks);
		    }
		  };
		  /* istanbul ignore next */
		  SourceNode.prototype = {
		    add: function add(chunks) {
		      if (_utils.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src += chunks;
		    },
		    prepend: function prepend(chunks) {
		      if (_utils.isArray(chunks)) {
		        chunks = chunks.join('');
		      }
		      this.src = chunks + this.src;
		    },
		    toStringWithSourceMap: function toStringWithSourceMap() {
		      return { code: this.toString() };
		    },
		    toString: function toString() {
		      return this.src;
		    }
		  };
		}

		function castChunk(chunk, codeGen, loc) {
		  if (_utils.isArray(chunk)) {
		    var ret = [];

		    for (var i = 0, len = chunk.length; i < len; i++) {
		      ret.push(codeGen.wrap(chunk[i], loc));
		    }
		    return ret;
		  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
		    // Handle primitives that the SourceNode will throw up on
		    return chunk + '';
		  }
		  return chunk;
		}

		function CodeGen(srcFile) {
		  this.srcFile = srcFile;
		  this.source = [];
		}

		CodeGen.prototype = {
		  isEmpty: function isEmpty() {
		    return !this.source.length;
		  },
		  prepend: function prepend(source, loc) {
		    this.source.unshift(this.wrap(source, loc));
		  },
		  push: function push(source, loc) {
		    this.source.push(this.wrap(source, loc));
		  },

		  merge: function merge() {
		    var source = this.empty();
		    this.each(function (line) {
		      source.add(['  ', line, '\n']);
		    });
		    return source;
		  },

		  each: function each(iter) {
		    for (var i = 0, len = this.source.length; i < len; i++) {
		      iter(this.source[i]);
		    }
		  },

		  empty: function empty() {
		    var loc = this.currentLocation || { start: {} };
		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
		  },
		  wrap: function wrap(chunk) {
		    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

		    if (chunk instanceof SourceNode) {
		      return chunk;
		    }

		    chunk = castChunk(chunk, this, loc);

		    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
		  },

		  functionCall: function functionCall(fn, type, params) {
		    params = this.generateList(params);
		    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
		  },

		  quotedString: function quotedString(str) {
		    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
		    .replace(/\u2029/g, '\\u2029') + '"';
		  },

		  objectLiteral: function objectLiteral(obj) {
		    var pairs = [];

		    for (var key in obj) {
		      if (obj.hasOwnProperty(key)) {
		        var value = castChunk(obj[key], this);
		        if (value !== 'undefined') {
		          pairs.push([this.quotedString(key), ':', value]);
		        }
		      }
		    }

		    var ret = this.generateList(pairs);
		    ret.prepend('{');
		    ret.add('}');
		    return ret;
		  },

		  generateList: function generateList(entries) {
		    var ret = this.empty();

		    for (var i = 0, len = entries.length; i < len; i++) {
		      if (i) {
		        ret.add(',');
		      }

		      ret.add(castChunk(entries[i], this));
		    }

		    return ret;
		  },

		  generateArray: function generateArray(entries) {
		    var ret = this.generateList(entries);
		    ret.prepend('[');
		    ret.add(']');

		    return ret;
		  }
		};

		exports['default'] = CodeGen;
		module.exports = exports['default'];

	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(4),
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(7),
	  __webpack_require__(16),
	  __webpack_require__(16)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Handlebars, _, $, StringUtil, markdownToHtml, moment) {

	  var CACHE_BUST_URL_PREFIX = '/assets';

	  function formatDate(format, dateInISOString) {
	    return moment.utc(dateInISOString).zone('-07:00').format(format);
	  }

	  function trim(str) {
	    return str && str.replace(/^\s+|\s+$/g, '');
	  }

	  function prependCachebustPrefix(path) {
	    if (path.indexOf(CACHE_BUST_URL_PREFIX) === 0) {
	      return path;
	    }
	    return CACHE_BUST_URL_PREFIX + path;
	  }

	  Handlebars.registerHelper('i18n', function (options) {
	    var params,
	        key = trim(options.hash.code),
	        bundle = trim(options.hash.bundle),
	        args = trim(options.hash['arguments']);

	    if (args) {
	      params = _.map(trim(args).split(';'), function (param) {
	        param = trim(param);
	        var val,
	            data = this;
	        /*
	         * the context(data) may be a deep object, ex {user: {name: 'John', gender: 'M'}}
	         * arguments may be 'user.name'
	         * return data['user']['name']
	         */
	        _.each(param.split('.'), function (p) {
	          val = val ? val[p] : data[p];
	        });
	        return val;
	      }, this);
	    }

	    return StringUtil.localize(key, bundle, params);
	  });

	  Handlebars.registerHelper('xsrfTokenInput', function () {
	    return '<input type="hidden" class="hide" name="_xsrfToken" ' +
	           'value="' + $('#_xsrfToken').text() + '">';
	  });

	  Handlebars.registerHelper('img', function (options) {
	    /*global okta */
	    var cdn = (typeof okta != 'undefined' && okta.cdnUrlHostname || '');
	    var hash = _.pick(options.hash, ['src', 'alt', 'width', 'height', 'class', 'title']);
	    hash.src = '' + cdn + prependCachebustPrefix(hash.src);
	    var attrs = _.map(hash, function (value, attr) {
	      return attr + '="' + _.escape(value) + '"';
	    });
	    return '<img ' + attrs.join(' ') + '/>';
	  });

	  Handlebars.registerHelper('shortDate',  _.partial(formatDate, 'MMM DD'));
	  Handlebars.registerHelper('mediumDate', _.partial(formatDate, 'MMMM DD, YYYY'));
	  Handlebars.registerHelper('longDate',   _.partial(formatDate, 'MMMM DD, YYYY, h:mma'));
	  Handlebars.registerHelper('formatDate', formatDate);


	  Handlebars.registerHelper('markdown', function (mdText) {
	    return markdownToHtml(Handlebars, mdText);
	  });

	  return Handlebars;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(8),
	  __webpack_require__(15)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, Bundles) {

	  /**
	   * @class StringUtil
	   * @private
	   *
	   * Handy utility functions to handle strings.
	   */

	  var entityMap = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': '\'',
	    '&#039;': '\'',
	    '&#x2F;': '/'
	  };

	  /* eslint max-len: 0*/
	  var emailValidator = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@(?!-)((\[?[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\]?)|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

	  var StringUtil = {
	    sprintf: function () {
	      /* eslint max-statements: [2, 11] */

	      var args = Array.prototype.slice.apply(arguments),
	          value = args.shift(),
	          oldValue = value;

	      function triggerError() {
	        throw new Error('Mismatch number of variables: ' + arguments[0] + ', ' + JSON.stringify(args));
	      }

	      for (var i = 0, l = args.length; i < l; i++) {
	        var entity = args[i];
	        value = value.replace('{' + i + '}', entity);
	        if (entity === undefined || entity === null || value === oldValue) {
	          triggerError();
	        }
	        oldValue = value;
	      }

	      if (/\{[\d+]\}/.test(value)) {
	        triggerError();
	      }

	      return value;
	    },

	    /**
	     * Converts a URI encoded query string into a hash map
	     *
	     * ### Example:
	     *
	     *  ```javascript
	     *  StringUtil.parseQuery('foo=bar&baz=qux') // {foo: 'bar', baz: 'qux'}
	     *
	     * ```
	     * @static
	     * @param  {String} query The query string
	     * @return {Object} The map
	     */
	    parseQuery: function (query) {
	      var params = {};
	      var pairs = decodeURIComponent(query.replace(/\+/g, ' ')).split('&');
	      for (var i = 0; i < pairs.length; i++) {
	        var pair = pairs[i];
	        var data = pair.split('=');
	        params[data.shift()] = data.join('=');
	      }
	      return params;
	    },

	    encodeJSObject: function (jsObj) {
	      return encodeURIComponent(JSON.stringify(jsObj));
	    },

	    decodeJSObject: function (jsObj) {
	      try {
	        return JSON.parse(decodeURIComponent(jsObj));
	      } catch (e) {
	        return null;
	      }
	    },

	    unescapeHtml: function (string) {
	      return String(string).replace(/&[\w\#\d]{2,};/g, function (s) {
	        return entityMap[s] || s;
	      });
	    },

	    /**
	     * Translate a key to the localized value
	     * @static
	     * @param  {String} key The key
	     * @param  {String} [bundle="messages"] The name of the i18n bundle. Defaults to the first bundle in the list.
	     * @param  {Array} [params] A list of parameters to apply as tokens to the i18n value
	     * @return {String} The localized value
	     */
	    localize: function (key, bundleName, params) {
	      var bundle = bundleName ? Bundles[bundleName] : Bundles[_.keys(Bundles)[0]];

	      if (!bundle) {
	        return 'L10N_ERROR[' + (bundleName) + ']';
	      }

	      var value = bundle[key];

	      try {
	        params = params && params.slice ? params.slice(0) : [];
	        params.unshift(value);
	        value = StringUtil.sprintf.apply(null, params);
	      }
	      catch (e) {
	        value = null;
	      }

	      return value || 'L10N_ERROR[' + key + ']';
	    },

	    /**
	    * Convert a string to a float if valid, otherwise return the string.
	    * Valid numbers may contain a negative sign and a decimal point.
	    * @static
	    * @param {String} string The string to convert to a number
	    * @return {String|Number} Returns a number if the string can be casted, otherwise returns the original string
	    */
	    parseFloat: function (string) {
	      var number = +string;
	      return typeof string == 'string' && number === parseFloat(string) ? number : string;
	    },

	    /**
	     * Returns a random string from [a-z][A-Z][0-9] of a given length
	     * @static
	     * @param {Number} length The length of the random string.
	     * @return {String} Returns a random string from [a-z][A-Z][0-9] of a given length
	     */
	    randomString: function (length) {
	      var characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';

	      if (length === undefined) {
	        length = _.random(characters.length); 
	      } else if (length === 0) {
	        return '';
	      }

	      var stringArray = [];
	      while (length--) {
	        stringArray.push(characters[_.random(characters.length)]);
	      }
	      return stringArray.join('');
	    },

	    /**
	     * Returns if a str ends with another string
	     * @static
	     * @param {String} str The string to search
	     * @param {String} ends The string it should end with
	     *
	     * @return {Boolean} Returns if the str ends with ends
	     */
	    endsWith: function (str, ends) {
	      str += '';
	      ends += '';
	      return str.length >= ends.length && str.substring(str.length - ends.length) === ends;
	    },

	    isEmail: function (str) {
	      var target = $.trim(str);
	      return !_.isEmpty(target) && emailValidator.test(target);
	    }

	  };

	  return StringUtil;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint newcap:false */
	/*global JSON */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(9),
	  __webpack_require__(6),
	  __webpack_require__(10),
	  __webpack_require__(11),
	  __webpack_require__(12),
	  __webpack_require__(1),
	  __webpack_require__(14)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Q, $, login, country, Logger, config, BrowserFeatures) {

	  var STORAGE_KEY = 'osw.languages';

	  var bundlePathTpl = _.template('/labels/jsonp/{{bundle}}_{{languageCode}}.jsonp');

	  /**
	   * Converts options to our internal format, which distinguishes between
	   * login and country bundles.
	   *
	   * Example options.i18n passed in by the developer:
	   * {
	   *   'en': {
	   *     'needhelp': 'need help override',
	   *     'primaryauth.title': 'new sign in text',
	   *     'country.JP' = 'Japan, Japan'
	   *   }
	   * }
	   *
	   * Parsed:
	   * {
	   *  'en': {
	   *    'login': {
	   *      'needhelp': 'need help override',
	   *      'primaryauth.title': 'new sign in text',
	   *    },
	   *    'country': {
	   *      'JP': 'Japan, Japan'
	   *    }
	   *  }
	   * }
	   */
	  function parseOverrides(i18n) {
	    if (!i18n) {
	      return {};
	    }
	    return _.mapObject(i18n, function (props) {
	      var mapped = { login: {}, country: {} };
	      if (!_.isObject(props)) {
	        throw new Error('Invalid format for "i18n"');
	      }
	      _.each(props, function (val, key) {
	        var split = key.split(/^country\./);
	        if (split.length > 1) {
	          mapped.country[split[1]] = val;
	        }
	        else {
	          mapped.login[split[0]] = val;
	        }
	      });
	      return mapped;
	    });
	  }

	  // Caching: We only bundle English by default in the Sign-In Widget. Other
	  // languages are loaded on demand and cached in localStorage. These languages
	  // are tied to the version of the widget - when it bumps, we reset the cache.

	  function getCachedLanguages() {
	    var storage = JSON.parse(localStorage.getItem(STORAGE_KEY));
	    if (!storage || storage.version !== config.version) {
	      storage = {
	        version: config.version
	      };
	    }
	    return storage;
	  }

	  function addLanguageToCache(language, loginJson, countryJson) {
	    var current = getCachedLanguages();
	    current[language] = {
	      login: loginJson,
	      country: countryJson
	    };
	    localStorage.setItem(STORAGE_KEY, JSON.stringify(current));
	  }

	  // We use jsonp to get around any CORS issues if the developer is using
	  // the hosted version of the widget - by default, the assets.bundleUrl is
	  // tied to the Okta CDN.
	  //
	  // There are two overrides available for modifying where we load the asset
	  // bundles from:
	  //
	  // 1. assets.baseUrl
	  //
	  //    This is the base path the OSW pulls assets from, which in this case is
	  //    the Okta CDN. Override this config option if you want to host the
	  //    files on your own domain, or if you're using a new version of the
	  //    widget whose language files haven't been published to the CDN yet.
	  //
	  // 2. assets.rewrite
	  //
	  //    This is a function that can be used to modify the path + fileName of
	  //    the bundle we're loading, relative to the baseUrl. When called, it
	  //    will pass the current path, and expect the new path to be returned.
	  //    This is useful, for example, if your build process has an extra
	  //    cachebusting step, i.e:
	  //
	  //    function rewrite(file) {
	  //      // file: /labels/jsonp/login_ja.jsonp
	  //      return file.replace('.jsonp', '.' + md5file(file) + '.jsonp');
	  //    }
	  //
	  // Note: Most developers will not need to use these overrides - the default
	  // is to use the Okta CDN and to use the same path + file structure the
	  // widget module publishes by default.
	  function fetchJsonp(bundle, language, assets) {
	    var languageCode, path;

	    // Our bundles use _ to separate country and region, i.e:
	    // zh-CN -> zh_CN
	    languageCode = language.replace('-', '_');

	    path = assets.rewrite(bundlePathTpl({
	      bundle: bundle,
	      languageCode: languageCode
	    }));

	    return $.ajax({
	      url: assets.baseUrl + path,
	      dataType: 'jsonp',
	      cache: true,
	      // jQuery jsonp doesn't handle errors, so set a long timeout as a
	      // fallback option
	      timeout: 5000,
	      jsonpCallback: 'jsonp_' + bundle
	    });
	  }

	  function getBundles(language, assets) {
	    // Two special cases:
	    // 1. English is already bundled with the widget
	    // 2. If the language is not in our config file, it means that they've
	    //    probably defined it on their own.
	    if (language === 'en' || !_.contains(config.supportedLanguages, language)) {
	      return Q({});
	    }

	    //local storage does not work correctly with android web views (embeded browers)
	    //so skip the caching and just make the request to get the local info
	    var localStorageIsSupported = !BrowserFeatures.localStorageIsNotSupported();
	    if (localStorageIsSupported) {
	      var cached = getCachedLanguages();
	      if (cached[language]) {
	        return Q(cached[language]);
	      }
	    }

	    return Q.all([
	      fetchJsonp('login', language, assets),
	      fetchJsonp('country', language, assets)
	    ])
	    .spread(function (loginJson, countryJson) {
	      if (localStorageIsSupported) {
	        addLanguageToCache(language, loginJson, countryJson);
	      }
	      return { login: loginJson, country: countryJson };
	    })
	    .fail(function () {
	      // If there is an error, this will default to the bundled language and
	      // we will no longer try to load the language this session.
	      Logger.warn('Unable to load language: ' + language);
	      return {};
	    });
	  }

	  return {
	    login: login,
	    country: country,

	    currentLanguage: null,

	    isLoaded: function (language) {
	      return this.currentLanguage === language;
	    },

	    loadLanguage: function (language, overrides, assets) {
	      var parsedOverrides = parseOverrides(overrides);
	      return getBundles(language, assets)
	      .then(_.bind(function (bundles) {
	        // Always extend from the built in defaults in the event that some
	        // properties are not translated
	        this.login = _.extend({}, login, bundles.login);
	        this.country = _.extend({}, country, bundles.country);
	        if (parsedOverrides[language]) {
	          _.extend(this.login, parsedOverrides[language]['login']);
	          _.extend(this.country, parsedOverrides[language]['country']);
	        }
	        this.currentLanguage = language;
	      }, this));
	    }

	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
	 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */

	(function (definition) {
	    "use strict";

	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.

	    // Montage Require
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);

	    // CommonJS
	    } else if (true) {
	        module.exports = definition();

	    // RequireJS
	    } else if (typeof define === "function" && define.amd) {
	        define(definition);

	    // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }

	    // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;

	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();

	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };

	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }

	})(function () {
	"use strict";

	var hasStacks = false;
	try {
	    throw new Error();
	} catch (e) {
	    hasStacks = !!e.stack;
	}

	// All code after this point will be filtered from stack traces reported
	// by Q.
	var qStartingLine = captureLine();
	var qFileName;

	// shims

	// used for fallback in "allResolved"
	var noop = function () {};

	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.
	var nextTick =(function () {
	    // linked list of tasks (single, with head node)
	    var head = {task: void 0, next: null};
	    var tail = head;
	    var flushing = false;
	    var requestTick = void 0;
	    var isNodeJS = false;
	    // queue for late tasks, used by unhandled rejection tracking
	    var laterQueue = [];

	    function flush() {
	        /* jshint loopfunc: true */
	        var task, domain;

	        while (head.next) {
	            head = head.next;
	            task = head.task;
	            head.task = void 0;
	            domain = head.domain;

	            if (domain) {
	                head.domain = void 0;
	                domain.enter();
	            }
	            runSingle(task, domain);

	        }
	        while (laterQueue.length) {
	            task = laterQueue.pop();
	            runSingle(task);
	        }
	        flushing = false;
	    }
	    // runs a single function in the async queue
	    function runSingle(task, domain) {
	        try {
	            task();

	        } catch (e) {
	            if (isNodeJS) {
	                // In node, uncaught exceptions are considered fatal errors.
	                // Re-throw them synchronously to interrupt flushing!

	                // Ensure continuation if the uncaught exception is suppressed
	                // listening "uncaughtException" events (as domains does).
	                // Continue in next event to avoid tick recursion.
	                if (domain) {
	                    domain.exit();
	                }
	                setTimeout(flush, 0);
	                if (domain) {
	                    domain.enter();
	                }

	                throw e;

	            } else {
	                // In browsers, uncaught exceptions are not fatal.
	                // Re-throw them asynchronously to avoid slow-downs.
	                setTimeout(function () {
	                    throw e;
	                }, 0);
	            }
	        }

	        if (domain) {
	            domain.exit();
	        }
	    }

	    nextTick = function (task) {
	        tail = tail.next = {
	            task: task,
	            domain: isNodeJS && process.domain,
	            next: null
	        };

	        if (!flushing) {
	            flushing = true;
	            requestTick();
	        }
	    };

	    if (typeof process === "object" &&
	        process.toString() === "[object process]" && process.nextTick) {
	        // Ensure Q is in a real Node environment, with a `process.nextTick`.
	        // To see through fake Node environments:
	        // * Mocha test runner - exposes a `process` global without a `nextTick`
	        // * Browserify - exposes a `process.nexTick` function that uses
	        //   `setTimeout`. In this case `setImmediate` is preferred because
	        //    it is faster. Browserify's `process.toString()` yields
	        //   "[object Object]", while in a real Node environment
	        //   `process.nextTick()` yields "[object process]".
	        isNodeJS = true;

	        requestTick = function () {
	            process.nextTick(flush);
	        };

	    } else if (typeof setImmediate === "function") {
	        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	        if (typeof window !== "undefined") {
	            requestTick = setImmediate.bind(window, flush);
	        } else {
	            requestTick = function () {
	                setImmediate(flush);
	            };
	        }

	    } else if (typeof MessageChannel !== "undefined") {
	        // modern browsers
	        // http://www.nonblocking.io/2011/06/windownexttick.html
	        var channel = new MessageChannel();
	        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	        // working message ports the first time a page loads.
	        channel.port1.onmessage = function () {
	            requestTick = requestPortTick;
	            channel.port1.onmessage = flush;
	            flush();
	        };
	        var requestPortTick = function () {
	            // Opera requires us to provide a message payload, regardless of
	            // whether we use it.
	            channel.port2.postMessage(0);
	        };
	        requestTick = function () {
	            setTimeout(flush, 0);
	            requestPortTick();
	        };

	    } else {
	        // old browsers
	        requestTick = function () {
	            setTimeout(flush, 0);
	        };
	    }
	    // runs a task after all other tasks have been run
	    // this is useful for unhandled rejection tracking that needs to happen
	    // after all `then`d tasks have been run.
	    nextTick.runAfter = function (task) {
	        laterQueue.push(task);
	        if (!flushing) {
	            flushing = true;
	            requestTick();
	        }
	    };
	    return nextTick;
	})();

	// Attempt to make generics safe in the face of downstream
	// modifications.
	// There is no situation where this is necessary.
	// If you need a security guarantee, these primordials need to be
	// deeply frozen anyway, and if you don’t need a security guarantee,
	// this is just plain paranoid.
	// However, this **might** have the nice side-effect of reducing the size of
	// the minified code by reducing x.call() to merely x()
	// See Mark Miller’s explanation of what this does.
	// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	var call = Function.call;
	function uncurryThis(f) {
	    return function () {
	        return call.apply(f, arguments);
	    };
	}
	// This is equivalent, but slower:
	// uncurryThis = Function_bind.bind(Function_bind.call);
	// http://jsperf.com/uncurrythis

	var array_slice = uncurryThis(Array.prototype.slice);

	var array_reduce = uncurryThis(
	    Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    }
	);

	var array_indexOf = uncurryThis(
	    Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    }
	);

	var array_map = uncurryThis(
	    Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    }
	);

	var object_create = Object.create || function (prototype) {
	    function Type() { }
	    Type.prototype = prototype;
	    return new Type();
	};

	var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

	var object_keys = Object.keys || function (object) {
	    var keys = [];
	    for (var key in object) {
	        if (object_hasOwnProperty(object, key)) {
	            keys.push(key);
	        }
	    }
	    return keys;
	};

	var object_toString = uncurryThis(Object.prototype.toString);

	function isObject(value) {
	    return value === Object(value);
	}

	// generator related shims

	// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	function isStopIteration(exception) {
	    return (
	        object_toString(exception) === "[object StopIteration]" ||
	        exception instanceof QReturnValue
	    );
	}

	// FIXME: Remove this helper and Q.return once ES6 generators are in
	// SpiderMonkey.
	var QReturnValue;
	if (typeof ReturnValue !== "undefined") {
	    QReturnValue = ReturnValue;
	} else {
	    QReturnValue = function (value) {
	        this.value = value;
	    };
	}

	// long stack traces

	var STACK_JUMP_SEPARATOR = "From previous event:";

	function makeStackTraceLong(error, promise) {
	    // If possible, transform the error stack trace by removing Node and Q
	    // cruft, then concatenating with the stack trace of `promise`. See #57.
	    if (hasStacks &&
	        promise.stack &&
	        typeof error === "object" &&
	        error !== null &&
	        error.stack &&
	        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
	    ) {
	        var stacks = [];
	        for (var p = promise; !!p; p = p.source) {
	            if (p.stack) {
	                stacks.unshift(p.stack);
	            }
	        }
	        stacks.unshift(error.stack);

	        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	        error.stack = filterStackString(concatedStacks);
	    }
	}

	function filterStackString(stackString) {
	    var lines = stackString.split("\n");
	    var desiredLines = [];
	    for (var i = 0; i < lines.length; ++i) {
	        var line = lines[i];

	        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	            desiredLines.push(line);
	        }
	    }
	    return desiredLines.join("\n");
	}

	function isNodeFrame(stackLine) {
	    return stackLine.indexOf("(module.js:") !== -1 ||
	           stackLine.indexOf("(node.js:") !== -1;
	}

	function getFileNameAndLineNumber(stackLine) {
	    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	    // In IE10 function name can have spaces ("Anonymous function") O_o
	    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	    if (attempt1) {
	        return [attempt1[1], Number(attempt1[2])];
	    }

	    // Anonymous functions: "at filename:lineNumber:columnNumber"
	    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	    if (attempt2) {
	        return [attempt2[1], Number(attempt2[2])];
	    }

	    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	    if (attempt3) {
	        return [attempt3[1], Number(attempt3[2])];
	    }
	}

	function isInternalFrame(stackLine) {
	    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

	    if (!fileNameAndLineNumber) {
	        return false;
	    }

	    var fileName = fileNameAndLineNumber[0];
	    var lineNumber = fileNameAndLineNumber[1];

	    return fileName === qFileName &&
	        lineNumber >= qStartingLine &&
	        lineNumber <= qEndingLine;
	}

	// discover own file name and line number range for filtering stack
	// traces
	function captureLine() {
	    if (!hasStacks) {
	        return;
	    }

	    try {
	        throw new Error();
	    } catch (e) {
	        var lines = e.stack.split("\n");
	        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	        if (!fileNameAndLineNumber) {
	            return;
	        }

	        qFileName = fileNameAndLineNumber[0];
	        return fileNameAndLineNumber[1];
	    }
	}

	function deprecate(callback, name, alternative) {
	    return function () {
	        if (typeof console !== "undefined" &&
	            typeof console.warn === "function") {
	            console.warn(name + " is deprecated, use " + alternative +
	                         " instead.", new Error("").stack);
	        }
	        return callback.apply(callback, arguments);
	    };
	}

	// end of shims
	// beginning of real work

	/**
	 * Constructs a promise for an immediate reference, passes promises through, or
	 * coerces promises from different systems.
	 * @param value immediate reference or promise
	 */
	function Q(value) {
	    // If the object is already a Promise, return it directly.  This enables
	    // the resolve function to both be used to created references from objects,
	    // but to tolerably coerce non-promises to promises.
	    if (value instanceof Promise) {
	        return value;
	    }

	    // assimilate thenables
	    if (isPromiseAlike(value)) {
	        return coerce(value);
	    } else {
	        return fulfill(value);
	    }
	}
	Q.resolve = Q;

	/**
	 * Performs a task in a future turn of the event loop.
	 * @param {Function} task
	 */
	Q.nextTick = nextTick;

	/**
	 * Controls whether or not long stack traces will be on
	 */
	Q.longStackSupport = false;

	// enable long stacks if Q_DEBUG is set
	if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
	    Q.longStackSupport = true;
	}

	/**
	 * Constructs a {promise, resolve, reject} object.
	 *
	 * `resolve` is a callback to invoke with a more resolved value for the
	 * promise. To fulfill the promise, invoke `resolve` with any value that is
	 * not a thenable. To reject the promise, invoke `resolve` with a rejected
	 * thenable, or invoke `reject` with the reason directly. To resolve the
	 * promise to another thenable, thus putting it in the same state, invoke
	 * `resolve` with that other thenable.
	 */
	Q.defer = defer;
	function defer() {
	    // if "messages" is an "Array", that indicates that the promise has not yet
	    // been resolved.  If it is "undefined", it has been resolved.  Each
	    // element of the messages array is itself an array of complete arguments to
	    // forward to the resolved promise.  We coerce the resolution value to a
	    // promise using the `resolve` function because it handles both fully
	    // non-thenable values and other thenables gracefully.
	    var messages = [], progressListeners = [], resolvedPromise;

	    var deferred = object_create(defer.prototype);
	    var promise = object_create(Promise.prototype);

	    promise.promiseDispatch = function (resolve, op, operands) {
	        var args = array_slice(arguments);
	        if (messages) {
	            messages.push(args);
	            if (op === "when" && operands[1]) { // progress operand
	                progressListeners.push(operands[1]);
	            }
	        } else {
	            Q.nextTick(function () {
	                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	            });
	        }
	    };

	    // XXX deprecated
	    promise.valueOf = function () {
	        if (messages) {
	            return promise;
	        }
	        var nearerValue = nearer(resolvedPromise);
	        if (isPromise(nearerValue)) {
	            resolvedPromise = nearerValue; // shorten chain
	        }
	        return nearerValue;
	    };

	    promise.inspect = function () {
	        if (!resolvedPromise) {
	            return { state: "pending" };
	        }
	        return resolvedPromise.inspect();
	    };

	    if (Q.longStackSupport && hasStacks) {
	        try {
	            throw new Error();
	        } catch (e) {
	            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	            // accessor around; that causes memory leaks as per GH-111. Just
	            // reify the stack trace as a string ASAP.
	            //
	            // At the same time, cut off the first line; it's always just
	            // "[object Promise]\n", as per the `toString`.
	            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	        }
	    }

	    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	    // consolidating them into `become`, since otherwise we'd create new
	    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

	    function become(newPromise) {
	        resolvedPromise = newPromise;
	        promise.source = newPromise;

	        array_reduce(messages, function (undefined, message) {
	            Q.nextTick(function () {
	                newPromise.promiseDispatch.apply(newPromise, message);
	            });
	        }, void 0);

	        messages = void 0;
	        progressListeners = void 0;
	    }

	    deferred.promise = promise;
	    deferred.resolve = function (value) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(Q(value));
	    };

	    deferred.fulfill = function (value) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(fulfill(value));
	    };
	    deferred.reject = function (reason) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(reject(reason));
	    };
	    deferred.notify = function (progress) {
	        if (resolvedPromise) {
	            return;
	        }

	        array_reduce(progressListeners, function (undefined, progressListener) {
	            Q.nextTick(function () {
	                progressListener(progress);
	            });
	        }, void 0);
	    };

	    return deferred;
	}

	/**
	 * Creates a Node-style callback that will resolve or reject the deferred
	 * promise.
	 * @returns a nodeback
	 */
	defer.prototype.makeNodeResolver = function () {
	    var self = this;
	    return function (error, value) {
	        if (error) {
	            self.reject(error);
	        } else if (arguments.length > 2) {
	            self.resolve(array_slice(arguments, 1));
	        } else {
	            self.resolve(value);
	        }
	    };
	};

	/**
	 * @param resolver {Function} a function that returns nothing and accepts
	 * the resolve, reject, and notify functions for a deferred.
	 * @returns a promise that may be resolved with the given resolve and reject
	 * functions, or rejected by a thrown exception in resolver
	 */
	Q.Promise = promise; // ES6
	Q.promise = promise;
	function promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("resolver must be a function.");
	    }
	    var deferred = defer();
	    try {
	        resolver(deferred.resolve, deferred.reject, deferred.notify);
	    } catch (reason) {
	        deferred.reject(reason);
	    }
	    return deferred.promise;
	}

	promise.race = race; // ES6
	promise.all = all; // ES6
	promise.reject = reject; // ES6
	promise.resolve = Q; // ES6

	// XXX experimental.  This method is a way to denote that a local value is
	// serializable and should be immediately dispatched to a remote upon request,
	// instead of passing a reference.
	Q.passByCopy = function (object) {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return object;
	};

	Promise.prototype.passByCopy = function () {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return this;
	};

	/**
	 * If two promises eventually fulfill to the same value, promises that value,
	 * but otherwise rejects.
	 * @param x {Any*}
	 * @param y {Any*}
	 * @returns {Any*} a promise for x and y if they are the same, but a rejection
	 * otherwise.
	 *
	 */
	Q.join = function (x, y) {
	    return Q(x).join(y);
	};

	Promise.prototype.join = function (that) {
	    return Q([this, that]).spread(function (x, y) {
	        if (x === y) {
	            // TODO: "===" should be Object.is or equiv
	            return x;
	        } else {
	            throw new Error("Can't join: not the same: " + x + " " + y);
	        }
	    });
	};

	/**
	 * Returns a promise for the first of an array of promises to become settled.
	 * @param answers {Array[Any*]} promises to race
	 * @returns {Any*} the first promise to be settled
	 */
	Q.race = race;
	function race(answerPs) {
	    return promise(function (resolve, reject) {
	        // Switch to this once we can assume at least ES5
	        // answerPs.forEach(function (answerP) {
	        //     Q(answerP).then(resolve, reject);
	        // });
	        // Use this in the meantime
	        for (var i = 0, len = answerPs.length; i < len; i++) {
	            Q(answerPs[i]).then(resolve, reject);
	        }
	    });
	}

	Promise.prototype.race = function () {
	    return this.then(Q.race);
	};

	/**
	 * Constructs a Promise with a promise descriptor object and optional fallback
	 * function.  The descriptor contains methods like when(rejected), get(name),
	 * set(name, value), post(name, args), and delete(name), which all
	 * return either a value, a promise for a value, or a rejection.  The fallback
	 * accepts the operation name, a resolver, and any further arguments that would
	 * have been forwarded to the appropriate method above had a method been
	 * provided with the proper name.  The API makes no guarantees about the nature
	 * of the returned object, apart from that it is usable whereever promises are
	 * bought and sold.
	 */
	Q.makePromise = Promise;
	function Promise(descriptor, fallback, inspect) {
	    if (fallback === void 0) {
	        fallback = function (op) {
	            return reject(new Error(
	                "Promise does not support operation: " + op
	            ));
	        };
	    }
	    if (inspect === void 0) {
	        inspect = function () {
	            return {state: "unknown"};
	        };
	    }

	    var promise = object_create(Promise.prototype);

	    promise.promiseDispatch = function (resolve, op, args) {
	        var result;
	        try {
	            if (descriptor[op]) {
	                result = descriptor[op].apply(promise, args);
	            } else {
	                result = fallback.call(promise, op, args);
	            }
	        } catch (exception) {
	            result = reject(exception);
	        }
	        if (resolve) {
	            resolve(result);
	        }
	    };

	    promise.inspect = inspect;

	    // XXX deprecated `valueOf` and `exception` support
	    if (inspect) {
	        var inspected = inspect();
	        if (inspected.state === "rejected") {
	            promise.exception = inspected.reason;
	        }

	        promise.valueOf = function () {
	            var inspected = inspect();
	            if (inspected.state === "pending" ||
	                inspected.state === "rejected") {
	                return promise;
	            }
	            return inspected.value;
	        };
	    }

	    return promise;
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.then = function (fulfilled, rejected, progressed) {
	    var self = this;
	    var deferred = defer();
	    var done = false;   // ensure the untrusted promise makes at most a
	                        // single call to one of the callbacks

	    function _fulfilled(value) {
	        try {
	            return typeof fulfilled === "function" ? fulfilled(value) : value;
	        } catch (exception) {
	            return reject(exception);
	        }
	    }

	    function _rejected(exception) {
	        if (typeof rejected === "function") {
	            makeStackTraceLong(exception, self);
	            try {
	                return rejected(exception);
	            } catch (newException) {
	                return reject(newException);
	            }
	        }
	        return reject(exception);
	    }

	    function _progressed(value) {
	        return typeof progressed === "function" ? progressed(value) : value;
	    }

	    Q.nextTick(function () {
	        self.promiseDispatch(function (value) {
	            if (done) {
	                return;
	            }
	            done = true;

	            deferred.resolve(_fulfilled(value));
	        }, "when", [function (exception) {
	            if (done) {
	                return;
	            }
	            done = true;

	            deferred.resolve(_rejected(exception));
	        }]);
	    });

	    // Progress propagator need to be attached in the current tick.
	    self.promiseDispatch(void 0, "when", [void 0, function (value) {
	        var newValue;
	        var threw = false;
	        try {
	            newValue = _progressed(value);
	        } catch (e) {
	            threw = true;
	            if (Q.onerror) {
	                Q.onerror(e);
	            } else {
	                throw e;
	            }
	        }

	        if (!threw) {
	            deferred.notify(newValue);
	        }
	    }]);

	    return deferred.promise;
	};

	Q.tap = function (promise, callback) {
	    return Q(promise).tap(callback);
	};

	/**
	 * Works almost like "finally", but not called for rejections.
	 * Original resolution value is passed through callback unaffected.
	 * Callback may return a promise that will be awaited for.
	 * @param {Function} callback
	 * @returns {Q.Promise}
	 * @example
	 * doSomething()
	 *   .then(...)
	 *   .tap(console.log)
	 *   .then(...);
	 */
	Promise.prototype.tap = function (callback) {
	    callback = Q(callback);

	    return this.then(function (value) {
	        return callback.fcall(value).thenResolve(value);
	    });
	};

	/**
	 * Registers an observer on a promise.
	 *
	 * Guarantees:
	 *
	 * 1. that fulfilled and rejected will be called only once.
	 * 2. that either the fulfilled callback or the rejected callback will be
	 *    called, but not both.
	 * 3. that fulfilled and rejected will not be called in this turn.
	 *
	 * @param value      promise or immediate reference to observe
	 * @param fulfilled  function to be called with the fulfilled value
	 * @param rejected   function to be called with the rejection exception
	 * @param progressed function to be called on any progress notifications
	 * @return promise for the return value from the invoked callback
	 */
	Q.when = when;
	function when(value, fulfilled, rejected, progressed) {
	    return Q(value).then(fulfilled, rejected, progressed);
	}

	Promise.prototype.thenResolve = function (value) {
	    return this.then(function () { return value; });
	};

	Q.thenResolve = function (promise, value) {
	    return Q(promise).thenResolve(value);
	};

	Promise.prototype.thenReject = function (reason) {
	    return this.then(function () { throw reason; });
	};

	Q.thenReject = function (promise, reason) {
	    return Q(promise).thenReject(reason);
	};

	/**
	 * If an object is not a promise, it is as "near" as possible.
	 * If a promise is rejected, it is as "near" as possible too.
	 * If it’s a fulfilled promise, the fulfillment value is nearer.
	 * If it’s a deferred promise and the deferred has been resolved, the
	 * resolution is "nearer".
	 * @param object
	 * @returns most resolved (nearest) form of the object
	 */

	// XXX should we re-do this?
	Q.nearer = nearer;
	function nearer(value) {
	    if (isPromise(value)) {
	        var inspected = value.inspect();
	        if (inspected.state === "fulfilled") {
	            return inspected.value;
	        }
	    }
	    return value;
	}

	/**
	 * @returns whether the given object is a promise.
	 * Otherwise it is a fulfilled value.
	 */
	Q.isPromise = isPromise;
	function isPromise(object) {
	    return object instanceof Promise;
	}

	Q.isPromiseAlike = isPromiseAlike;
	function isPromiseAlike(object) {
	    return isObject(object) && typeof object.then === "function";
	}

	/**
	 * @returns whether the given object is a pending promise, meaning not
	 * fulfilled or rejected.
	 */
	Q.isPending = isPending;
	function isPending(object) {
	    return isPromise(object) && object.inspect().state === "pending";
	}

	Promise.prototype.isPending = function () {
	    return this.inspect().state === "pending";
	};

	/**
	 * @returns whether the given object is a value or fulfilled
	 * promise.
	 */
	Q.isFulfilled = isFulfilled;
	function isFulfilled(object) {
	    return !isPromise(object) || object.inspect().state === "fulfilled";
	}

	Promise.prototype.isFulfilled = function () {
	    return this.inspect().state === "fulfilled";
	};

	/**
	 * @returns whether the given object is a rejected promise.
	 */
	Q.isRejected = isRejected;
	function isRejected(object) {
	    return isPromise(object) && object.inspect().state === "rejected";
	}

	Promise.prototype.isRejected = function () {
	    return this.inspect().state === "rejected";
	};

	//// BEGIN UNHANDLED REJECTION TRACKING

	// This promise library consumes exceptions thrown in handlers so they can be
	// handled by a subsequent promise.  The exceptions get added to this array when
	// they are created, and removed when they are handled.  Note that in ES6 or
	// shimmed environments, this would naturally be a `Set`.
	var unhandledReasons = [];
	var unhandledRejections = [];
	var reportedUnhandledRejections = [];
	var trackUnhandledRejections = true;

	function resetUnhandledRejections() {
	    unhandledReasons.length = 0;
	    unhandledRejections.length = 0;

	    if (!trackUnhandledRejections) {
	        trackUnhandledRejections = true;
	    }
	}

	function trackRejection(promise, reason) {
	    if (!trackUnhandledRejections) {
	        return;
	    }
	    if (typeof process === "object" && typeof process.emit === "function") {
	        Q.nextTick.runAfter(function () {
	            if (array_indexOf(unhandledRejections, promise) !== -1) {
	                process.emit("unhandledRejection", reason, promise);
	                reportedUnhandledRejections.push(promise);
	            }
	        });
	    }

	    unhandledRejections.push(promise);
	    if (reason && typeof reason.stack !== "undefined") {
	        unhandledReasons.push(reason.stack);
	    } else {
	        unhandledReasons.push("(no stack) " + reason);
	    }
	}

	function untrackRejection(promise) {
	    if (!trackUnhandledRejections) {
	        return;
	    }

	    var at = array_indexOf(unhandledRejections, promise);
	    if (at !== -1) {
	        if (typeof process === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                if (atReport !== -1) {
	                    process.emit("rejectionHandled", unhandledReasons[at], promise);
	                    reportedUnhandledRejections.splice(atReport, 1);
	                }
	            });
	        }
	        unhandledRejections.splice(at, 1);
	        unhandledReasons.splice(at, 1);
	    }
	}

	Q.resetUnhandledRejections = resetUnhandledRejections;

	Q.getUnhandledReasons = function () {
	    // Make a copy so that consumers can't interfere with our internal state.
	    return unhandledReasons.slice();
	};

	Q.stopUnhandledRejectionTracking = function () {
	    resetUnhandledRejections();
	    trackUnhandledRejections = false;
	};

	resetUnhandledRejections();

	//// END UNHANDLED REJECTION TRACKING

	/**
	 * Constructs a rejected promise.
	 * @param reason value describing the failure
	 */
	Q.reject = reject;
	function reject(reason) {
	    var rejection = Promise({
	        "when": function (rejected) {
	            // note that the error has been handled
	            if (rejected) {
	                untrackRejection(this);
	            }
	            return rejected ? rejected(reason) : this;
	        }
	    }, function fallback() {
	        return this;
	    }, function inspect() {
	        return { state: "rejected", reason: reason };
	    });

	    // Note that the reason has not been handled.
	    trackRejection(rejection, reason);

	    return rejection;
	}

	/**
	 * Constructs a fulfilled promise for an immediate reference.
	 * @param value immediate reference
	 */
	Q.fulfill = fulfill;
	function fulfill(value) {
	    return Promise({
	        "when": function () {
	            return value;
	        },
	        "get": function (name) {
	            return value[name];
	        },
	        "set": function (name, rhs) {
	            value[name] = rhs;
	        },
	        "delete": function (name) {
	            delete value[name];
	        },
	        "post": function (name, args) {
	            // Mark Miller proposes that post with no name should apply a
	            // promised function.
	            if (name === null || name === void 0) {
	                return value.apply(void 0, args);
	            } else {
	                return value[name].apply(value, args);
	            }
	        },
	        "apply": function (thisp, args) {
	            return value.apply(thisp, args);
	        },
	        "keys": function () {
	            return object_keys(value);
	        }
	    }, void 0, function inspect() {
	        return { state: "fulfilled", value: value };
	    });
	}

	/**
	 * Converts thenables to Q promises.
	 * @param promise thenable promise
	 * @returns a Q promise
	 */
	function coerce(promise) {
	    var deferred = defer();
	    Q.nextTick(function () {
	        try {
	            promise.then(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (exception) {
	            deferred.reject(exception);
	        }
	    });
	    return deferred.promise;
	}

	/**
	 * Annotates an object such that it will never be
	 * transferred away from this process over any promise
	 * communication channel.
	 * @param object
	 * @returns promise a wrapping of that object that
	 * additionally responds to the "isDef" message
	 * without a rejection.
	 */
	Q.master = master;
	function master(object) {
	    return Promise({
	        "isDef": function () {}
	    }, function fallback(op, args) {
	        return dispatch(object, op, args);
	    }, function () {
	        return Q(object).inspect();
	    });
	}

	/**
	 * Spreads the values of a promised array of arguments into the
	 * fulfillment callback.
	 * @param fulfilled callback that receives variadic arguments from the
	 * promised array
	 * @param rejected callback that receives the exception if the promise
	 * is rejected.
	 * @returns a promise for the return value or thrown exception of
	 * either callback.
	 */
	Q.spread = spread;
	function spread(value, fulfilled, rejected) {
	    return Q(value).spread(fulfilled, rejected);
	}

	Promise.prototype.spread = function (fulfilled, rejected) {
	    return this.all().then(function (array) {
	        return fulfilled.apply(void 0, array);
	    }, rejected);
	};

	/**
	 * The async function is a decorator for generator functions, turning
	 * them into asynchronous generators.  Although generators are only part
	 * of the newest ECMAScript 6 drafts, this code does not cause syntax
	 * errors in older engines.  This code should continue to work and will
	 * in fact improve over time as the language improves.
	 *
	 * ES6 generators are currently part of V8 version 3.19 with the
	 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	 * for longer, but under an older Python-inspired form.  This function
	 * works on both kinds of generators.
	 *
	 * Decorates a generator function such that:
	 *  - it may yield promises
	 *  - execution will continue when that promise is fulfilled
	 *  - the value of the yield expression will be the fulfilled value
	 *  - it returns a promise for the return value (when the generator
	 *    stops iterating)
	 *  - the decorated function returns a promise for the return value
	 *    of the generator or the first rejected promise among those
	 *    yielded.
	 *  - if an error is thrown in the generator, it propagates through
	 *    every following yield until it is caught, or until it escapes
	 *    the generator function altogether, and is translated into a
	 *    rejection for the promise returned by the decorated generator.
	 */
	Q.async = async;
	function async(makeGenerator) {
	    return function () {
	        // when verb is "send", arg is a value
	        // when verb is "throw", arg is an exception
	        function continuer(verb, arg) {
	            var result;

	            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	            // engine that has a deployed base of browsers that support generators.
	            // However, SM's generators use the Python-inspired semantics of
	            // outdated ES6 drafts.  We would like to support ES6, but we'd also
	            // like to make it possible to use generators in deployed browsers, so
	            // we also support Python-style generators.  At some point we can remove
	            // this block.

	            if (typeof StopIteration === "undefined") {
	                // ES6 Generators
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    return reject(exception);
	                }
	                if (result.done) {
	                    return Q(result.value);
	                } else {
	                    return when(result.value, callback, errback);
	                }
	            } else {
	                // SpiderMonkey Generators
	                // FIXME: Remove this case when SM does ES6 generators.
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    if (isStopIteration(exception)) {
	                        return Q(exception.value);
	                    } else {
	                        return reject(exception);
	                    }
	                }
	                return when(result, callback, errback);
	            }
	        }
	        var generator = makeGenerator.apply(this, arguments);
	        var callback = continuer.bind(continuer, "next");
	        var errback = continuer.bind(continuer, "throw");
	        return callback();
	    };
	}

	/**
	 * The spawn function is a small wrapper around async that immediately
	 * calls the generator and also ends the promise chain, so that any
	 * unhandled errors are thrown instead of forwarded to the error
	 * handler. This is useful because it's extremely common to run
	 * generators at the top-level to work with libraries.
	 */
	Q.spawn = spawn;
	function spawn(makeGenerator) {
	    Q.done(Q.async(makeGenerator)());
	}

	// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	/**
	 * Throws a ReturnValue exception to stop an asynchronous generator.
	 *
	 * This interface is a stop-gap measure to support generator return
	 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	 * generators like Chromium 29, just use "return" in your generator
	 * functions.
	 *
	 * @param value the return value for the surrounding generator
	 * @throws ReturnValue exception with the value.
	 * @example
	 * // ES6 style
	 * Q.async(function* () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      return foo + bar;
	 * })
	 * // Older SpiderMonkey style
	 * Q.async(function () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      Q.return(foo + bar);
	 * })
	 */
	Q["return"] = _return;
	function _return(value) {
	    throw new QReturnValue(value);
	}

	/**
	 * The promised function decorator ensures that any promise arguments
	 * are settled and passed as values (`this` is also settled and passed
	 * as a value).  It will also ensure that the result of a function is
	 * always a promise.
	 *
	 * @example
	 * var add = Q.promised(function (a, b) {
	 *     return a + b;
	 * });
	 * add(Q(a), Q(B));
	 *
	 * @param {function} callback The function to decorate
	 * @returns {function} a function that has been decorated.
	 */
	Q.promised = promised;
	function promised(callback) {
	    return function () {
	        return spread([this, all(arguments)], function (self, args) {
	            return callback.apply(self, args);
	        });
	    };
	}

	/**
	 * sends a message to a value in a future turn
	 * @param object* the recipient
	 * @param op the name of the message operation, e.g., "when",
	 * @param args further arguments to be forwarded to the operation
	 * @returns result {Promise} a promise for the result of the operation
	 */
	Q.dispatch = dispatch;
	function dispatch(object, op, args) {
	    return Q(object).dispatch(op, args);
	}

	Promise.prototype.dispatch = function (op, args) {
	    var self = this;
	    var deferred = defer();
	    Q.nextTick(function () {
	        self.promiseDispatch(deferred.resolve, op, args);
	    });
	    return deferred.promise;
	};

	/**
	 * Gets the value of a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to get
	 * @return promise for the property value
	 */
	Q.get = function (object, key) {
	    return Q(object).dispatch("get", [key]);
	};

	Promise.prototype.get = function (key) {
	    return this.dispatch("get", [key]);
	};

	/**
	 * Sets the value of a property in a future turn.
	 * @param object    promise or immediate reference for object object
	 * @param name      name of property to set
	 * @param value     new value of property
	 * @return promise for the return value
	 */
	Q.set = function (object, key, value) {
	    return Q(object).dispatch("set", [key, value]);
	};

	Promise.prototype.set = function (key, value) {
	    return this.dispatch("set", [key, value]);
	};

	/**
	 * Deletes a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to delete
	 * @return promise for the return value
	 */
	Q.del = // XXX legacy
	Q["delete"] = function (object, key) {
	    return Q(object).dispatch("delete", [key]);
	};

	Promise.prototype.del = // XXX legacy
	Promise.prototype["delete"] = function (key) {
	    return this.dispatch("delete", [key]);
	};

	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param value     a value to post, typically an array of
	 *                  invocation arguments for promises that
	 *                  are ultimately backed with `resolve` values,
	 *                  as opposed to those backed with URLs
	 *                  wherein the posted value can be any
	 *                  JSON serializable object.
	 * @return promise for the return value
	 */
	// bound locally because it is used by other methods
	Q.mapply = // XXX As proposed by "Redsandro"
	Q.post = function (object, name, args) {
	    return Q(object).dispatch("post", [name, args]);
	};

	Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	Promise.prototype.post = function (name, args) {
	    return this.dispatch("post", [name, args]);
	};

	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param ...args   array of invocation arguments
	 * @return promise for the return value
	 */
	Q.send = // XXX Mark Miller's proposed parlance
	Q.mcall = // XXX As proposed by "Redsandro"
	Q.invoke = function (object, name /*...args*/) {
	    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	};

	Promise.prototype.send = // XXX Mark Miller's proposed parlance
	Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	Promise.prototype.invoke = function (name /*...args*/) {
	    return this.dispatch("post", [name, array_slice(arguments, 1)]);
	};

	/**
	 * Applies the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param args      array of application arguments
	 */
	Q.fapply = function (object, args) {
	    return Q(object).dispatch("apply", [void 0, args]);
	};

	Promise.prototype.fapply = function (args) {
	    return this.dispatch("apply", [void 0, args]);
	};

	/**
	 * Calls the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q["try"] =
	Q.fcall = function (object /* ...args*/) {
	    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	};

	Promise.prototype.fcall = function (/*...args*/) {
	    return this.dispatch("apply", [void 0, array_slice(arguments)]);
	};

	/**
	 * Binds the promised function, transforming return values into a fulfilled
	 * promise and thrown errors into a rejected one.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q.fbind = function (object /*...args*/) {
	    var promise = Q(object);
	    var args = array_slice(arguments, 1);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};
	Promise.prototype.fbind = function (/*...args*/) {
	    var promise = this;
	    var args = array_slice(arguments);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};

	/**
	 * Requests the names of the owned properties of a promised
	 * object in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @return promise for the keys of the eventually settled object
	 */
	Q.keys = function (object) {
	    return Q(object).dispatch("keys", []);
	};

	Promise.prototype.keys = function () {
	    return this.dispatch("keys", []);
	};

	/**
	 * Turns an array of promises into a promise for an array.  If any of
	 * the promises gets rejected, the whole array is rejected immediately.
	 * @param {Array*} an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns a promise for an array of the corresponding values
	 */
	// By Mark Miller
	// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	Q.all = all;
	function all(promises) {
	    return when(promises, function (promises) {
	        var pendingCount = 0;
	        var deferred = defer();
	        array_reduce(promises, function (undefined, promise, index) {
	            var snapshot;
	            if (
	                isPromise(promise) &&
	                (snapshot = promise.inspect()).state === "fulfilled"
	            ) {
	                promises[index] = snapshot.value;
	            } else {
	                ++pendingCount;
	                when(
	                    promise,
	                    function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    },
	                    deferred.reject,
	                    function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    }
	                );
	            }
	        }, void 0);
	        if (pendingCount === 0) {
	            deferred.resolve(promises);
	        }
	        return deferred.promise;
	    });
	}

	Promise.prototype.all = function () {
	    return all(this);
	};

	/**
	 * Returns the first resolved promise of an array. Prior rejected promises are
	 * ignored.  Rejects only if all promises are rejected.
	 * @param {Array*} an array containing values or promises for values
	 * @returns a promise fulfilled with the value of the first resolved promise,
	 * or a rejected promise if all promises are rejected.
	 */
	Q.any = any;

	function any(promises) {
	    if (promises.length === 0) {
	        return Q.resolve();
	    }

	    var deferred = Q.defer();
	    var pendingCount = 0;
	    array_reduce(promises, function (prev, current, index) {
	        var promise = promises[index];

	        pendingCount++;

	        when(promise, onFulfilled, onRejected, onProgress);
	        function onFulfilled(result) {
	            deferred.resolve(result);
	        }
	        function onRejected() {
	            pendingCount--;
	            if (pendingCount === 0) {
	                deferred.reject(new Error(
	                    "Can't get fulfillment value from any promise, all " +
	                    "promises were rejected."
	                ));
	            }
	        }
	        function onProgress(progress) {
	            deferred.notify({
	                index: index,
	                value: progress
	            });
	        }
	    }, undefined);

	    return deferred.promise;
	}

	Promise.prototype.any = function () {
	    return any(this);
	};

	/**
	 * Waits for all promises to be settled, either fulfilled or
	 * rejected.  This is distinct from `all` since that would stop
	 * waiting at the first rejection.  The promise returned by
	 * `allResolved` will never be rejected.
	 * @param promises a promise for an array (or an array) of promises
	 * (or values)
	 * @return a promise for an array of promises
	 */
	Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	function allResolved(promises) {
	    return when(promises, function (promises) {
	        promises = array_map(promises, Q);
	        return when(all(array_map(promises, function (promise) {
	            return when(promise, noop, noop);
	        })), function () {
	            return promises;
	        });
	    });
	}

	Promise.prototype.allResolved = function () {
	    return allResolved(this);
	};

	/**
	 * @see Promise#allSettled
	 */
	Q.allSettled = allSettled;
	function allSettled(promises) {
	    return Q(promises).allSettled();
	}

	/**
	 * Turns an array of promises into a promise for an array of their states (as
	 * returned by `inspect`) when they have all settled.
	 * @param {Array[Any*]} values an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns {Array[State]} an array of states for the respective values.
	 */
	Promise.prototype.allSettled = function () {
	    return this.then(function (promises) {
	        return all(array_map(promises, function (promise) {
	            promise = Q(promise);
	            function regardless() {
	                return promise.inspect();
	            }
	            return promise.then(regardless, regardless);
	        }));
	    });
	};

	/**
	 * Captures the failure of a promise, giving an oportunity to recover
	 * with a callback.  If the given promise is fulfilled, the returned
	 * promise is fulfilled.
	 * @param {Any*} promise for something
	 * @param {Function} callback to fulfill the returned promise if the
	 * given promise is rejected
	 * @returns a promise for the return value of the callback
	 */
	Q.fail = // XXX legacy
	Q["catch"] = function (object, rejected) {
	    return Q(object).then(void 0, rejected);
	};

	Promise.prototype.fail = // XXX legacy
	Promise.prototype["catch"] = function (rejected) {
	    return this.then(void 0, rejected);
	};

	/**
	 * Attaches a listener that can respond to progress notifications from a
	 * promise's originating deferred. This listener receives the exact arguments
	 * passed to ``deferred.notify``.
	 * @param {Any*} promise for something
	 * @param {Function} callback to receive any progress notifications
	 * @returns the given promise, unchanged
	 */
	Q.progress = progress;
	function progress(object, progressed) {
	    return Q(object).then(void 0, void 0, progressed);
	}

	Promise.prototype.progress = function (progressed) {
	    return this.then(void 0, void 0, progressed);
	};

	/**
	 * Provides an opportunity to observe the settling of a promise,
	 * regardless of whether the promise is fulfilled or rejected.  Forwards
	 * the resolution to the returned promise when the callback is done.
	 * The callback can return a promise to defer completion.
	 * @param {Any*} promise
	 * @param {Function} callback to observe the resolution of the given
	 * promise, takes no arguments.
	 * @returns a promise for the resolution of the given promise when
	 * ``fin`` is done.
	 */
	Q.fin = // XXX legacy
	Q["finally"] = function (object, callback) {
	    return Q(object)["finally"](callback);
	};

	Promise.prototype.fin = // XXX legacy
	Promise.prototype["finally"] = function (callback) {
	    callback = Q(callback);
	    return this.then(function (value) {
	        return callback.fcall().then(function () {
	            return value;
	        });
	    }, function (reason) {
	        // TODO attempt to recycle the rejection with "this".
	        return callback.fcall().then(function () {
	            throw reason;
	        });
	    });
	};

	/**
	 * Terminates a chain of promises, forcing rejections to be
	 * thrown as exceptions.
	 * @param {Any*} promise at the end of a chain of promises
	 * @returns nothing
	 */
	Q.done = function (object, fulfilled, rejected, progress) {
	    return Q(object).done(fulfilled, rejected, progress);
	};

	Promise.prototype.done = function (fulfilled, rejected, progress) {
	    var onUnhandledError = function (error) {
	        // forward to a future turn so that ``when``
	        // does not catch it and turn it into a rejection.
	        Q.nextTick(function () {
	            makeStackTraceLong(error, promise);
	            if (Q.onerror) {
	                Q.onerror(error);
	            } else {
	                throw error;
	            }
	        });
	    };

	    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	    var promise = fulfilled || rejected || progress ?
	        this.then(fulfilled, rejected, progress) :
	        this;

	    if (typeof process === "object" && process && process.domain) {
	        onUnhandledError = process.domain.bind(onUnhandledError);
	    }

	    promise.then(void 0, onUnhandledError);
	};

	/**
	 * Causes a promise to be rejected if it does not get fulfilled before
	 * some milliseconds time out.
	 * @param {Any*} promise
	 * @param {Number} milliseconds timeout
	 * @param {Any*} custom error message or Error object (optional)
	 * @returns a promise for the resolution of the given promise if it is
	 * fulfilled before the timeout, otherwise rejected.
	 */
	Q.timeout = function (object, ms, error) {
	    return Q(object).timeout(ms, error);
	};

	Promise.prototype.timeout = function (ms, error) {
	    var deferred = defer();
	    var timeoutId = setTimeout(function () {
	        if (!error || "string" === typeof error) {
	            error = new Error(error || "Timed out after " + ms + " ms");
	            error.code = "ETIMEDOUT";
	        }
	        deferred.reject(error);
	    }, ms);

	    this.then(function (value) {
	        clearTimeout(timeoutId);
	        deferred.resolve(value);
	    }, function (exception) {
	        clearTimeout(timeoutId);
	        deferred.reject(exception);
	    }, deferred.notify);

	    return deferred.promise;
	};

	/**
	 * Returns a promise for the given value (or promised value), some
	 * milliseconds after it resolved. Passes rejections immediately.
	 * @param {Any*} promise
	 * @param {Number} milliseconds
	 * @returns a promise for the resolution of the given promise after milliseconds
	 * time has elapsed since the resolution of the given promise.
	 * If the given promise rejects, that is passed immediately.
	 */
	Q.delay = function (object, timeout) {
	    if (timeout === void 0) {
	        timeout = object;
	        object = void 0;
	    }
	    return Q(object).delay(timeout);
	};

	Promise.prototype.delay = function (timeout) {
	    return this.then(function (value) {
	        var deferred = defer();
	        setTimeout(function () {
	            deferred.resolve(value);
	        }, timeout);
	        return deferred.promise;
	    });
	};

	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided as an array, and returns a promise.
	 *
	 *      Q.nfapply(FS.readFile, [__filename])
	 *      .then(function (content) {
	 *      })
	 *
	 */
	Q.nfapply = function (callback, args) {
	    return Q(callback).nfapply(args);
	};

	Promise.prototype.nfapply = function (args) {
	    var deferred = defer();
	    var nodeArgs = array_slice(args);
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided individually, and returns a promise.
	 * @example
	 * Q.nfcall(FS.readFile, __filename)
	 * .then(function (content) {
	 * })
	 *
	 */
	Q.nfcall = function (callback /*...args*/) {
	    var args = array_slice(arguments, 1);
	    return Q(callback).nfapply(args);
	};

	Promise.prototype.nfcall = function (/*...args*/) {
	    var nodeArgs = array_slice(arguments);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Wraps a NodeJS continuation passing function and returns an equivalent
	 * version that returns a promise.
	 * @example
	 * Q.nfbind(FS.readFile, __filename)("utf-8")
	 * .then(console.log)
	 * .done()
	 */
	Q.nfbind =
	Q.denodeify = function (callback /*...args*/) {
	    var baseArgs = array_slice(arguments, 1);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(callback).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};

	Promise.prototype.nfbind =
	Promise.prototype.denodeify = function (/*...args*/) {
	    var args = array_slice(arguments);
	    args.unshift(this);
	    return Q.denodeify.apply(void 0, args);
	};

	Q.nbind = function (callback, thisp /*...args*/) {
	    var baseArgs = array_slice(arguments, 2);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        function bound() {
	            return callback.apply(thisp, arguments);
	        }
	        Q(bound).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};

	Promise.prototype.nbind = function (/*thisp, ...args*/) {
	    var args = array_slice(arguments, 0);
	    args.unshift(this);
	    return Q.nbind.apply(void 0, args);
	};

	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback with a given array of arguments, plus a provided callback.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param {Array} args arguments to pass to the method; the callback
	 * will be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nmapply = // XXX As proposed by "Redsandro"
	Q.npost = function (object, name, args) {
	    return Q(object).npost(name, args);
	};

	Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	Promise.prototype.npost = function (name, args) {
	    var nodeArgs = array_slice(args || []);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback, forwarding the given variadic arguments, plus a provided
	 * callback argument.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param ...args arguments to pass to the method; the callback will
	 * be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nsend = // XXX Based on Mark Miller's proposed "send"
	Q.nmcall = // XXX Based on "Redsandro's" proposal
	Q.ninvoke = function (object, name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 2);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	Promise.prototype.ninvoke = function (name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 1);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * If a function would like to support both Node continuation-passing-style and
	 * promise-returning-style, it can end its internal promise chain with
	 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	 * elects to use a nodeback, the result will be sent there.  If they do not
	 * pass a nodeback, they will receive the result promise.
	 * @param object a result (or a promise for a result)
	 * @param {Function} nodeback a Node.js-style callback
	 * @returns either the promise or nothing
	 */
	Q.nodeify = nodeify;
	function nodeify(object, nodeback) {
	    return Q(object).nodeify(nodeback);
	}

	Promise.prototype.nodeify = function (nodeback) {
	    if (nodeback) {
	        this.then(function (value) {
	            Q.nextTick(function () {
	                nodeback(null, value);
	            });
	        }, function (error) {
	            Q.nextTick(function () {
	                nodeback(error);
	            });
	        });
	    } else {
	        return this;
	    }
	};

	Q.noConflict = function() {
	    throw new Error("Q.noConflict only works when Q is used as a global");
	};

	// All code before this point will be filtered from stack traces.
	var qEndingLine = captureLine();

	return Q;

	});


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = {
		"signout": "Sign Out",
		"remember": "Remember me",
		"rememberDevice": "Trust this device",
		"rememberDevice.timebased": "Do not challenge me on this device for the next {0}",
		"rememberDevice.devicebased": "Do not challenge me on this device again",
		"autoPush": "Send push automatically",
		"unlockaccount": "Unlock account?",
		"needhelp": "Need help signing in?",
		"goback": "Back to Sign In",
		"forgotpassword": "Forgot password?",
		"help": "Help",
		"minutes.oneMinute": "minute",
		"minutes": "{0} minutes",
		"hours": "{0} hours",
		"days": "{0} days",
		"error.config": "There was a configuration error",
		"error.required.authParams": "Missing parameters for the configured authentication scheme - \"OAUTH2\"",
		"error.required.baseUrl": "\"baseUrl\" is a required widget parameter",
		"error.required.success": "A success handler is required",
		"error.required.el": "\"el\" is a required widget parameter",
		"error.unsupported.browser": "Unsupported browser",
		"error.unsupported.cors": "Unsupported browser - missing CORS support",
		"error.unsupported.localStorage": "Unsupported browser - missing localStorage support",
		"error.enabled.cors": "There was an error sending the request - have you enabled CORS?",
		"error.expired.session": "Your session has expired. Please try to log in again.",
		"error.auth.lockedOut": "Your account is locked. Please contact your administrator.",
		"error.oauth.idToken": "There was a problem generating the id_token for the user. Please try again.",
		"error.network.connection": "Unable to connect to the server. Please check your network connection.",
		"errors.E0000004": "Sign in failed!",
		"errors.E0000069": "Your account was locked due to excessive MFA attempts.",
		"errors.E0000047": "You exceeded the maximum number of requests. Try again in a while.",
		"oform.next": "Next",
		"oform.verify": "Verify",
		"oform.send": "Send",
		"oform.back": "Back",
		"oform.save": "Save",
		"oform.cancel": "Cancel",
		"oform.edit": "Edit",
		"oform.previous": "Previous",
		"oform.errorbanner.title": "We found some errors. Please review the form and make corrections.",
		"oform.errormsg.title": "Please review the form to correct the following errors:",
		"oform.error.unexpected": "There was an unexpected internal error. Please try again.",
		"model.validation.field.blank": "The field cannot be left blank",
		"model.validation.field.wrong.type": "The field is of the wrong type",
		"model.validation.field.invalid": "The field has an invalid value",
		"model.validation.field.value.not.allowed": "The field value is not allowed",
		"model.validation.field.array.minItems": "The array does not have enough items",
		"model.validation.field.array.unique": "The array can only have unique values",
		"model.validation.field.username": "Please check your username",
		"factor.totpSoft.oktaVerify": "Okta Verify",
		"factor.totpSoft.googleAuthenticator": "Google Authenticator",
		"factor.totpSoft.description": "Enter single-use code from the mobile app.",
		"factor.totpHard.rsaSecurId": "RSA SecurID",
		"factor.totpHard.symantecVip": "Symantec VIP",
		"factor.totpHard.description": "Enter a single-use code from a hardware token.",
		"factor.totpHard.yubikey": "Yubikey",
		"factor.totpHard.yubikey.description": "Insert your Yubikey and tap it to get a verification code.",
		"factor.totpHard.yubikey.placeholder": "Click here, then tap your Yubikey",
		"factor.oktaVerifyPush": "Okta Verify",
		"factor.push.description": "Use a push notification sent to the mobile app.",
		"factor.duo": "Duo Security",
		"factor.duo.description": "Use Push Notification, SMS, or Voice call to authenticate.",
		"factor.sms": "SMS Authentication",
		"factor.sms.description": "Enter a single-use code sent to your mobile phone.",
		"factor.call": "Voice Call Authentication",
		"factor.call.description": "Use a phone to authenticate by following voice instructions.",
		"factor.securityQuestion": "Security Question",
		"factor.securityQuestion.description": "Use the answer to a security question to authenticate.",
		"factor.windowsHello": "Windows Hello",
		"factor.windowsHello.signin.description": "Sign in to Okta using Windows Hello.",
		"factor.u2f": "Security Key (U2F)",
		"factor.u2f.description": "Use a Universal 2nd Factor (U2F) security key to sign on to Okta.",
		"mfa.challenge.verify": "Verify",
		"mfa.challenge.answer.placeholder": "Answer",
		"mfa.challenge.answer.tooltip": "Answer",
		"mfa.challenge.answer.showAnswer": "Show",
		"mfa.challenge.answer.hideAnswer": "Hide",
		"mfa.challenge.enterCode.placeholder": "Enter Code",
		"mfa.challenge.enterCode.tooltip": "Enter Code",
		"mfa.backToFactors": "Back to factor list",
		"mfa.phoneNumber.placeholder": "Phone number",
		"mfa.phoneNumber.ext.placeholder": "Extension",
		"mfa.sendCode": "Send code",
		"mfa.sent": "Sent",
		"mfa.resendCode": "Re-send code",
		"mfa.call": "Call",
		"mfa.calling": "Calling",
		"mfa.redial": "Redial",
		"mfa.scanBarcode": "Scan barcode",
		"mfa.noAccessToEmail": "Can't access email",
		"password.reset": "Reset Password",
		"password.oldPassword.placeholder": "Old password",
		"password.oldPassword.tooltip": "Old password",
		"password.newPassword.placeholder": "New password",
		"password.newPassword.tooltip": "New password",
		"password.confirmPassword.placeholder": "Repeat password",
		"password.confirmPassword.tooltip": "Repeat password",
		"password.error.match": "New passwords must match",
		"recovery.sms.hint": "SMS can only be used if a mobile phone number has been configured.",
		"recovery.mobile.hint": "{0} can only be used if a mobile phone number has been configured.",
		"recovery.sms": "SMS",
		"recovery.call": "Voice Call",
		"recovery.smsOrCall": "SMS or Voice Call",
		"enroll.choices.title": "Set up multifactor authentication",
		"enroll.choices.description": "Your company requires multifactor authentication to add an additional layer of security when signing into your Okta account",
		"enroll.choices.optional": "You can configure any additional optional factor or click finish",
		"enroll.choices.list.setup": "Setup required",
		"enroll.choices.list.enrolled": "Enrolled factors",
		"enroll.choices.list.optional": "Additional optional factors",
		"enroll.choices.step": "{0} of {1}",
		"enroll.choices.setup": "Setup",
		"enroll.choices.submit.finish": "Finish",
		"enroll.choices.submit.configure": "Configure factor",
		"enroll.choices.submit.next": "Configure next factor",
		"enroll.securityQuestion.setup": "Setup secret question authentication",
		"security.disliked_food": "What is the food you least liked as a child?",
		"security.name_of_first_plush_toy": "What is the name of your first stuffed animal?",
		"security.first_award": "What did you earn your first medal or award for?",
		"security.favorite_security_question": "What is your favorite security question?",
		"security.favorite_toy": "What is the toy/stuffed animal you liked the most as a kid?",
		"security.first_computer_game": "What was the first computer game you played?",
		"security.favorite_movie_quote": "What is your favorite movie quote?",
		"security.first_sports_team_mascot": "What was the mascot of the first sports team you played on?",
		"security.first_music_purchase": "What music album or song did you first purchase?",
		"security.favorite_art_piece": "What is your favorite piece of art?",
		"security.grandmother_favorite_desert": "What was your grandmother's favorite dessert?",
		"security.first_thing_cooked": "What was the first thing you learned to cook?",
		"security.childhood_dream_job": "What was your dream job as a child?",
		"security.first_kiss_location": "Where did you have your first kiss?",
		"security.place_where_significant_other_was_met": "Where did you meet your spouse/significant other?",
		"security.favorite_vacation_location": "Where did you go for your favorite vacation?",
		"security.new_years_two_thousand": "Where were you on New Year's Eve in the year 2000?",
		"security.favorite_speaker_actor": "Who is your favorite speaker/orator?",
		"security.favorite_book_movie_character": "Who is your favorite book/movie character?",
		"security.favorite_sports_player": "Who is your favorite sports player?",
		"enroll.sms.setup": "Receive a code via SMS to authenticate",
		"enroll.call.setup": "Follow phone call instructions to authenticate",
		"enroll.onprem.username.placeholder": "Enter {0} username",
		"enroll.onprem.username.tooltip": "Enter {0} username",
		"enroll.onprem.passcode.placeholder": "Enter {0} passcode",
		"enroll.onprem.passcode.tooltip": "Enter {0} passcode",
		"enroll.symantecVip.subtitle": "Enter Credential ID and two consecutive generated codes",
		"enroll.symantecVip.credentialId.placeholder": "Enter credential ID",
		"enroll.symantecVip.credentialId.tooltip": "Enter credential ID",
		"enroll.symantecVip.passcode1.placeholder": "Security code 1",
		"enroll.symantecVip.passcode1.tooltip": "Security code 1",
		"enroll.symantecVip.passcode2.placeholder": "Security code 2",
		"enroll.symantecVip.passcode2.tooltip": "Security code 2",
		"enroll.yubikey.title": "Setup Yubikey",
		"enroll.yubikey.subtitle": "Insert your Yubikey into a USB port and tap it to generate a verification code",
		"enroll.totp.title": "Setup {0}",
		"enroll.totp.selectDevice": "Select your device type",
		"enroll.totp.downloadApp": "Download <a href=\"{0}\" class=\"inline-link\">{1} from the {2}</a> onto your mobile device.",
		"enroll.totp.installApp": "Install {0}",
		"enroll.duo.title": "Setup Duo Security",
		"enroll.windowsHello.title": "Enroll Windows Hello",
		"enroll.windowsHello.subtitle": "Click below to enroll Windows Hello as a second form of authentication",
		"enroll.windowsHello.subtitle.loading": "Please wait while Windows Hello is loading...",
		"enroll.windowsHello.save": "Enroll Windows Hello",
		"enroll.windowsHello.error.notWindows": "Windows Hello can only be used on Windows Edge with Windows 10. Contact your admin for assistance.",
		"enroll.windowsHello.error.notConfiguredHtml": "Windows Hello is not configured. Select the <b>Start</b> button, then select <b>Settings</b> &gt; <b>Accounts</b> &gt; <b>Sign-in</b> to configure Windows Hello.",
		"verify.windowsHello.subtitle": "Verify your identity with Windows Hello",
		"verify.windowsHello.subtitle.loading": "Please wait while Windows Hello is loading...",
		"verify.windowsHello.subtitle.signingIn": "Signing into Okta...",
		"verify.windowsHello.save": "Verify with Windows Hello",
		"verify.windowsHello.error.notFound": "Your Windows Hello enrollment does not match our records. Contact your administrator for assistance.",
		"verify.windowsHello.error.notFound.selectAnother": "Your Windows Hello enrollment does not match our records. Select another factor or contact your administrator for assistance.",
		"enroll.u2f.title": "Setup Security Key (U2F)",
		"enroll.u2f.save": "Register Security Key",
		"enroll.u2f.general1": "If using Firefox download and install the U2F browser extension.",
		"enroll.u2f.general2": "Make sure you have a Security Key. If already inserted, remove it now.<br>If you have a Bluetooth Security Key, turn on your computer's Bluetooth.",
		"enroll.u2f.general3": "Click the button below to register",
		"enroll.u2f.instructions": "Insert your Security Key into a USB port on this computer. If it has a button or gold disk, tap it.",
		"enroll.u2f.instructionsBluetooth": "If you are using a Bluetooth Security Key, press the button.",
		"u2f.error.notSupportedBrowser": "The Security Key is only supported for Chrome or Firefox browsers. Select another factor or contact your admin for assistance.",
		"u2f.error.notSupportedBrowser.oneFactor": "The Security Key is only supported for Chrome or Firefox browsers. Contact your admin for assistance.",
		"u2f.error.noFirefoxExtension": "<a target=\"_blank\" href=\"https://addons.mozilla.org/en-US/firefox/addon/u2f-support-add-on/\">Download</a> and install the Firefox U2F browser extension before proceeding. You may be required to restart your browser after installation.",
		"u2f.error.other": "An unknown error has occured. Try again or select another factor.",
		"u2f.error.other.oneFactor": "An unknown error has occured. Try again or contact your admin for assistance.",
		"u2f.error.badRequest": "There was an error with the U2F request. Try again or select another factor.",
		"u2f.error.badRequest.oneFactor": "There was an error with the U2F request. Try again or contact your admin for assistance.",
		"u2f.error.unsupported": "The security key is unsupported. Select another factor.",
		"u2f.error.unsupported.oneFactor": "The security key is unsupported. Contact your admin for assistance.",
		"u2f.error.timeout": "You have timed out of the authentication period. Please try again.",
		"verify.u2f.instructions": "Insert your Security Key. If it has a button or gold disk, tap it.",
		"verify.u2f.instructionsBluetooth": "If you are using a Bluetooth Security Key, turn on your computer's Bluetooth and press the button.",
		"verify.u2f.retry": "Retry",
		"enroll.totp.enterCode": "Enter code displayed from the application",
		"enroll.totp.setupApp": "Launch {0} application on your mobile device and select Add an account.",
		"enroll.totp.setupGoogleAuthApp": "Launch {0}, tap the \"+\" icon, then select \"Scan barcode\".",
		"enroll.totp.cannotScan": "Can't scan?",
		"enroll.totp.refreshBarcode": "Refresh code",
		"enroll.totp.cannotScanBarcode": "Can't scan barcode?",
		"enroll.totp.manualSetupInstructions": "To set up manually enter your Okta Account username and then input the following in the Secret Key Field",
		"enroll.totp.sharedSecretInstructions": "Enter your Okta Account username and enter the following in the Secret Key Field",
		"enroll.totp.sendSms": "Send activation link via SMS",
		"enroll.totp.sendEmail": "Send activation link via email",
		"enroll.totp.setupManually": "Setup manually without push notification",
		"enroll.totp.enrollViaEmail.title": "Activation email sent!",
		"enroll.totp.enrollViaEmail.msg": "Open the email from your mobile device.",
		"enroll.totp.enrollViaSms.title": "SMS sent!",
		"enroll.totp.enrollViaSms.msg": "View the SMS on your mobile device.",
		"recoveryChallenge.sms.title": "Enter verification code sent via SMS",
		"recoveryChallenge.call.title": "Enter verification code received via Voice Call",
		"mfa.factors.dropdown.title": "Select an authentication factor",
		"mfa.duoSecurity.push": "Push — {0}",
		"mfa.duoSecurity.sms": "SMS — {0}",
		"mfa.duoSecurity.call": "Call — {0}",
		"mfa.challenge.title": "Enter your {0} passcode",
		"mfa.challenge.orEnterCode": "Or enter code",
		"oktaverify.send": "Send Push",
		"oktaverify.sent": "Push sent!",
		"oktaverify.rejected": "You have chosen to reject this login.",
		"oktaverify.timeout": "Your push notification has expired.",
		"primaryauth.title": "Sign In",
		"primaryauth.username.placeholder": "Username",
		"primaryauth.username.tooltip": "Username",
		"primaryauth.password.placeholder": "Password",
		"primaryauth.password.tooltip": "Password",
		"primaryauth.submit": "Sign In",
		"primaryauth.newUser.tooltip": "This is the first time you are connecting to {0} from this browser",
		"primaryauth.newUser.tooltip.close": "Close",
		"password.forgot.email.or.username.placeholder": "Email or Username",
		"password.forgot.email.or.username.tooltip": "Email or Username",
		"password.forgot.sendText": "Reset via SMS",
		"password.forgot.sendEmail": "Reset via Email",
		"password.forgot.call": "Reset via Voice Call",
		"password.forgot.emailSent.title": "Email sent!",
		"password.forgot.emailSent.desc": "Email has been sent to {0} with instructions on resetting your password.",
		"password.forgot.question.title": "Answer Forgotten Password Challenge",
		"password.forgot.question.submit": "Reset Password",
		"password.forgot.sms.notReceived": "Didn't receive an SMS? Reset via email",
		"password.forgot.code.notReceived": "Didn't receive a code? Reset via email",
		"password.reset.title": "Reset your Okta password",
		"password.complexity.description": "Your password must have {0}.",
		"password.complexity.length": "at least {0} characters",
		"password.complexity.list.element": ", {0}",
		"password.complexity.lowercase": "a lowercase letter",
		"password.complexity.uppercase": "an uppercase letter",
		"password.complexity.number": "a number",
		"password.complexity.symbol": "a symbol",
		"password.complexity.no_username": "no parts of your username",
		"password.expired.submit": "Change Password",
		"password.expired.title": "Your Okta password has expired",
		"password.expiring.later": "Remind me later",
		"password.expiring.title": "Your password will expire in {0} days",
		"password.expiring.today": "Your password will expire later today",
		"password.expiring.subtitle": "When password expires you may be locked out of Okta Mobile, mobile email, and other services.",
		"password.expired.custom.submit": "Go to {0}",
		"password.expired.custom.subtitle": "This password is set on another website. Click the button below to go there and set a new password.",
		"account.unlock.title": "Unlock account",
		"account.unlock.email.or.username.placeholder": "Email or username",
		"account.unlock.email.or.username.tooltip": "Email or username",
		"account.unlock.sendText": "Send SMS",
		"account.unlock.sendEmail": "Send Email",
		"account.unlock.emailSent.title": "Email sent!",
		"account.unlock.emailSent.desc": "Email has been sent to {0} with instructions on unlocking your account.",
		"account.unlock.question.title": "Answer Unlock Account Challenge",
		"account.unlock.question.submit": "Unlock Account",
		"account.unlock.unlocked.title": "Account successfully unlocked!",
		"account.unlock.unlocked.desc": "You can log in using your existing username and password.",
		"account.unlock.sms.notReceived": "Didn't receive an SMS? Unlock via email",
		"contact.support": "If you didn't provide a secondary email address or don't have access to email, please contact your administrator at {0}",
		"socialauth.divider.text": "OR",
		"socialauth.facebook.label": "Sign in with Facebook",
		"socialauth.google.label": "Sign in with Google",
		"socialauth.linkedin.label": "Sign in with LinkedIn",
		"socialauth.microsoft.label": "Sign in with Microsoft",
		"socialauth.popup.title": "External Identity Provider User Authentication",
		"unsupported.oneDrive.title": "Your OneDrive version is not supported",
		"unsupported.oneDrive.desc": "Upgrade now by installing the OneDrive for Business Next Generation Sync Client to login to Okta",
		"unsupported.oneDrive.action": "Learn how to upgrade"
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = {
		"AF": "Afghanistan",
		"AX": "Åland Islands",
		"AL": "Albania",
		"DZ": "Algeria",
		"AS": "American Samoa",
		"AD": "Andorra",
		"AO": "Angola",
		"AI": "Anguilla",
		"AQ": "Antarctica",
		"AG": "Antigua and Barbuda",
		"AR": "Argentina",
		"AM": "Armenia",
		"AW": "Aruba",
		"AU": "Australia",
		"AT": "Austria",
		"AZ": "Azerbaijan",
		"BS": "Bahamas",
		"BH": "Bahrain",
		"BD": "Bangladesh",
		"BB": "Barbados",
		"BY": "Belarus",
		"BE": "Belgium",
		"BZ": "Belize",
		"BJ": "Benin",
		"BM": "Bermuda",
		"BT": "Bhutan",
		"BO": "Bolivia, Plurinational State of",
		"BA": "Bosnia and Herzegovina",
		"BW": "Botswana",
		"BV": "Bouvet Island",
		"BR": "Brazil",
		"IO": "British Indian Ocean Territory",
		"VG": "Virgin Islands, British",
		"BN": "Brunei Darussalam",
		"BG": "Bulgaria",
		"BF": "Burkina Faso",
		"BI": "Burundi",
		"KH": "Cambodia",
		"CM": "Cameroon",
		"CA": "Canada",
		"CV": "Cape Verde",
		"KY": "Cayman Islands",
		"CF": "Central African Republic",
		"TD": "Chad",
		"CL": "Chile",
		"CN": "China",
		"CX": "Christmas Island",
		"CO": "Colombia",
		"KM": "Comoros",
		"CG": "Congo",
		"CK": "Cook Islands",
		"CR": "Costa Rica",
		"CI": "Côte d'Ivoire",
		"HR": "Croatia",
		"CU": "Cuba",
		"CY": "Cyprus",
		"CZ": "Czech Republic",
		"CD": "Congo, the Democratic Republic of the",
		"DK": "Denmark",
		"DJ": "Djibouti",
		"DM": "Dominica",
		"DO": "Dominican Republic",
		"TL": "Timor-Leste",
		"EC": "Ecuador",
		"EG": "Egypt",
		"SV": "El Salvador",
		"GQ": "Equatorial Guinea",
		"ER": "Eritrea",
		"EE": "Estonia",
		"ET": "Ethiopia",
		"FK": "Falkland Islands (Malvinas)",
		"FO": "Faroe Islands",
		"FJ": "Fiji",
		"FI": "Finland",
		"FR": "France",
		"GF": "French Guiana",
		"PF": "French Polynesia",
		"TF": "French Southern Territories",
		"GA": "Gabon",
		"GM": "Gambia",
		"GE": "Georgia",
		"DE": "Germany",
		"GH": "Ghana",
		"GI": "Gibraltar",
		"GR": "Greece",
		"GL": "Greenland",
		"GD": "Grenada",
		"GP": "Guadeloupe",
		"GU": "Guam",
		"GT": "Guatemala",
		"GG": "Guernsey",
		"GN": "Guinea",
		"GW": "Guinea-Bissau",
		"GY": "Guyana",
		"HT": "Haiti",
		"HM": "Heard Island and McDonald Islands",
		"HN": "Honduras",
		"HK": "Hong Kong",
		"HU": "Hungary",
		"IS": "Iceland",
		"IN": "India",
		"ID": "Indonesia",
		"IR": "Iran, Islamic Republic of",
		"IQ": "Iraq",
		"IE": "Ireland",
		"IL": "Israel",
		"IT": "Italy",
		"JM": "Jamaica",
		"JP": "Japan",
		"JE": "Jersey",
		"JO": "Jordan",
		"KZ": "Kazakhstan",
		"KE": "Kenya",
		"KI": "Kiribati",
		"KR": "Korea, Republic of",
		"KW": "Kuwait",
		"KG": "Kyrgyzstan",
		"LA": "Lao People's Democratic Republic",
		"LV": "Latvia",
		"LB": "Lebanon",
		"LS": "Lesotho",
		"LR": "Liberia",
		"LY": "Libya",
		"LI": "Liechtenstein",
		"LT": "Lithuania",
		"LU": "Luxembourg",
		"MO": "Macao",
		"MK": "Macedonia, the former Yugoslav Republic of",
		"MG": "Madagascar",
		"MW": "Malawi",
		"MY": "Malaysia",
		"MV": "Maldives",
		"ML": "Mali",
		"MT": "Malta",
		"MH": "Marshall Islands",
		"MQ": "Martinique",
		"MR": "Mauritania",
		"MU": "Mauritius",
		"YT": "Mayotte",
		"MX": "Mexico",
		"FM": "Micronesia, Federated States of",
		"MD": "Moldova, Republic of",
		"MC": "Monaco",
		"MN": "Mongolia",
		"ME": "Montenegro",
		"MS": "Montserrat",
		"MA": "Morocco",
		"MZ": "Mozambique",
		"MM": "Myanmar",
		"NA": "Namibia",
		"NR": "Nauru",
		"NP": "Nepal",
		"NL": "Netherlands",
		"AN": "Netherlands Antilles",
		"NC": "New Caledonia",
		"NZ": "New Zealand",
		"NI": "Nicaragua",
		"NE": "Niger",
		"NG": "Nigeria",
		"NU": "Niue",
		"NF": "Norfolk Island",
		"KP": "Korea, Democratic People's Republic of",
		"MP": "Northern Mariana Islands",
		"NO": "Norway",
		"OM": "Oman",
		"PK": "Pakistan",
		"PW": "Palau",
		"PS": "Palestine, State of",
		"PA": "Panama",
		"PG": "Papua New Guinea",
		"PY": "Paraguay",
		"PE": "Peru",
		"PH": "Philippines",
		"PN": "Pitcairn",
		"PL": "Poland",
		"PT": "Portugal",
		"PR": "Puerto Rico",
		"QA": "Qatar",
		"RE": "Réunion",
		"RO": "Romania",
		"RU": "Russian Federation",
		"RW": "Rwanda",
		"SH": "Saint Helena, Ascension and Tristan da Cunha",
		"KN": "Saint Kitts and Nevis",
		"LC": "Saint Lucia",
		"PM": "Saint Pierre and Miquelon",
		"VC": "Saint Vincent and the Grenadines",
		"WS": "Samoa",
		"SM": "San Marino",
		"ST": "São Tomé and Príncipe",
		"SA": "Saudi Arabia",
		"SN": "Senegal",
		"RS": "Serbia",
		"SC": "Seychelles",
		"SL": "Sierra Leone",
		"SG": "Singapore",
		"SK": "Slovakia",
		"SI": "Slovenia",
		"SB": "Solomon Islands",
		"SO": "Somalia",
		"ZA": "South Africa",
		"GS": "South Georgia and the South Sandwich Islands",
		"SS": "South Sudan",
		"ES": "Spain",
		"LK": "Sri Lanka",
		"SD": "Sudan",
		"SR": "Suriname",
		"SJ": "Svalbard and Jan Mayen",
		"SZ": "Swaziland",
		"SE": "Sweden",
		"CH": "Switzerland",
		"SY": "Syrian Arab Republic",
		"TW": "Taiwan",
		"TJ": "Tajikistan",
		"TZ": "Tanzania, United Republic of",
		"TH": "Thailand",
		"TG": "Togo",
		"TK": "Tokelau",
		"TO": "Tonga",
		"TT": "Trinidad and Tobago",
		"TN": "Tunisia",
		"TR": "Turkey",
		"TM": "Turkmenistan",
		"TC": "Turks and Caicos Islands",
		"TV": "Tuvalu",
		"VI": "Virgin Islands, U.S.",
		"UG": "Uganda",
		"UA": "Ukraine",
		"AE": "United Arab Emirates",
		"GB": "United Kingdom",
		"US": "United States",
		"UM": "United States Minor Outlying Islands",
		"UY": "Uruguay",
		"UZ": "Uzbekistan",
		"VU": "Vanuatu",
		"VA": "Holy See (Vatican City State)",
		"VE": "Venezuela, Bolivarian Republic of",
		"VN": "Viet Nam",
		"WF": "Wallis and Futuna",
		"EH": "Western Sahara",
		"YE": "Yemen",
		"ZM": "Zambia",
		"ZW": "Zimbabwe"
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	// Note: The reason to create a separate logger (instead of placing these
	// functions in util/Util) is because this is used in places like Bundles that
	// need to be loaded before Okta is defined.
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Logger) {

	  return _.extend(Logger, {

	    deprecate: function (msg) {
	      Logger.warn('[okta-signin-widget] DEPRECATED:', msg);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

	  function log(level, args) {
	    if (window.console) {
	      window.console[level].apply(window.console, args);
	    }
	  }

	  /**
	   * @class Okta.Logger
	   * See [window.console](https://developer.mozilla.org/en-US/docs/Web/API/Console)
	   */
	  return {
	    /**
	     * @static
	     * See: [console.trace](https://developer.mozilla.org/en-US/docs/Web/API/Console.trace)
	     */
	    trace: function () {
	      return log('trace', arguments);
	    },
	    /**
	     * @static
	     * See: [console.dir](https://developer.mozilla.org/en-US/docs/Web/API/Console.dir)
	     */
	    dir: function () {
	      return log('dir', arguments);
	    },
	    /**
	     * @static
	     * See: [console.time](https://developer.mozilla.org/en-US/docs/Web/API/Console.time)
	     */
	    time: function () {
	      return log('time', arguments);
	    },
	    /**
	     * @static
	     * See: [console.timeEnd](https://developer.mozilla.org/en-US/docs/Web/API/Console.timeEnd)
	     */
	    timeEnd: function () {
	      return log('timeEnd', arguments);
	    },
	    /**
	     * @static
	     * See: [console.group](https://developer.mozilla.org/en-US/docs/Web/API/Console.group)
	     */
	    group: function () {
	      return log('group', arguments);
	    },
	    /**
	     * @static
	     * See: [console.groupEnd](https://developer.mozilla.org/en-US/docs/Web/API/Console.groupEnd)
	     */
	    groupEnd: function () {
	      return log('groupEnd', arguments);
	    },
	    /**
	     * @static
	     * See: [console.assert](https://developer.mozilla.org/en-US/docs/Web/API/Console.assert)
	     */
	    assert: function () {
	      return log('assert', arguments);
	    },
	    /**
	     * @static
	     * See: [console.log](https://developer.mozilla.org/en-US/docs/Web/API/Console.log)
	     */
	    log: function () {
	      return log('log', arguments);
	    },
	    /**
	     * @static
	     * See: [console.info](https://developer.mozilla.org/en-US/docs/Web/API/Console.info)
	     */
	    info: function () {
	      return log('info', arguments);
	    },
	    /**
	     * @static
	     * See: [console.warn](https://developer.mozilla.org/en-US/docs/Web/API/Console.warn)
	     */
	    warn: function () {
	      return log('warn', arguments);
	    },
	    /**
	     * @static
	     * See: [console.error](https://developer.mozilla.org/en-US/docs/Web/API/Console.error)
	     */
	    error: function () {
	      return log('error', arguments);
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {

	  var fn = {},
	      hasFullCorsSupport = 'withCredentials' in new window.XMLHttpRequest(),
	      hasXDomainRequest = typeof XDomainRequest !== 'undefined';

	  fn.corsIsNotSupported = function () {
	    return !(hasFullCorsSupport || hasXDomainRequest);
	  };

	  fn.corsIsNotEnabled = function (jqXhr) {
	    // Not a definitive check, but it's the best we've got.
	    // Note: This will change when OktaAuth is updated
	    return jqXhr.status === 0;
	  };

	  // This is currently not being used, but we'll keep it around for when we
	  // want a fallback mechanism - i.e. use localStorage if it exists, else fall
	  // back to cookies.
	  fn.localStorageIsNotSupported = function () {
	    var test = 'test';
	    try {
	        localStorage.setItem(test, test);
	        localStorage.removeItem(test);
	        return false;
	    } catch(e) {
	        return true;
	    }
	  };

	  fn.supportsPushState = function (win) {
	    win = win || window;
	    return !!(win.history && win.history.pushState);
	  };

	  fn.isIE = function () {
	    return /(msie|trident)/i.test(navigator.userAgent);
	  };

	  fn.isFirefox = function () {
	    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	  };

	  // Returns a list of languages the user has configured for their browser, in
	  // order of preference.
	  fn.getUserLanguages = function () {
	    var languages, properties;

	    // Chrome, Firefox
	    if (navigator.languages) {
	      return navigator.languages;
	    }

	    languages = [];
	    properties = [
	      'language',         // Safari, IE11
	      'userLanguage',     // IE
	      'browserLanguage',  // IE
	      'systemLanguage'    // IE
	    ];

	    _.each(properties, function (property) {
	      if (navigator[property]) {
	        languages.push(navigator[property]);
	      }
	    });

	    return languages;
	  };

	  return fn;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 15 */
/***/ function(module, exports) {

	/*
	    json2.js
	    2012-10-08

	    Public Domain.

	    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

	    See http://www.JSON.org/js.html


	    This code should be minified before deployment.
	    See http://javascript.crockford.com/jsmin.html

	    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
	    NOT CONTROL.


	    This file creates a global JSON object containing two methods: stringify
	    and parse.

	        JSON.stringify(value, replacer, space)
	            value       any JavaScript value, usually an object or array.

	            replacer    an optional parameter that determines how object
	                        values are stringified for objects. It can be a
	                        function or an array of strings.

	            space       an optional parameter that specifies the indentation
	                        of nested structures. If it is omitted, the text will
	                        be packed without extra whitespace. If it is a number,
	                        it will specify the number of spaces to indent at each
	                        level. If it is a string (such as '\t' or '&nbsp;'),
	                        it contains the characters used to indent at each level.

	            This method produces a JSON text from a JavaScript value.

	            When an object value is found, if the object contains a toJSON
	            method, its toJSON method will be called and the result will be
	            stringified. A toJSON method does not serialize: it returns the
	            value represented by the name/value pair that should be serialized,
	            or undefined if nothing should be serialized. The toJSON method
	            will be passed the key associated with the value, and this will be
	            bound to the value

	            For example, this would serialize Dates as ISO strings.

	                Date.prototype.toJSON = function (key) {
	                    function f(n) {
	                        // Format integers to have at least two digits.
	                        return n < 10 ? '0' + n : n;
	                    }

	                    return this.getUTCFullYear()   + '-' +
	                         f(this.getUTCMonth() + 1) + '-' +
	                         f(this.getUTCDate())      + 'T' +
	                         f(this.getUTCHours())     + ':' +
	                         f(this.getUTCMinutes())   + ':' +
	                         f(this.getUTCSeconds())   + 'Z';
	                };

	            You can provide an optional replacer method. It will be passed the
	            key and value of each member, with this bound to the containing
	            object. The value that is returned from your method will be
	            serialized. If your method returns undefined, then the member will
	            be excluded from the serialization.

	            If the replacer parameter is an array of strings, then it will be
	            used to select the members to be serialized. It filters the results
	            such that only members with keys listed in the replacer array are
	            stringified.

	            Values that do not have JSON representations, such as undefined or
	            functions, will not be serialized. Such values in objects will be
	            dropped; in arrays they will be replaced with null. You can use
	            a replacer function to replace those with JSON values.
	            JSON.stringify(undefined) returns undefined.

	            The optional space parameter produces a stringification of the
	            value that is filled with line breaks and indentation to make it
	            easier to read.

	            If the space parameter is a non-empty string, then that string will
	            be used for indentation. If the space parameter is a number, then
	            the indentation will be that many spaces.

	            Example:

	            text = JSON.stringify(['e', {pluribus: 'unum'}]);
	            // text is '["e",{"pluribus":"unum"}]'


	            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
	            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

	            text = JSON.stringify([new Date()], function (key, value) {
	                return this[key] instanceof Date ?
	                    'Date(' + this[key] + ')' : value;
	            });
	            // text is '["Date(---current time---)"]'


	        JSON.parse(text, reviver)
	            This method parses a JSON text to produce an object or array.
	            It can throw a SyntaxError exception.

	            The optional reviver parameter is a function that can filter and
	            transform the results. It receives each of the keys and values,
	            and its return value is used instead of the original value.
	            If it returns what it received, then the structure is not modified.
	            If it returns undefined then the member is deleted.

	            Example:

	            // Parse the text. Values that look like ISO date strings will
	            // be converted to Date objects.

	            myData = JSON.parse(text, function (key, value) {
	                var a;
	                if (typeof value === 'string') {
	                    a =
	/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
	                    if (a) {
	                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
	                            +a[5], +a[6]));
	                    }
	                }
	                return value;
	            });

	            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
	                var d;
	                if (typeof value === 'string' &&
	                        value.slice(0, 5) === 'Date(' &&
	                        value.slice(-1) === ')') {
	                    d = new Date(value.slice(5, -1));
	                    if (d) {
	                        return d;
	                    }
	                }
	                return value;
	            });


	    This is a reference implementation. You are free to copy, modify, or
	    redistribute.
	*/

	/*jslint evil: true, regexp: true */

	/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
	    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
	    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
	    lastIndex, length, parse, prototype, push, replace, slice, stringify,
	    test, toJSON, toString, valueOf
	*/


	// Create a JSON object only if one does not already exist. We create the
	// methods in a closure to avoid creating global variables.

	if (typeof JSON !== 'object') {
	    JSON = {};
	}

	(function () {
	    'use strict';

	    function f(n) {
	        // Format integers to have at least two digits.
	        return n < 10 ? '0' + n : n;
	    }

	    if (typeof Date.prototype.toJSON !== 'function') {

	        Date.prototype.toJSON = function (key) {

	            return isFinite(this.valueOf())
	                ? this.getUTCFullYear()     + '-' +
	                    f(this.getUTCMonth() + 1) + '-' +
	                    f(this.getUTCDate())      + 'T' +
	                    f(this.getUTCHours())     + ':' +
	                    f(this.getUTCMinutes())   + ':' +
	                    f(this.getUTCSeconds())   + 'Z'
	                : null;
	        };

	        String.prototype.toJSON      =
	            Number.prototype.toJSON  =
	            Boolean.prototype.toJSON = function (key) {
	                return this.valueOf();
	            };
	    }

	    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	        gap,
	        indent,
	        meta = {    // table of character substitutions
	            '\b': '\\b',
	            '\t': '\\t',
	            '\n': '\\n',
	            '\f': '\\f',
	            '\r': '\\r',
	            '"' : '\\"',
	            '\\': '\\\\'
	        },
	        rep;


	    function quote(string) {

	// If the string contains no control characters, no quote characters, and no
	// backslash characters, then we can safely slap some quotes around it.
	// Otherwise we must also replace the offending characters with safe escape
	// sequences.

	        escapable.lastIndex = 0;
	        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	            var c = meta[a];
	            return typeof c === 'string'
	                ? c
	                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	        }) + '"' : '"' + string + '"';
	    }


	    function str(key, holder) {

	// Produce a string from holder[key].

	        var i,          // The loop counter.
	            k,          // The member key.
	            v,          // The member value.
	            length,
	            mind = gap,
	            partial,
	            value = holder[key];

	// If the value has a toJSON method, call it to obtain a replacement value.

	        if (value && typeof value === 'object' &&
	                typeof value.toJSON === 'function') {
	            value = value.toJSON(key);
	        }

	// If we were called with a replacer function, then call the replacer to
	// obtain a replacement value.

	        if (typeof rep === 'function') {
	            value = rep.call(holder, key, value);
	        }

	// What happens next depends on the value's type.

	        switch (typeof value) {
	        case 'string':
	            return quote(value);

	        case 'number':

	// JSON numbers must be finite. Encode non-finite numbers as null.

	            return isFinite(value) ? String(value) : 'null';

	        case 'boolean':
	        case 'null':

	// If the value is a boolean or null, convert it to a string. Note:
	// typeof null does not produce 'null'. The case is included here in
	// the remote chance that this gets fixed someday.

	            return String(value);

	// If the type is 'object', we might be dealing with an object or an array or
	// null.

	        case 'object':

	// Due to a specification blunder in ECMAScript, typeof null is 'object',
	// so watch out for that case.

	            if (!value) {
	                return 'null';
	            }

	// Make an array to hold the partial results of stringifying this object value.

	            gap += indent;
	            partial = [];

	// Is the value an array?

	            if (Object.prototype.toString.apply(value) === '[object Array]') {

	// The value is an array. Stringify every element. Use null as a placeholder
	// for non-JSON values.

	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }

	// Join all of the elements together, separated with commas, and wrap them in
	// brackets.

	                v = partial.length === 0
	                    ? '[]'
	                    : gap
	                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
	                    : '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }

	// If the replacer is an array, use it to select the members to be stringified.

	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    if (typeof rep[i] === 'string') {
	                        k = rep[i];
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            } else {

	// Otherwise, iterate through all of the keys in the object.

	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }

	// Join all of the member texts together, separated with commas,
	// and wrap them in braces.

	            v = partial.length === 0
	                ? '{}'
	                : gap
	                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
	                : '{' + partial.join(',') + '}';
	            gap = mind;
	            return v;
	        }
	    }

	// If the JSON object does not yet have a stringify method, give it one.

	    if (typeof JSON.stringify !== 'function') {
	        JSON.stringify = function (value, replacer, space) {

	// The stringify method takes a value and an optional replacer, and an optional
	// space parameter, and returns a JSON text. The replacer can be a function
	// that can replace values, or an array of strings that will select the keys.
	// A default replacer method can be provided. Use of the space parameter can
	// produce text that is more easily readable.

	            var i;
	            gap = '';
	            indent = '';

	// If the space parameter is a number, make an indent string containing that
	// many spaces.

	            if (typeof space === 'number') {
	                for (i = 0; i < space; i += 1) {
	                    indent += ' ';
	                }

	// If the space parameter is a string, it will be used as the indent string.

	            } else if (typeof space === 'string') {
	                indent = space;
	            }

	// If there is a replacer, it must be a function or an array.
	// Otherwise, throw an error.

	            rep = replacer;
	            if (replacer && typeof replacer !== 'function' &&
	                    (typeof replacer !== 'object' ||
	                    typeof replacer.length !== 'number')) {
	                throw new Error('JSON.stringify');
	            }

	// Make a fake root object containing our value under the key of ''.
	// Return the result of stringifying the value.

	            return str('', {'': value});
	        };
	    }


	// If the JSON object does not yet have a parse method, give it one.

	    if (typeof JSON.parse !== 'function') {
	        JSON.parse = function (text, reviver) {

	// The parse method takes a text and an optional reviver function, and returns
	// a JavaScript value if the text is a valid JSON text.

	            var j;

	            function walk(holder, key) {

	// The walk method is used to recursively walk the resulting structure so
	// that modifications can be made.

	                var k, v, value = holder[key];
	                if (value && typeof value === 'object') {
	                    for (k in value) {
	                        if (Object.prototype.hasOwnProperty.call(value, k)) {
	                            v = walk(value, k);
	                            if (v !== undefined) {
	                                value[k] = v;
	                            } else {
	                                delete value[k];
	                            }
	                        }
	                    }
	                }
	                return reviver.call(holder, key, value);
	            }


	// Parsing happens in four stages. In the first stage, we replace certain
	// Unicode characters with escape sequences. JavaScript handles many characters
	// incorrectly, either silently deleting them, or treating them as line endings.

	            text = String(text);
	            cx.lastIndex = 0;
	            if (cx.test(text)) {
	                text = text.replace(cx, function (a) {
	                    return '\\u' +
	                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	                });
	            }

	// In the second stage, we run the text against regular expressions that look
	// for non-JSON patterns. We are especially concerned with '()' and 'new'
	// because they can cause invocation, and '=' because it can cause mutation.
	// But just to be safe, we want to reject all unexpected forms.

	// We split the second stage into 4 regexp operations in order to work around
	// crippling inefficiencies in IE's and Safari's regexp engines. First we
	// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
	// replace all simple value tokens with ']' characters. Third, we delete all
	// open brackets that follow a colon or comma or that begin the text. Finally,
	// we look to see that the remaining characters are only whitespace or ']' or
	// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

	            if (/^[\],:{}\s]*$/
	                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
	                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
	                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	// In the third stage we use the eval function to compile the text into a
	// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
	// in JavaScript: it can begin a block or an object literal. We wrap the text
	// in parens to eliminate the ambiguity.

	                j = eval('(' + text + ')');

	// In the optional fourth stage, we recursively walk the new structure, passing
	// each name/value pair to a reviver function for possible transformation.

	                return typeof reviver === 'function'
	                    ? walk({'': j}, '')
	                    : j;
	            }

	// If the text is not JSON parseable, then a SyntaxError is thrown.

	            throw new SyntaxError('JSON.parse');
	        };
	    }
	}());


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	  $(function () {
	    $.ajaxSetup({
	      headers: {
	        'X-Okta-XsrfToken': $('#_xsrfToken').text()
	      },
	      converters : {
	        'text secureJSON' : function (str) {
	          if (str.substring(0, 11) === 'while(1){};') {
	            str = str.substring(11);
	          }
	          return JSON.parse(str);
	        }
	      }
	    });
	  });
	  // Selenium Hook
	  // Widget such as autocomplete and autosuggest needs to be triggered from the running version of jQuery.
	  // We have 2 versions of jQuery running in parallel and they don't share the same events bus
	  window.jQueryCourage = $;
	  return $;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var jqueryRequest = __webpack_require__(19);
	module.exports = __webpack_require__(20)(jqueryRequest);


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	var $ = __webpack_require__(6);

	function jqueryRequest(method, url, args) {
	  var deferred = $.Deferred();
	  $.ajax({
	    type: method,
	    url: url,
	    headers: args.headers,
	    data: JSON.stringify(args.data),
	    xhrFields: {
	      withCredentials: true
	    }
	  })
	  .then(function(data, textStatus, jqXHR) {
	    delete jqXHR.then;
	    deferred.resolve(jqXHR);
	  }, function(jqXHR) {
	    delete jqXHR.then;
	    deferred.reject(jqXHR);
	  });
	  return deferred;
	}

	module.exports = jqueryRequest;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	__webpack_require__(21);

	var util              = __webpack_require__(23);
	var tx                = __webpack_require__(24);
	var session           = __webpack_require__(33);
	var cookies           = __webpack_require__(26);
	var token             = __webpack_require__(34);
	var AuthSdkError      = __webpack_require__(29);
	var config            = __webpack_require__(30);
	var TokenManager      = __webpack_require__(38);

	function OktaAuthBuilder(args) {
	  var sdk = this;

	  if (!args) {
	    throw new AuthSdkError('No arguments passed to constructor. ' +
	      'Required usage: new OktaAuth(args)');
	  }

	  if (!args.url) {
	    throw new AuthSdkError('No url passed to constructor. ' +
	      'Required usage: new OktaAuth({url: "https://sample.okta.com"})');
	  }

	  this.options = {
	    url: util.removeTrailingSlash(args.url),
	    clientId: args.clientId,
	    issuer: util.removeTrailingSlash(args.issuer),
	    authorizeUrl: util.removeTrailingSlash(args.authorizeUrl),
	    userinfoUrl: util.removeTrailingSlash(args.userinfoUrl),
	    redirectUri: args.redirectUri,
	    ajaxRequest: args.ajaxRequest,
	    transformErrorXHR: args.transformErrorXHR,
	    headers: args.headers
	  };

	  // Digital clocks will drift over time, so the server
	  // can misalign with the time reported by the browser.
	  // The maxClockSkew allows relaxing the time-based
	  // validation of tokens (in seconds, not milliseconds).
	  // It currently defaults to 300, because 5 min is the
	  // default maximum tolerance allowed by Kerberos.
	  // (https://technet.microsoft.com/en-us/library/cc976357.aspx)
	  if (!args.maxClockSkew && args.maxClockSkew !== 0) {
	    this.options.maxClockSkew = config.DEFAULT_MAX_CLOCK_SKEW;
	  } else {
	    this.options.maxClockSkew = args.maxClockSkew;
	  }

	  sdk.session = {
	    close: util.bind(session.closeSession, null, sdk),
	    exists: util.bind(session.sessionExists, null, sdk),
	    get: util.bind(session.getSession, null, sdk),
	    refresh: util.bind(session.refreshSession, null, sdk),
	    setCookieAndRedirect: util.bind(session.setCookieAndRedirect, null, sdk)
	  };

	  sdk.tx = {
	    status: util.bind(tx.transactionStatus, null, sdk),
	    resume: util.bind(tx.resumeTransaction, null, sdk),
	    exists: util.bind(tx.transactionExists, null, sdk)
	  };

	  // This is exposed so we can mock document.cookie in our tests
	  sdk.tx.exists._getCookie = function(name) {
	    return cookies.getCookie(name);
	  };

	  sdk.idToken = {
	    authorize: util.deprecateWrap('Use token.getWithoutPrompt, token.getWithPopup, or token.getWithRedirect ' +
	      'instead of idToken.authorize.', util.bind(token.getToken, null, sdk)),
	    verify: util.deprecateWrap('Use token.verify instead of idToken.verify', util.bind(token.verifyIdToken, null, sdk)),
	    refresh: util.deprecateWrap('Use token.refresh instead of idToken.refresh',
	      util.bind(token.refreshIdToken, null, sdk)),
	    decode: util.deprecateWrap('Use token.decode instead of idToken.decode', token.decodeToken)
	  };

	  // This is exposed so we can mock window.location.href in our tests
	  sdk.idToken.authorize._getLocationHref = function() {
	    return window.location.href;
	  };

	  sdk.token = {
	    getWithoutPrompt: util.bind(token.getWithoutPrompt, null, sdk),
	    getWithPopup: util.bind(token.getWithPopup, null, sdk),
	    getWithRedirect: util.bind(token.getWithRedirect, null, sdk),
	    parseFromUrl: util.bind(token.parseFromUrl, null, sdk),
	    decode: token.decodeToken,
	    refresh: util.bind(token.refreshToken, null, sdk),
	    getUserInfo: util.bind(token.getUserInfo, null, sdk),
	    verify: util.bind(token.verifyToken, null, sdk)
	  };

	  // This is exposed so we can set window.location in our tests
	  sdk.token.getWithRedirect._setLocation = function(url) {
	    window.location = url;
	  };

	  // This is exposed so we can mock window.location.hash in our tests
	  sdk.token.parseFromUrl._getLocationHash = function(url) {
	    return window.location.hash;
	  };

	  sdk.tokenManager = new TokenManager(sdk, args.tokenManager);
	}

	var proto = OktaAuthBuilder.prototype;

	proto.features = {};

	proto.features.isPopupPostMessageSupported = function() {
	  var isIE8or9 = document.documentMode && document.documentMode < 10;
	  if (window.postMessage && !isIE8or9) {
	    return true;
	  }
	  return false;
	};

	proto.features.isTokenVerifySupported = function() {
	  return typeof crypto !== 'undefined' && crypto.subtle && typeof Uint8Array !== 'undefined';
	};

	// { username, password, (relayState), (context) }
	proto.signIn = function (opts) {
	  return tx.postToTransaction(this, '/api/v1/authn', opts);
	};

	proto.signOut = function () {
	  return this.session.close();
	};

	// { username, (relayState) }
	proto.forgotPassword = function (opts) {
	  return tx.postToTransaction(this, '/api/v1/authn/recovery/password', opts);
	};

	// { username, (relayState) }
	proto.unlockAccount = function (opts) {
	  return tx.postToTransaction(this, '/api/v1/authn/recovery/unlock', opts);
	};

	// { recoveryToken }
	proto.verifyRecoveryToken = function (opts) {
	  return tx.postToTransaction(this, '/api/v1/authn/recovery/token', opts);
	};

	module.exports = function(ajaxRequest) {
	  function OktaAuth(args) {
	    if (!(this instanceof OktaAuth)) {
	      return new OktaAuth(args);
	    }
	    
	    if (args && !args.ajaxRequest) {
	      args.ajaxRequest = ajaxRequest;
	    }
	    util.bind(OktaAuthBuilder, this)(args);
	  }
	  OktaAuth.prototype = OktaAuthBuilder.prototype;
	  OktaAuth.prototype.constructor = OktaAuth;

	  return OktaAuth;
	};


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	__webpack_require__(22);

	// Production steps of ECMA-262, Edition 5, 15.4.4.14
	// Reference: http://es5.github.io/#x15.4.4.14
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
	if (!Array.prototype.indexOf) {
	  Array.prototype.indexOf = function(searchElement, fromIndex) {

	    var k;

	    // 1. Let o be the result of calling ToObject passing
	    //    the this value as the argument.
	    if (this == null) {
	      throw new TypeError('"this" is null or not defined');
	    }

	    var o = Object(this);

	    // 2. Let lenValue be the result of calling the Get
	    //    internal method of o with the argument "length".
	    // 3. Let len be ToUint32(lenValue).
	    var len = o.length >>> 0;

	    // 4. If len is 0, return -1.
	    if (len === 0) {
	      return -1;
	    }

	    // 5. If argument fromIndex was passed let n be
	    //    ToInteger(fromIndex); else let n be 0.
	    var n = +fromIndex || 0;

	    if (Math.abs(n) === Infinity) {
	      n = 0;
	    }

	    // 6. If n >= len, return -1.
	    if (n >= len) {
	      return -1;
	    }

	    // 7. If n >= 0, then Let k be n.
	    // 8. Else, n<0, Let k be len - abs(n).
	    //    If k is less than 0, then let k be 0.
	    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

	    // 9. Repeat, while k < len
	    while (k < len) {
	      // a. Let Pk be ToString(k).
	      //   This is implicit for LHS operands of the in operator
	      // b. Let kPresent be the result of calling the
	      //    HasProperty internal method of o with argument Pk.
	      //   This step can be combined with c
	      // c. If kPresent is true, then
	      //    i.  Let elementK be the result of calling the Get
	      //        internal method of o with the argument ToString(k).
	      //   ii.  Let same be the result of applying the
	      //        Strict Equality Comparison Algorithm to
	      //        searchElement and elementK.
	      //  iii.  If same is true, return k.
	      if (k in o && o[k] === searchElement) {
	        return k;
	      }
	      k++;
	    }
	    return -1;
	  };
	}

	if (!Array.isArray) {
	  Array.isArray = function(obj) {
	    return Object.prototype.toString.call(obj) === '[object Array]';
	  };
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {

	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    var str = String(input);
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next str index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      str.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = str.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });

	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    var str = String(input).replace(/=+$/, '');
	    if (str.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = str.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });

	}());


/***/ },
/* 23 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */
	/* eslint-env es6 */
	var util = module.exports;

	util.base64UrlToBase64 = function(b64u) {
	  return b64u.replace(/\-/g, '+').replace(/_/g, '/');
	};

	util.base64UrlToString = function(b64u) {
	  var b64 = util.base64UrlToBase64(b64u);
	  switch (b64.length % 4) {
	    case 0:
	      break;
	    case 2:
	      b64 += '==';
	      break;
	    case 3:
	      b64 += '=';
	      break;
	    default:
	      throw 'Not a valid Base64Url';
	  }
	  var utf8 = atob(b64);
	  try {
	    return decodeURIComponent(escape(utf8));
	  } catch (e) {
	    return utf8;
	  }
	};

	util.stringToBuffer = function(str) {
	  var buffer = new Uint8Array(str.length);
	  for (var i = 0; i < str.length; i++) {
	    buffer[i] = str.charCodeAt(i);
	  }
	  return buffer;
	};

	util.base64UrlDecode = function(str) {
	  return atob(util.base64UrlToBase64(str));
	};

	util.bind = function(fn, ctx) {
	  var additionalArgs = Array.prototype.slice.call(arguments, 2);
	  return function() {
	    var args = Array.prototype.slice.call(arguments);
	    args = additionalArgs.concat(args);
	    return fn.apply(ctx, args);
	  };
	};

	util.isAbsoluteUrl = function(url) {
	  return /^(?:[a-z]+:)?\/\//i.test(url);
	};

	util.isString = function(obj) {
	  return Object.prototype.toString.call(obj) === '[object String]';
	};

	util.isObject = function(obj) {
	  return Object.prototype.toString.call(obj) === '[object Object]';
	};

	util.isNumber = function(obj) {
	  return Object.prototype.toString.call(obj) === '[object Number]';
	};

	util.isArray = function(obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
	};

	util.isoToUTCString = function(str) {
	  var parts = str.match(/\d+/g),
	      isoTime = Date.UTC(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]),
	      isoDate = new Date(isoTime);

	  return isoDate.toUTCString();
	};

	util.toQueryParams = function(obj) {
	  var str = [];
	  if (obj !== null) {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key) &&
	          obj[key] !== undefined &&
	          obj[key] !== null) {
	        str.push(key + '=' + encodeURIComponent(obj[key]));
	      }
	    }
	  }
	  if (str.length) {
	    return '?' + str.join('&');
	  } else {
	    return '';
	  }
	};

	util.genRandomString = function(length) {
	  var randomCharset = 'abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
	  var random = '';
	  for (var c = 0, cl = randomCharset.length; c < length; ++c) {
	    random += randomCharset[Math.floor(Math.random() * cl)];
	  }
	  return random;
	};

	util.extend = function(obj1, obj2) {
	  for (var prop in obj2) {
	    if (obj2.hasOwnProperty(prop)) {
	      obj1[prop] = obj2[prop];
	    }
	  }
	};

	util.removeNils = function(obj) {
	  var cleaned = {};
	  for (var prop in obj) {
	    if (obj.hasOwnProperty(prop)) {
	      var value = obj[prop];
	      if (value !== null && value !== undefined) {
	        cleaned[prop] = value;
	      }
	    }
	  }
	  return cleaned;
	};

	util.clone = function(obj) {
	  if (obj) {
	    var str = JSON.stringify(obj);
	    if (str) {
	      return JSON.parse(str);
	    }
	  }
	  return obj;
	};

	// Analogous to _.omit
	util.omit = function(obj) {
	  var props = Array.prototype.slice.call(arguments, 1);
	  var newobj = {};
	  for (var p in obj) {
	    if (obj.hasOwnProperty(p) && props.indexOf(p) == -1) {
	      newobj[p] = obj[p];
	    }
	  }
	  return util.clone(newobj);
	};

	util.find = function(collection, searchParams) {
	  var c = collection.length;
	  while (c--) {
	    var item = collection[c];
	    var found = true;
	    for (var prop in searchParams) {
	      if (!searchParams.hasOwnProperty(prop)) {
	        continue;
	      }
	      if (item[prop] !== searchParams[prop]) {
	        found = false;
	        break;
	      }
	    }
	    if (found) {
	      return item;
	    }
	  }
	};

	util.getLink = function(obj, linkName, altName) {
	  if (!obj || !obj._links) {
	    return;
	  }
	  
	  var link = util.clone(obj._links[linkName]);

	  // If a link has a name and we have an altName, return if they match
	  if (link && link.name && altName) {
	    if (link.name === altName) {
	      return link;
	    }
	  } else {
	    return link;
	  }
	};

	util.getNativeConsole = function() {
	  return window.console;
	};

	util.getConsole = function() {
	  var nativeConsole = util.getNativeConsole();
	  if (nativeConsole && nativeConsole.log) {
	    return nativeConsole;
	  }
	  return {
	    log: function() {}
	  };
	};

	util.warn = function(text) {
	  /* eslint-disable no-console */
	  util.getConsole().log('[okta-auth-sdk] WARN: ' + text);
	  /* eslint-enable */
	};

	util.deprecate = function(text) {
	  /* eslint-disable no-console */
	  util.getConsole().log('[okta-auth-sdk] DEPRECATION: ' + text);
	  /* eslint-enable */
	};

	util.deprecateWrap = function(text, fn) {
	  return function() {
	    util.deprecate(text);
	    return fn.apply(null, arguments);
	  };
	};

	util.removeTrailingSlash = function(path) {
	  if (!path) {
	    return;
	  }
	  if (path.slice(-1) === '/') {
	    return path.slice(0, -1);
	  }
	  return path;
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable complexity */
	var http              = __webpack_require__(25);
	var util              = __webpack_require__(23);
	var Q                 = __webpack_require__(9);
	var AuthSdkError      = __webpack_require__(29);
	var AuthPollStopError = __webpack_require__(32);
	var config            = __webpack_require__(30);

	function addStateToken(res, options) {
	  var builtArgs = util.clone(options) || {};

	  // Add the stateToken if one isn't passed and we have one
	  if (!builtArgs.stateToken && res.stateToken) {
	    builtArgs.stateToken = res.stateToken;
	  }

	  return builtArgs;
	}

	function getStateToken(res) {
	  return addStateToken(res);
	}

	function transactionStatus(sdk, args) {
	  args = addStateToken(sdk, args);
	  return http.post(sdk, sdk.options.url + '/api/v1/authn', args);
	}

	function resumeTransaction(sdk, args) {
	  if (!args || !args.stateToken) {
	    var stateToken = sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);
	    if (stateToken) {
	      args = {
	        stateToken: stateToken
	      };
	    } else {
	      return Q.reject(new AuthSdkError('No transaction to resume'));
	    }
	  }
	  return sdk.tx.status(args)
	    .then(function(res) {
	      return new AuthTransaction(sdk, res);
	    });
	}

	function transactionExists(sdk) {
	  // We have a cookie state token
	  return !!sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);
	}

	function postToTransaction(sdk, url, options) {
	  return http.post(sdk, url, options)
	    .then(function(res) {
	      return new AuthTransaction(sdk, res);
	    });
	}

	function getPollFn(sdk, res, ref) {
	  return function (options) {
	    var delay;
	    var rememberDevice;

	    if (util.isNumber(options)) {
	      delay = options;
	    } else if (util.isObject(options)) {
	      delay = options.delay;
	      rememberDevice = options.rememberDevice;
	    }

	    if (!delay && delay !== 0) {
	      delay = config.DEFAULT_POLLING_DELAY;
	    }

	    // Get the poll function
	    var pollLink = util.getLink(res, 'next', 'poll');
	    function pollFn() {
	      var href = pollLink.href;
	      if (rememberDevice) {
	        href += '?rememberDevice=true';
	      }
	      return http.post(sdk, href, getStateToken(res), {
	        saveAuthnState: false  
	      });
	    }

	    ref.isPolling = true;

	    var retryCount = 0;
	    var recursivePoll = function () {

	      // If the poll was manually stopped during the delay
	      if (!ref.isPolling) {
	        return Q.reject(new AuthPollStopError());
	      }

	      return pollFn()
	        .then(function (pollRes) {
	          // Reset our retry counter on success
	          retryCount = 0;

	          // If we're still waiting
	          if (pollRes.factorResult && pollRes.factorResult === 'WAITING') {

	            // If the poll was manually stopped while the pollFn was called
	            if (!ref.isPolling) {
	              throw new AuthPollStopError();
	            }

	            // Continue poll
	            return Q.delay(delay)
	              .then(recursivePoll);

	          } else {
	            // Any non-waiting result, even if polling was stopped
	            // during a request, will return
	            ref.isPolling = false;
	            return new AuthTransaction(sdk, pollRes);
	          }
	        })
	        .fail(function(err) {
	          // Exponential backoff, up to 16 seconds
	          if (err.xhr &&
	              (err.xhr.status === 0 || err.xhr.status === 429) &&
	              retryCount <= 4) {
	            var delayLength = Math.pow(2, retryCount) * 1000;
	            retryCount++;
	            return Q.delay(delayLength)
	              .then(recursivePoll);
	          }
	          throw err;
	        });
	    };
	    return recursivePoll()
	      .fail(function(err) {
	        ref.isPolling = false;
	        throw err;
	      });
	  };
	}

	function link2fn(sdk, res, obj, link, ref) {
	  if (Array.isArray(link)) {
	    return function(name, opts) {
	      if (!name) {
	        throw new AuthSdkError('Must provide a link name');
	      }

	      var lk = util.find(link, {name: name});
	      if (!lk) {
	        throw new AuthSdkError('No link found for that name');
	      }

	      return link2fn(sdk, res, obj, lk, ref)(opts);
	    };

	  } else if (link.hints &&
	      link.hints.allow &&
	      link.hints.allow.length === 1) {
	    var method = link.hints.allow[0];
	    switch (method) {

	      case 'GET':
	        return function() {
	          return http.get(sdk, link.href);
	        };

	      case 'POST':
	        return function(opts) {
	          if (ref && ref.isPolling) {
	            ref.isPolling = false;
	          }

	          var data = addStateToken(res, opts);

	          if (res.status === 'MFA_ENROLL') {
	            // Add factorType and provider
	            util.extend(data, {
	              factorType: obj.factorType,
	              provider: obj.provider
	            });
	          }

	          var href = link.href;
	          if (data.rememberDevice !== undefined) {
	            if (data.rememberDevice) {
	              href += '?rememberDevice=true';
	            }
	            data = util.omit(data, 'rememberDevice');

	          } else if (data.profile &&
	                    data.profile.updatePhone !== undefined) {
	            if (data.profile.updatePhone) {
	              href += '?updatePhone=true';
	            }
	            data.profile = util.omit(data.profile, 'updatePhone');
	          }

	          return postToTransaction(sdk, href, data);
	        };
	    }
	  }
	}

	function links2fns(sdk, res, obj, ref) {
	  var fns = {};
	  for (var linkName in obj._links) {
	    if (!obj._links.hasOwnProperty(linkName)) {
	      continue;
	    }

	    var link = obj._links[linkName];
	    
	    if (linkName === 'next') {
	      linkName = link.name;
	    }

	    if (link.type) {
	      fns[linkName] = link;
	      continue;
	    }

	    switch (linkName) {
	      // poll is only found at the transaction
	      // level, so we don't need to pass the link
	      case 'poll':
	        fns.poll = getPollFn(sdk, res, ref);
	        break;

	      default:
	        var fn = link2fn(sdk, res, obj, link, ref);
	        if (fn) {
	          fns[linkName] = fn;
	        }
	    }
	  }
	  return fns;
	}

	function flattenEmbedded(sdk, res, obj, ref) {
	  obj = obj || res;
	  obj = util.clone(obj);

	  if (Array.isArray(obj)) {
	    var objArr = [];
	    for (var o = 0, ol = obj.length; o < ol; o++) {
	      objArr.push(flattenEmbedded(sdk, res, obj[o], ref));
	    }
	    return objArr;
	  }

	  var embedded = obj._embedded || {};

	  for (var key in embedded) {
	    if (!embedded.hasOwnProperty(key)) {
	      continue;
	    }

	    // Flatten any nested _embedded objects
	    if (util.isObject(embedded[key]) || Array.isArray(embedded[key])) {
	      embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);
	    }
	  }

	  // Convert any links on the embedded object
	  var fns = links2fns(sdk, res, obj, ref);
	  util.extend(embedded, fns);

	  obj = util.omit(obj, '_embedded', '_links');
	  util.extend(obj, embedded);
	  return obj;
	}

	function AuthTransaction(sdk, res) {
	  if (res) {
	    this.data = res;
	    util.extend(this, flattenEmbedded(sdk, res, res, {}));
	    delete this.stateToken;

	    // RECOVERY_CHALLENGE has some responses without _links.
	    // Without _links, we emulate cancel to make it intuitive
	    // to return to the starting state. We may remove this
	    // when OKTA-75434 is resolved
	    if (res.status === 'RECOVERY_CHALLENGE' && !res._links) {
	      this.cancel = function() {
	        return new Q(new AuthTransaction(sdk));
	      };
	    }
	  }
	}

	module.exports = {
	  transactionStatus: transactionStatus,
	  resumeTransaction: resumeTransaction,
	  transactionExists: transactionExists,
	  postToTransaction: postToTransaction
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable complexity */
	var util = __webpack_require__(23);
	var cookies = __webpack_require__(26);
	var storageUtil = __webpack_require__(27);
	var Q = __webpack_require__(9);
	var AuthApiError = __webpack_require__(31);
	var config = __webpack_require__(30);

	function httpRequest(sdk, options) {
	  options = options || {};
	  var url = options.url,
	      method = options.method,
	      args = options.args,
	      saveAuthnState = options.saveAuthnState,
	      accessToken = options.accessToken,
	      httpCache = storageUtil.getHttpCache();

	  if (options.cacheResponse) {
	    var cacheContents = httpCache.getStorage();
	    var cachedResponse = cacheContents[url];
	    if (cachedResponse && Date.now()/1000 < cachedResponse.expiresAt) {
	      return Q.resolve(cachedResponse.response);
	    }
	  }

	  var headers = {
	    'Accept': 'application/json',
	    'Content-Type': 'application/json',
	    'X-Okta-User-Agent-Extended': 'okta-auth-js-' + config.SDK_VERSION
	  };
	  util.extend(headers, sdk.options.headers || {});

	  if (accessToken && util.isString(accessToken)) {
	    headers['Authorization'] = 'Bearer ' + accessToken;
	  }

	  var ajaxOptions = {
	    headers: headers,
	    data: args || undefined
	  };

	  var err, res;
	  return new Q(sdk.options.ajaxRequest(method, url, ajaxOptions))
	    .then(function(resp) {
	      res = resp.responseText;
	      if (res && util.isString(res)) {
	        res = JSON.parse(res);
	      }

	      if (saveAuthnState) {
	        if (!res.stateToken) {
	          cookies.deleteCookie(config.STATE_TOKEN_COOKIE_NAME);
	        }
	      }

	      if (res && res.stateToken && res.expiresAt) {
	        cookies.setCookie(config.STATE_TOKEN_COOKIE_NAME, res.stateToken, res.expiresAt);
	      }

	      if (res && options.cacheResponse) {
	        httpCache.updateStorage(url, {
	          expiresAt: Math.floor(Date.now()/1000) + config.DEFAULT_CACHE_DURATION,
	          response: res
	        });
	      }

	      return res;
	    })
	    .fail(function(resp) { 
	      var serverErr = resp.responseText || {};
	      if (util.isString(serverErr)) {
	        try {
	          serverErr = JSON.parse(serverErr);
	        } catch (e) {
	          serverErr = {
	            errorSummary: 'Unknown error'
	          };
	        }
	      }

	      if (resp.status >= 500) {
	        serverErr.errorSummary = 'Unknown error';
	      }

	      if (sdk.options.transformErrorXHR) {
	        resp = sdk.options.transformErrorXHR(util.clone(resp));
	      }

	      err = new AuthApiError(serverErr, resp);

	      if (err.errorCode === 'E0000011') {
	        cookies.deleteCookie(config.STATE_TOKEN_COOKIE_NAME);
	      }

	      throw err;
	    });
	}

	function get(sdk, url, options) {
	  url = util.isAbsoluteUrl(url) ? url : sdk.options.url + url;
	  var getOptions = {
	    url: url,
	    method: 'GET'
	  };
	  util.extend(getOptions, options);
	  return httpRequest(sdk, getOptions);
	}

	function post(sdk, url, args, options) {
	  url = util.isAbsoluteUrl(url) ? url : sdk.options.url + url;
	  var postOptions = {
	    url: url,
	    method: 'POST',
	    args: args,
	    saveAuthnState: true
	  };
	  util.extend(postOptions, options);
	  return httpRequest(sdk, postOptions);
	}

	module.exports = {
	  get: get,
	  post: post,
	  httpRequest: httpRequest
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(23);

	function setCookie(name, value, expiresAt) {
	  var expiresText = '';
	  if (expiresAt) {
	    expiresText = ' expires=' + util.isoToUTCString(expiresAt) + ';';
	  }

	  var cookieText = name + '=' + value + '; path=/;' + expiresText;
	  setCookie._setDocumentCookie(cookieText);

	  return cookieText;
	}

	// Exposed for testing
	setCookie._setDocumentCookie = function(cookieText) {
	  document.cookie = cookieText;
	};

	function getCookie(name) {
	  var pattern = new RegExp(name + '=([^;]*)'),
	      matched = getCookie._getDocumentCookie().match(pattern);

	  if (matched) {
	    var cookie = matched[1];
	    return cookie;
	  }
	}

	// Exposed for testing
	getCookie._getDocumentCookie = function() {
	  return document.cookie;
	};

	function deleteCookie(name) {
	  setCookie(name, '', '1970-01-01T00:00:00Z');
	}

	module.exports = {
	  setCookie: setCookie,
	  getCookie: getCookie,
	  deleteCookie: deleteCookie
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var cookies = __webpack_require__(26);
	var storageBuilder = __webpack_require__(28);
	var config = __webpack_require__(30);

	// Building this as an object allows us to mock the functions in our tests
	var storageUtil = {};

	// IE11 bug that Microsoft doesn't plan to fix
	// https://connect.microsoft.com/IE/Feedback/Details/1496040
	storageUtil.browserHasLocalStorage = function() {
	  try {
	    if (storageUtil.getLocalStorage()) {
	      return true;
	    } else {
	      return false;
	    }
	  } catch (e) {
	    return false;
	  }
	};

	storageUtil.browserHasSessionStorage = function() {
	  try {
	    if (storageUtil.getSessionStorage()) {
	      return true;
	    } else {
	      return false;
	    }
	  } catch (e) {
	    return false;
	  }
	};

	storageUtil.getHttpCache = function() {
	  if (storageUtil.browserHasLocalStorage()) {
	    return storageBuilder(storageUtil.getLocalStorage(), config.CACHE_STORAGE_NAME);
	  } else if (storageUtil.browserHasSessionStorage()) {
	    return storageBuilder(storageUtil.getSessionStorage(), config.CACHE_STORAGE_NAME);
	  } else {
	    return storageBuilder(storageUtil.getCookieStorage(), config.CACHE_STORAGE_NAME);
	  }
	};

	storageUtil.getLocalStorage = function() {
	  return localStorage;
	};

	storageUtil.getSessionStorage = function() {
	  return sessionStorage;
	};

	// Provides webStorage-like interface for cookies
	storageUtil.getCookieStorage = function() {
	  return {
	    getItem: cookies.getCookie,
	    setItem: function(key, value) {
	      // Cookie shouldn't expire
	      cookies.setCookie(key, value, '2038-01-19T03:14:07.000Z');
	    }
	  };
	};

	module.exports = storageUtil;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var AuthSdkError = __webpack_require__(29);

	// storage must have getItem and setItem
	function storageBuilder(webstorage, storageName) {
	  function getStorage() {
	    var storageString = webstorage.getItem(storageName);
	    storageString = storageString || '{}';
	    try {
	      return JSON.parse(storageString);
	    } catch(e) {
	      throw new AuthSdkError('Unable to parse storage string: ' + storageName);
	    }
	  }

	  function setStorage(storage) {
	    try {
	      var storageString = JSON.stringify(storage);
	      webstorage.setItem(storageName, storageString);
	    } catch(e) {
	      throw new AuthSdkError('Unable to set storage: ' + storageName);
	    }
	  }

	  function clearStorage(key) {
	    if (!key) {
	      setStorage({});
	    }
	    var storage = getStorage();
	    delete storage[key];
	    setStorage(storage);
	  }

	  function updateStorage(key, value) {
	    var storage = getStorage();
	    storage[key] = value;
	    setStorage(storage);
	  }

	  return {
	    getStorage: getStorage,
	    setStorage: setStorage,
	    clearStorage: clearStorage,
	    updateStorage: updateStorage
	  };
	}

	module.exports = storageBuilder;


/***/ },
/* 29 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	function AuthSdkError(msg, xhr) {
	  this.name = 'AuthSdkError';
	  this.message = msg;

	  this.errorCode = 'INTERNAL';
	  this.errorSummary = msg;
	  this.errorLink = 'INTERNAL';
	  this.errorId = 'INTERNAL';
	  this.errorCauses = [];
	  if (xhr) {
	    this.xhr = xhr;
	  }
	}
	AuthSdkError.prototype = new Error();

	module.exports = AuthSdkError;


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = {
	  "STATE_TOKEN_COOKIE_NAME": "oktaStateToken",
	  "DEFAULT_POLLING_DELAY": 500,
	  "DEFAULT_MAX_CLOCK_SKEW": 300,
	  "DEFAULT_CACHE_DURATION": 86400,
	  "FRAME_ID": "okta-oauth-helper-frame",
	  "REDIRECT_OAUTH_PARAMS_COOKIE_NAME": "okta-oauth-redirect-params",
	  "REDIRECT_STATE_COOKIE_NAME": "okta-oauth-state",
	  "REDIRECT_NONCE_COOKIE_NAME": "okta-oauth-nonce",
	  "TOKEN_STORAGE_NAME": "okta-token-storage",
	  "CACHE_STORAGE_NAME": "okta-cache-storage",
	  "SDK_VERSION": "1.8.0"
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	function AuthApiError(err, xhr) {
	  this.name = 'AuthApiError';
	  this.message = err.errorSummary;
	  this.errorSummary = err.errorSummary;
	  this.errorCode = err.errorCode;
	  this.errorLink = err.errorLink;
	  this.errorId = err.errorId;
	  this.errorCauses = err.errorCauses;

	  if (xhr) {
	    this.xhr = xhr;
	  }
	}
	AuthApiError.prototype = new Error();

	module.exports = AuthApiError;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	function AuthPollStopError() {
	  this.name = 'AuthPollStopError';
	  this.message = 'The poll was stopped by the sdk';
	}
	AuthPollStopError.prototype = new Error();

	module.exports = AuthPollStopError;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(23);
	var http = __webpack_require__(25);

	function sessionExists(sdk) {
	  return sdk.session.get()
	    .then(function(res) {
	      if (res.status === 'ACTIVE') {
	        return true;
	      }
	      return false;
	    })
	    .fail(function() {
	      return false;
	    });
	}

	function getSession(sdk) { 
	  return http.get(sdk, '/api/v1/sessions/me')
	  .then(function(session) {
	    var res = util.omit(session, '_links');

	    res.refresh = function() {
	      return http.post(sdk, util.getLink(session, 'refresh').href);
	    };

	    res.user = function() {
	      return http.get(sdk, util.getLink(session, 'user').href);
	    };

	    return res;
	  })
	  .fail(function() {
	    // Return INACTIVE status on failure
	    return {status: 'INACTIVE'};
	  });
	}

	function closeSession(sdk) {
	  return http.httpRequest(sdk, {
	    url: sdk.options.url + '/api/v1/sessions/me',
	    method: 'DELETE'
	  });
	}

	function refreshSession(sdk) {
	  return http.post(sdk, '/api/v1/sessions/me/lifecycle/refresh');
	}

	function setCookieAndRedirect(sdk, sessionToken, redirectUrl) {
	  redirectUrl = redirectUrl || window.location.href;
	  window.location = sdk.options.url + '/login/sessionCookieRedirect' +
	    util.toQueryParams({
	      checkAccountSetupComplete: true,
	      token: sessionToken,
	      redirectUrl: redirectUrl
	    });
	}

	module.exports = {
	  sessionExists: sessionExists,
	  getSession: getSession,
	  closeSession: closeSession,
	  refreshSession: refreshSession,
	  setCookieAndRedirect: setCookieAndRedirect
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable complexity, max-statements */
	var http          = __webpack_require__(25);
	var util          = __webpack_require__(23);
	var oauthUtil     = __webpack_require__(35);
	var Q             = __webpack_require__(9);
	var sdkCrypto     = __webpack_require__(36);
	var AuthSdkError  = __webpack_require__(29);
	var OAuthError    = __webpack_require__(37);
	var config        = __webpack_require__(30);
	var cookies       = __webpack_require__(26);

	function decodeToken(token) {
	  var jwt = token.split('.');
	  var decodedToken;

	  try {
	    decodedToken = {
	      header: JSON.parse(util.base64UrlToString(jwt[0])),
	      payload: JSON.parse(util.base64UrlToString(jwt[1])),
	      signature: jwt[2]
	    };
	  } catch(e) {
	    throw new AuthSdkError('Malformed token');
	  }

	  return decodedToken;
	}

	function verifyIdToken(sdk, idToken, options) {
	  options = options || {};

	  if (!sdk.features.isTokenVerifySupported()) {
	    return Q.reject(new AuthSdkError('This browser doesn\'t support crypto.subtle'));
	  }

	  function isExpired(jwtExp) {
	    var expirationTime;
	    if (options.expirationTime || options.expirationTime === 0) {
	      expirationTime = options.expirationTime;
	    } else {
	      expirationTime = Math.floor(Date.now()/1000);
	    }
	    if (jwtExp &&
	        jwtExp > expirationTime) {
	      return true;
	    }
	  }

	  function hasAudience(jwtAudience) {
	    if (!options.audience) {
	      return true;
	    }
	    var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
	    var jwtAudiences = Array.isArray(jwtAudience) ? jwtAudience : [jwtAudience];
	    var ai = audiences.length;
	    while (ai--) {
	      var aud = audiences[ai];
	      if (jwtAudiences.indexOf(aud) !== -1) {
	        return true;
	      }
	    }
	  }

	  return oauthUtil.getWellKnown(sdk)
	    .then(function(res) {
	      return http.get(sdk, res['jwks_uri']);
	    })
	    .then(function(res) {
	      var key = res.keys[0];
	      return sdkCrypto.verifyToken(idToken, key);
	    })
	    .then(function(res) {
	      if (!res) {
	        return false;
	      }
	      var jwt = sdk.token.decode(idToken);

	      if (isExpired(jwt.payload.exp)) {
	        return false;
	      }

	      if (!hasAudience(jwt.payload.aud)) {
	        return false;
	      }

	      if (options.issuer &&
	          options.issuer !== jwt.payload.iss) {
	        return false;
	      }

	      return true;
	    });
	}

	function verifyToken(sdk, token, nonce, ignoreSignature) {
	  return new Q()
	  .then(function() {
	    if (!token || !token.idToken) {
	      throw new AuthSdkError('Only idTokens may be verified');
	    }

	    var jwt = decodeToken(token.idToken);

	    // Standard claim validation
	    oauthUtil.validateClaims(sdk, jwt.payload, token.clientId, token.issuer, nonce);

	    // If the browser doesn't support native crypto or we choose not 
	    // to verify the signature, bail early
	    if (ignoreSignature || !sdk.features.isTokenVerifySupported()) {
	      return token;
	    }

	    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid)
	    .then(function(key) {
	      return sdkCrypto.verifyToken(token.idToken, key);
	    })
	    .then(function(valid) {
	      if (!valid) {
	        throw new AuthSdkError('The token signature is not valid');
	      }
	      return token;
	    });
	  });
	}

	function refreshIdToken(sdk, options) {
	  options = options || {};
	  options.display = null;
	  options.prompt = 'none';
	  return getToken(sdk, options);
	}

	function addPostMessageListener(sdk, timeout, state) {
	  var deferred = Q.defer();

	  function responseHandler(e) {
	    if (!e.data ||
	        e.origin !== sdk.options.url ||
	        (e.data && util.isString(state) && e.data.state !== state)) {
	      return;
	    }
	    deferred.resolve(e.data);
	  }

	  oauthUtil.addListener(window, 'message', responseHandler);

	  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'))
	    .fin(function() {
	      oauthUtil.removeListener(window, 'message', responseHandler);
	    });
	}

	function addFragmentListener(sdk, windowEl, timeout) {
	  var deferred = Q.defer();

	  function hashChangeHandler() {
	    /*
	      We are only able to access window.location.hash on a window
	      that has the same domain. A try/catch is necessary because
	      there's no other way to determine that the popup is in
	      another domain. When we try to access a window on another 
	      domain, an error is thrown.
	    */
	    try {
	      if (windowEl &&
	          windowEl.location &&
	          windowEl.location.hash) {
	        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));
	      } else if (windowEl && !windowEl.closed) {
	        setTimeout(hashChangeHandler, 500);
	      }
	    } catch (err) {
	      setTimeout(hashChangeHandler, 500);
	    }
	  }

	  hashChangeHandler();

	  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));
	}

	function handleOAuthResponse(sdk, oauthParams, res, urls) {
	  urls = urls || {};

	  var tokenTypes = oauthParams.responseType;
	  var scopes = util.clone(oauthParams.scopes);
	  var clientId = oauthParams.clientId || sdk.options.clientId;

	  return new Q()
	  .then(function() {
	    if (res['error'] || res['error_description']) {
	      throw new OAuthError(res['error'], res['error_description']);
	    }

	    if (res.state !== oauthParams.state) {
	      throw new AuthSdkError('OAuth flow response state doesn\'t match request state');
	    }

	    var tokenDict = {};
	    
	    if (res['access_token']) {
	      tokenDict['token'] = {
	        accessToken: res['access_token'],
	        expiresAt: Number(res['expires_in']) + Math.floor(Date.now()/1000),
	        tokenType: res['token_type'],
	        scopes: scopes,
	        authorizeUrl: urls.authorizeUrl,
	        userinfoUrl: urls.userinfoUrl
	      };
	    }

	    if (res['code']) {
	      tokenDict['code'] = {
	        authorizationCode: res['code']
	      };
	    }

	    if (res['id_token']) {
	      var jwt = sdk.token.decode(res['id_token']);

	      var idToken = {
	        idToken: res['id_token'],
	        claims: jwt.payload,
	        expiresAt: jwt.payload.exp,
	        scopes: scopes,
	        authorizeUrl: urls.authorizeUrl,
	        issuer: urls.issuer,
	        clientId: clientId
	      };

	      return verifyToken(sdk, idToken, oauthParams.nonce, true)
	      .then(function(token) {
	        tokenDict['id_token'] = idToken;
	        return tokenDict;
	      });
	    }

	    return tokenDict;
	  })
	  .then(function(tokenDict) {
	    if (!Array.isArray(tokenTypes)) {
	      return tokenDict[tokenTypes];
	    }

	    if (!tokenDict['token'] && !tokenDict['id_token']) {
	      throw new AuthSdkError('Unable to parse OAuth flow response');
	    }

	    // Create token array in the order of the responseType array
	    return tokenTypes.map(function(item) {
	      return tokenDict[item];
	    });
	  });
	}

	function getDefaultOAuthParams(sdk, oauthOptions) {
	  oauthOptions = util.clone(oauthOptions) || {};

	  if (oauthOptions.scope) {
	    util.deprecate('The param "scope" is equivalent to "scopes". Use "scopes" instead.');
	    oauthOptions.scopes = oauthOptions.scope;
	    delete oauthOptions.scope;
	  }

	  var defaults = {
	    clientId: sdk.options.clientId,
	    redirectUri: sdk.options.redirectUri || window.location.href,
	    responseType: 'id_token',
	    responseMode: 'okta_post_message',
	    state: util.genRandomString(64),
	    nonce: util.genRandomString(64),
	    scopes: ['openid', 'email']
	  };
	  util.extend(defaults, oauthOptions);
	  return defaults;
	}

	function convertOAuthParamsToQueryParams(oauthParams) {
	  // Quick validation
	  if (!oauthParams.clientId) {
	    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');
	  }

	  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {
	    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');
	  }

	  // Convert our params to their actual OAuth equivalents
	  var oauthQueryParams = util.removeNils({
	    'client_id': oauthParams.clientId,
	    'redirect_uri': oauthParams.redirectUri,
	    'response_type': oauthParams.responseType,
	    'response_mode': oauthParams.responseMode,
	    'state': oauthParams.state,
	    'nonce': oauthParams.nonce,
	    'prompt': oauthParams.prompt,
	    'display': oauthParams.display,
	    'sessionToken': oauthParams.sessionToken,
	    'idp': oauthParams.idp,
	    'max_age': oauthParams.maxAge
	  });

	  if (Array.isArray(oauthQueryParams['response_type'])) {
	    oauthQueryParams['response_type'] = oauthQueryParams['response_type'].join(' ');
	  }

	  if (oauthParams.responseType.indexOf('id_token') !== -1 &&
	      oauthParams.scopes.indexOf('openid') === -1) {
	    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');
	  } else {
	    oauthQueryParams.scope = oauthParams.scopes.join(' ');
	  }

	  return oauthQueryParams;
	}

	function buildAuthorizeParams(oauthParams) {
	  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);
	  return util.toQueryParams(oauthQueryParams);
	}

	/*
	 * Retrieve an idToken from an Okta or a third party idp
	 * 
	 * Two main flows:
	 *
	 *  1) Exchange a sessionToken for a token
	 * 
	 *    Required:
	 *      clientId: passed via the OktaAuth constructor or into getToken
	 *      sessionToken: 'yourtoken'
	 *
	 *    Optional:
	 *      redirectUri: defaults to window.location.href
	 *      scopes: defaults to ['openid', 'email']
	 *
	 *    Forced:
	 *      prompt: 'none'
	 *      responseMode: 'okta_post_message'
	 *      display: undefined
	 *
	 *  2) Get a token from an idp
	 *
	 *    Required:
	 *      clientId: passed via the OktaAuth constructor or into getToken
	 *
	 *    Optional:
	 *      redirectUri: defaults to window.location.href
	 *      scopes: defaults to ['openid', 'email']
	 *      idp: defaults to Okta as an idp
	 *      prompt: no default. Pass 'none' to throw an error if user is not signed in
	 *
	 *    Forced:
	 *      display: 'popup'
	 *
	 *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override
	 *
	 * @param {Object} oauthOptions
	 * @param {String} [oauthOptions.clientId] ID of this client
	 * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated
	 * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)
	 * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication
	 * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API
	 * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.
	 *                                       Use 'none' to prevent this behavior
	 *
	 * @param {Object} options
	 * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000
	 * @param {String} [options.popupTitle] Title dispayed in the popup.
	 *                                      Defaults to 'External Identity Provider User Authentication'
	 */
	function getToken(sdk, oauthOptions, options) {
	  oauthOptions = oauthOptions || {};
	  options = options || {};

	  // Default OAuth query params
	  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);

	  // Start overriding any options that don't make sense
	  var sessionTokenOverrides = {
	    prompt: 'none',
	    responseMode: 'okta_post_message',
	    display: null
	  };

	  var idpOverrides = {
	    display: 'popup'
	  };

	  if (oauthOptions.sessionToken) {
	    util.extend(oauthParams, sessionTokenOverrides);
	  } else if (oauthOptions.idp) {
	    util.extend(oauthParams, idpOverrides);
	  }

	  // Use the query params to build the authorize url
	  var requestUrl,
	      urls;
	  try {
	    // Get authorizeUrl and issuer
	    urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);
	    requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);
	  } catch (e) {
	    return Q.reject(e);
	  }

	  // Determine the flow type
	  var flowType;
	  if (oauthParams.sessionToken || oauthParams.display === null) {
	    flowType = 'IFRAME';
	  } else if (oauthParams.display === 'popup') {
	    flowType = 'POPUP';
	  } else {
	    flowType = 'IMPLICIT';
	  }

	  function getOrigin(url) {
	    var originRegex = /^(https?\:\/\/)?([^:\/?#]*(?:\:[0-9]+)?)/;
	    return originRegex.exec(url)[0];
	  }

	  // Execute the flow type
	  switch (flowType) {
	    case 'IFRAME':
	      var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);
	      var iframeEl = oauthUtil.loadFrame(requestUrl);
	      return iframePromise
	        .then(function(res) {
	          return handleOAuthResponse(sdk, oauthParams, res, urls);
	        })
	        .fin(function() {
	          if (document.body.contains(iframeEl)) {
	            iframeEl.parentElement.removeChild(iframeEl);
	          }
	        });

	    case 'POPUP': // eslint-disable-line no-case-declarations
	      var popupPromise;

	      // Add listener on postMessage before window creation, so
	      // postMessage isn't triggered before we're listening
	      if (oauthParams.responseMode === 'okta_post_message') {
	        if (!sdk.features.isPopupPostMessageSupported()) {
	          return Q.reject(new AuthSdkError('This browser doesn\'t have full postMessage support'));
	        }
	        popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);
	      }

	      // Create the window
	      var windowOptions = {
	        popupTitle: options.popupTitle
	      };
	      var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions);

	      // Poll until we get a valid hash fragment
	      if (oauthParams.responseMode === 'fragment') {
	        var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());
	        var redirectUriOrigin = getOrigin(oauthParams.redirectUri);
	        if (windowOrigin !== redirectUriOrigin) {
	          return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin +
	            ') must match the origin of this page (' + windowOrigin + ')'));
	        }
	        popupPromise = addFragmentListener(sdk, windowEl, options.timeout);
	      }

	      // Both postMessage and fragment require a poll to see if the popup closed
	      var popupDeferred = Q.defer();
	      function hasClosed(win) { // eslint-disable-line no-inner-declarations
	        if (win.closed) {
	          popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));
	        }
	      }
	      var closePoller = setInterval(function() {
	        hasClosed(windowEl);
	      }, 500);

	      // Proxy the promise results into the deferred
	      popupPromise
	      .then(function(res) {
	        popupDeferred.resolve(res);
	      })
	      .fail(function(err) {
	        popupDeferred.reject(err);
	      });

	      return popupDeferred.promise
	        .then(function(res) {
	          return handleOAuthResponse(sdk, oauthParams, res, urls);
	        })
	        .fin(function() {
	          if (!windowEl.closed) {
	            clearInterval(closePoller);
	            windowEl.close();
	          }
	        });

	    default:
	      return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));
	  }
	}

	function getWithoutPrompt(sdk, oauthOptions, options) {
	  var oauthParams = util.clone(oauthOptions) || {};
	  util.extend(oauthParams, {
	    prompt: 'none',
	    responseMode: 'okta_post_message',
	    display: null
	  });
	  return getToken(sdk, oauthParams, options);
	}

	function getWithPopup(sdk, oauthOptions, options) {
	  var oauthParams = util.clone(oauthOptions) || {};
	  util.extend(oauthParams, {
	    display: 'popup'
	  });
	  return getToken(sdk, oauthParams, options);
	}

	function getWithRedirect(sdk, oauthOptions, options) {
	  oauthOptions = util.clone(oauthOptions) || {};
	  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);
	  // If the user didn't specify a responseMode
	  if (!oauthOptions.responseMode) {
	    // And it's only an auth code request (responseType could be an array)
	    var respType = oauthParams.responseType;
	    if (respType.indexOf('code') !== -1 &&
	        (util.isString(respType) || (Array.isArray(respType) && respType.length === 1))) {
	        // Default the responseMode to query
	        util.extend(oauthParams, {
	          responseMode: 'query'
	        });
	    // Otherwise, default to fragment
	    } else {
	      util.extend(oauthParams, {
	        responseMode: 'fragment'
	      });
	    }
	  }
	  
	  var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);
	  var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);

	  // Set session cookie to store the oauthParams
	  cookies.setCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({
	    responseType: oauthParams.responseType,
	    state: oauthParams.state,
	    nonce: oauthParams.nonce,
	    scopes: oauthParams.scopes,
	    urls: urls
	  }));

	  // Set nonce cookie for servers to validate nonce in id_token
	  cookies.setCookie(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce);

	  // Set state cookie for servers to validate state
	  cookies.setCookie(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);

	  sdk.token.getWithRedirect._setLocation(requestUrl);
	}

	function refreshToken(sdk, token) {
	  if (!oauthUtil.isToken(token)) {
	    return Q.reject(new AuthSdkError('Refresh must be passed a token with ' +
	      'an array of scopes and an accessToken or idToken'));
	  }

	  var responseType;
	  if (token.accessToken) {
	    responseType = 'token';
	  } else {
	    responseType = 'id_token';
	  }
	  return sdk.token.getWithoutPrompt({
	    responseType: responseType,
	    scopes: token.scopes
	  }, {
	    authorizeUrl: token.authorizeUrl,
	    userinfoUrl: token.userinfoUrl,
	    issuer: token.issuer
	  });
	}

	function parseFromUrl(sdk, url) {
	  var hash = sdk.token.parseFromUrl._getLocationHash();
	  if (url) {
	    hash = url.substring(url.indexOf('#'));
	  }

	  var oauthParamsCookie = cookies.getCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);
	  if (!hash || !oauthParamsCookie) {
	    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));
	  }
	  try {
	    var oauthParams = JSON.parse(oauthParamsCookie);
	    var urls = oauthParams.urls;
	    delete oauthParams.urls;
	    cookies.deleteCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);
	  } catch(e) {
	    return Q.reject(new AuthSdkError('Unable to parse the ' + 
	      config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));
	  }

	  return Q.resolve(oauthUtil.hashToObject(hash))
	    .then(function(res) {
	      return handleOAuthResponse(sdk, oauthParams, res, urls);
	    });
	}

	function getUserInfo(sdk, accessTokenObject) {
	  if (!accessTokenObject ||
	      (!oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl)) {
	    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));
	  }
	  return http.httpRequest(sdk, {
	    url: accessTokenObject.userinfoUrl,
	    method: 'GET',
	    accessToken: accessTokenObject.accessToken
	  })
	  .fail(function(err) {
	    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {
	      var authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');
	      if (authenticateHeader) {
	        var errorMatches = authenticateHeader.match(/error="(.*?)"/) || [];
	        var errorDescriptionMatches = authenticateHeader.match(/error_description="(.*?)"/) || [];
	        var error = errorMatches[1];
	        var errorDescription = errorDescriptionMatches[1];
	        if (error && errorDescription) {
	          err = new OAuthError(error, errorDescription);
	        }
	      }
	    }
	    throw err;
	  });
	}

	module.exports = {
	  getToken: getToken,
	  getWithoutPrompt: getWithoutPrompt,
	  getWithPopup: getWithPopup,
	  getWithRedirect: getWithRedirect,
	  parseFromUrl: parseFromUrl,
	  refreshIdToken: refreshIdToken,
	  decodeToken: decodeToken,
	  verifyIdToken: verifyIdToken,
	  refreshToken: refreshToken,
	  getUserInfo: getUserInfo,
	  verifyToken: verifyToken
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable complexity, max-statements */
	var http = __webpack_require__(25);
	var util = __webpack_require__(23);
	var storageUtil = __webpack_require__(27);
	var AuthSdkError = __webpack_require__(29);

	var httpCache = storageUtil.getHttpCache();

	function isToken(obj) {
	  if (obj &&
	      (obj.accessToken || obj.idToken) &&
	      Array.isArray(obj.scopes)) {
	    return true;
	  }
	  return false;
	}

	function addListener(eventTarget, name, fn) {
	  if (eventTarget.addEventListener) {
	    eventTarget.addEventListener(name, fn);
	  } else {
	    eventTarget.attachEvent('on' + name, fn);
	  }
	}

	function removeListener(eventTarget, name, fn) {
	  if (eventTarget.removeEventListener) {
	    eventTarget.removeEventListener(name, fn);
	  } else {
	    eventTarget.detachEvent('on' + name, fn);
	  }
	}

	function loadFrame(src) {
	  var iframe = document.createElement('iframe');
	  iframe.style.display = 'none';
	  iframe.src = src;

	  return document.body.appendChild(iframe);
	}

	function loadPopup(src, options) {
	  var title = options.popupTitle || 'External Identity Provider User Authentication';
	  var appearance = 'toolbar=no, scrollbars=yes, resizable=yes, ' +
	    'top=100, left=500, width=600, height=600';
	  return window.open(src, title, appearance);
	}

	function getWellKnown(sdk, issuer) {
	  return http.get(sdk, (issuer || sdk.options.url) + '/.well-known/openid-configuration', {
	    cacheResponse: true
	  });
	}

	function getKey(sdk, issuer, kid) {
	  return getWellKnown(sdk, issuer)
	  .then(function(wellKnown) {
	    var jwksUri = wellKnown['jwks_uri'];

	    // Check our kid against the cached version (if it exists and isn't expired)
	    var cacheContents = httpCache.getStorage();
	    var cachedResponse = cacheContents[jwksUri];
	    if (cachedResponse && Date.now()/1000 < cachedResponse.expiresAt) {
	      var cachedKey = util.find(cachedResponse.response.keys, {
	        kid: kid
	      });

	      if (cachedKey) {
	        return cachedKey;
	      }
	    }

	    // Remove cache for the key
	    httpCache.clearStorage(jwksUri);

	    // Pull the latest keys if the key wasn't in the cache
	    return http.get(sdk, jwksUri, {
	      cacheResponse: true
	    })
	    .then(function(res) {
	      var key = util.find(res.keys, {
	        kid: kid
	      });

	      if (key) {
	        return key;
	      }

	      throw new AuthSdkError('The key id, ' + kid + ', was not found in the server\'s keys');
	    });
	  });
	}

	function validateClaims(sdk, claims, aud, iss, nonce) {
	  if (!claims || !iss || !aud) {
	    throw new AuthSdkError('The jwt, iss, and aud arguments are all required');
	  }

	  if (nonce && claims.nonce !== nonce) {
	    throw new AuthSdkError('OAuth flow response nonce doesn\'t match request nonce');
	  }

	  var now = Math.floor(new Date().getTime()/1000);

	  if (claims.iss !== iss) {
	    throw new AuthSdkError('The issuer [' + claims.iss + '] ' +
	      'does not match [' + iss + ']');
	  }

	  if (claims.aud !== aud) {
	    throw new AuthSdkError('The audience [' + claims.aud + '] ' +
	      'does not match [' + aud + ']');
	  }

	  if (claims.iat > claims.exp) {
	    throw new AuthSdkError('The JWT expired before it was issued');
	  }

	  if ((now - sdk.options.maxClockSkew) > claims.exp) {
	    throw new AuthSdkError('The JWT expired and is no longer valid');
	  }

	  if (claims.iat > (now + sdk.options.maxClockSkew)) {
	    throw new AuthSdkError('The JWT was issued in the future');
	  }
	}

	function getOAuthUrls(sdk, oauthParams, options) {
	  options = options || {};

	  // Get user-supplied arguments
	  var authorizeUrl = util.removeTrailingSlash(options.authorizeUrl) || sdk.options.authorizeUrl;
	  var issuer = util.removeTrailingSlash(options.issuer) || sdk.options.issuer;
	  var userinfoUrl = util.removeTrailingSlash(options.userinfoUrl) || sdk.options.userinfoUrl;

	  // If an issuer exists but it's not a url, assume it's an authServerId
	  if (issuer && !(/^https?:/.test(issuer))) {
	    // Make it a url
	    issuer = sdk.options.url + '/oauth2/' + issuer;
	  }

	  // If an authorizeUrl is supplied without an issuer, and an id_token is requested
	  if (!issuer && authorizeUrl &&
	      oauthParams.responseType.indexOf('id_token') !== -1) {
	    // The issuer is ambiguous, so we won't be able to validate the id_token jwt
	    throw new AuthSdkError('Cannot request idToken with an authorizeUrl without an issuer');
	  }

	  // If a token is requested without an issuer
	  if (!issuer && oauthParams.responseType.indexOf('token') !== -1) {
	    // If an authorizeUrl is supplied without a userinfoUrl
	    if (authorizeUrl && !userinfoUrl) {
	      // The userinfoUrl is ambiguous, so we won't be able to call getUserInfo
	      throw new AuthSdkError('Cannot request accessToken with an authorizeUrl without an issuer or userinfoUrl');
	    }

	    // If a userinfoUrl is supplied without a authorizeUrl
	    if (userinfoUrl && !authorizeUrl) {
	      // The authorizeUrl is ambiguous, so we won't be able to call the authorize endpoint
	      throw new AuthSdkError('Cannot request token with an userinfoUrl without an issuer or authorizeUrl');
	    }
	  }

	  var sharedResourceServerRegex = new RegExp('^https?://.*?/oauth2/.+');

	  // Default the issuer to our baseUrl
	  issuer = issuer || sdk.options.url;

	  // A shared resource server issuer looks like:
	  // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7
	  if (sharedResourceServerRegex.test(issuer)) {
	    // A shared resource server authorizeUrl looks like:
	    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/authorize
	    authorizeUrl = authorizeUrl || issuer + '/v1/authorize';
	    // Shared resource server userinfoUrls look like:
	    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/userinfo
	    userinfoUrl = userinfoUrl || issuer + '/v1/userinfo';

	  // Normally looks like:
	  // https://example.okta.com
	  } else {
	    // Normal authorizeUrls look like:
	    // https://example.okta.com/oauth2/v1/authorize
	    authorizeUrl = authorizeUrl || issuer + '/oauth2/v1/authorize';
	    // Normal userinfoUrls look like:
	    // https://example.okta.com/oauth2/v1/userinfo
	    userinfoUrl = userinfoUrl || issuer + '/oauth2/v1/userinfo';
	  }

	  return {
	    issuer: issuer,
	    authorizeUrl: authorizeUrl,
	    userinfoUrl: userinfoUrl
	  };
	}

	function hashToObject(hash) {
	  // Predefine regexs for parsing hash
	  var plus2space = /\+/g;
	  var paramSplit = /([^&=]+)=?([^&]*)/g;

	  // Remove the leading hash
	  var fragment = hash.substring(1);

	  var obj = {};

	  // Loop until we have no more params
	  var param;
	  while (true) { // eslint-disable-line no-constant-condition
	    param = paramSplit.exec(fragment);
	    if (!param) { break; }

	    var key = param[1];
	    var value = param[2];

	    // id_token should remain base64url encoded
	    if (key === 'id_token' || key === 'access_token' || key === 'code') {
	      obj[key] = value;
	    } else {
	      obj[key] = decodeURIComponent(value.replace(plus2space, ' '));
	    }
	  }
	  return obj;
	}

	module.exports = {
	  getWellKnown: getWellKnown,
	  getKey: getKey,
	  validateClaims: validateClaims,
	  getOAuthUrls: getOAuthUrls,
	  loadFrame: loadFrame,
	  loadPopup: loadPopup,
	  hashToObject: hashToObject,
	  isToken: isToken,
	  addListener: addListener,
	  removeListener: removeListener
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	var util = __webpack_require__(23);

	function verifyToken(idToken, key) {
	  key = util.clone(key);

	  var format = 'jwk';
	  var algo = {
	    name: 'RSASSA-PKCS1-v1_5',
	    hash: { name: 'SHA-256' }
	  };
	  var extractable = true;
	  var usages = ['verify'];

	  // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails
	  // This is a metadata tag that specifies the intent of how the key should be used.
	  // It's not necessary to properly verify the jwt's signature.
	  delete key.use;

	  return crypto.subtle.importKey(
	    format,
	    key,
	    algo,
	    extractable,
	    usages
	  )
	  .then(function(cryptoKey) {
	    var jwt = idToken.split('.');
	    var payload = util.stringToBuffer(jwt[0] + '.' + jwt[1]);
	    var b64Signature = util.base64UrlDecode(jwt[2]);
	    var signature = util.stringToBuffer(b64Signature);

	    return crypto.subtle.verify(
	      algo,
	      cryptoKey,
	      signature,
	      payload
	    );
	  });
	}

	module.exports = {
	  verifyToken: verifyToken
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	function OAuthError(errorCode, summary) {
	  this.name = 'OAuthError';
	  this.message = summary;

	  this.errorCode = errorCode;
	  this.errorSummary = summary;
	}
	OAuthError.prototype = new Error();

	module.exports = OAuthError;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint complexity:[0,8] max-statements:[0,21] */
	var util = __webpack_require__(23);
	var AuthSdkError = __webpack_require__(29);
	var storageUtil = __webpack_require__(27);
	var Q = __webpack_require__(9);
	var Emitter = __webpack_require__(39);
	var config = __webpack_require__(30);
	var storageBuilder = __webpack_require__(28);

	function emitExpired(tokenMgmtRef, key, token) {
	  tokenMgmtRef.emitter.emit('expired', key, token);
	}

	function clearRefreshTimeout(tokenMgmtRef, key) {
	  clearTimeout(tokenMgmtRef.refreshTimeouts[key]);
	  delete tokenMgmtRef.refreshTimeouts[key];
	}

	function clearRefreshTimeoutAll(tokenMgmtRef) {
	  var refreshTimeouts = tokenMgmtRef.refreshTimeouts;
	  for(var key in refreshTimeouts) {
	    if (!refreshTimeouts.hasOwnProperty(key)) {
	      continue;
	    }
	    clearRefreshTimeout(tokenMgmtRef, key);
	  }
	  tokenMgmtRef.refreshTimeouts = {};
	}

	function setRefreshTimeout(sdk, tokenMgmtRef, storage, key, token) {
	  var refreshWait = (token.expiresAt * 1000) - Date.now();
	  if (refreshWait < 0) {
	    // Already expired
	    refreshWait = 0;
	  }
	  var refreshTimeout = setTimeout(function() {
	    if (tokenMgmtRef.autoRefresh) {
	      return refresh(sdk, tokenMgmtRef, storage, key);
	    } else if (token.expiresAt * 1000 <= Date.now()) {
	      remove(tokenMgmtRef, storage, key);
	      emitExpired(tokenMgmtRef, key, token);
	    }
	  }, refreshWait);

	  // Clear any existing timeout
	  clearRefreshTimeout(tokenMgmtRef, key);

	  // Add a new timeout
	  tokenMgmtRef.refreshTimeouts[key] = refreshTimeout;
	}

	function setRefreshTimeoutAll(sdk, tokenMgmtRef, storage) {
	  try {
	    var tokenStorage = storage.getStorage();
	  } catch(e) {
	    // Any errors thrown on instantiation will not be caught,
	    // because there are no listeners yet
	    tokenMgmtRef.emitter.emit('error', e);
	    return;
	  }

	  for(var key in tokenStorage) {
	    if (!tokenStorage.hasOwnProperty(key)) {
	      continue;
	    }
	    var token = tokenStorage[key];
	    setRefreshTimeout(sdk, tokenMgmtRef, storage, key, token);
	  }
	}

	function add(sdk, tokenMgmtRef, storage, key, token) {
	  var tokenStorage = storage.getStorage();
	  if (!util.isObject(token) ||
	      !token.scopes ||
	      (!token.expiresAt && token.expiresAt !== 0) ||
	      (!token.idToken && !token.accessToken)) {
	    throw new AuthSdkError('Token must be an Object with scopes, expiresAt, and an idToken or accessToken properties');
	  }
	  tokenStorage[key] = token;
	  storage.setStorage(tokenStorage);
	  setRefreshTimeout(sdk, tokenMgmtRef, storage, key, token);
	}

	function get(storage, key) {
	  var tokenStorage = storage.getStorage();
	  return tokenStorage[key];
	}

	function remove(tokenMgmtRef, storage, key) {
	  // Clear any listener for this token
	  clearRefreshTimeout(tokenMgmtRef, key);

	  // Remove it from storage
	  var tokenStorage = storage.getStorage();
	  delete tokenStorage[key];
	  storage.setStorage(tokenStorage);
	}

	function refresh(sdk, tokenMgmtRef, storage, key) {
	  try {
	    var token = get(storage, key);
	    if (!token) {
	      throw new AuthSdkError('The tokenManager has no token for the key: ' + key);
	    }
	  } catch (e) {
	    return Q.reject(e);
	  }

	  // Remove existing autoRefresh timeout for this key
	  clearRefreshTimeout(tokenMgmtRef, key);

	  return sdk.token.refresh(token)
	  .then(function(freshToken) {
	    add(sdk, tokenMgmtRef, storage, key, freshToken);
	    tokenMgmtRef.emitter.emit('refreshed', key, freshToken, token);
	    return freshToken;
	  })
	  .fail(function(err) {
	    if (err.name === 'OAuthError') {
	      remove(tokenMgmtRef, storage, key);
	      emitExpired(tokenMgmtRef, key, token);
	    }
	    throw err;
	  });
	}

	function clear(tokenMgmtRef, storage) {
	  clearRefreshTimeoutAll(tokenMgmtRef);
	  storage.clearStorage();
	}

	function TokenManager(sdk, options) {
	  options = options || {};
	  options.storage = options.storage || 'localStorage';
	  if (!options.autoRefresh && options.autoRefresh !== false) {
	    options.autoRefresh = true;
	  }

	  if (options.storage === 'localStorage' && !storageUtil.browserHasLocalStorage()) {
	    util.warn('This browser doesn\'t support localStorage. Switching to sessionStorage.');
	    options.storage = 'sessionStorage';
	  }

	  if (options.storage === 'sessionStorage' && !storageUtil.browserHasSessionStorage()) {
	    util.warn('This browser doesn\'t support sessionStorage. Switching to cookie-based storage.');
	    options.storage = 'cookie';
	  }

	  var storage;
	  switch(options.storage) {
	    case 'localStorage':
	      storage = storageBuilder(localStorage, config.TOKEN_STORAGE_NAME);
	      break;
	    case 'sessionStorage':
	      storage = storageBuilder(sessionStorage, config.TOKEN_STORAGE_NAME);
	      break;
	    case 'cookie':
	      storage = storageBuilder(storageUtil.getCookieStorage(), config.TOKEN_STORAGE_NAME);
	      break;
	    default:
	      throw new AuthSdkError('Unrecognized storage option');
	  }

	  var tokenMgmtRef = {
	    emitter: new Emitter(),
	    autoRefresh: options.autoRefresh,
	    refreshTimeouts: {}
	  };

	  this.add = util.bind(add, this, sdk, tokenMgmtRef, storage);
	  this.get = util.bind(get, this, storage);
	  this.remove = util.bind(remove, this, tokenMgmtRef, storage);
	  this.clear = util.bind(clear, this, tokenMgmtRef, storage);
	  this.refresh = util.bind(refresh, this, sdk, tokenMgmtRef, storage);
	  this.on = util.bind(tokenMgmtRef.emitter.on, tokenMgmtRef.emitter);
	  this.off = util.bind(tokenMgmtRef.emitter.off, tokenMgmtRef.emitter);
	  
	  setRefreshTimeoutAll(sdk, tokenMgmtRef, storage);
	}

	module.exports = TokenManager;


/***/ },
/* 39 */
/***/ function(module, exports) {

	function E () {
	  // Keep this empty so it's easier to inherit from
	  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
	}

	E.prototype = {
	  on: function (name, callback, ctx) {
	    var e = this.e || (this.e = {});

	    (e[name] || (e[name] = [])).push({
	      fn: callback,
	      ctx: ctx
	    });

	    return this;
	  },

	  once: function (name, callback, ctx) {
	    var self = this;
	    function listener () {
	      self.off(name, listener);
	      callback.apply(ctx, arguments);
	    };

	    listener._ = callback
	    return this.on(name, listener, ctx);
	  },

	  emit: function (name) {
	    var data = [].slice.call(arguments, 1);
	    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
	    var i = 0;
	    var len = evtArr.length;

	    for (i; i < len; i++) {
	      evtArr[i].fn.apply(evtArr[i].ctx, data);
	    }

	    return this;
	  },

	  off: function (name, callback) {
	    var e = this.e || (this.e = {});
	    var evts = e[name];
	    var liveEvents = [];

	    if (evts && callback) {
	      for (var i = 0, len = evts.length; i < len; i++) {
	        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
	          liveEvents.push(evts[i]);
	      }
	    }

	    // Remove event from queue to prevent memory leak
	    // Suggested by https://github.com/lazd
	    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

	    (liveEvents.length)
	      ? e[name] = liveEvents
	      : delete e[name];

	    return this;
	  }
	};

	module.exports = E;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*global JSON */
	/*jshint maxcomplexity:8 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  var Util = {};
	  var _ = Okta._;

	  Util.hasTokensInHash = function (hash) {
	    return /((id|access)_token=)/i.test(hash);
	  };

	  Util.transformErrorXHR = function (xhr) {
	    // Handle network connection error
	    if (xhr.status === 0 && _.isEmpty(xhr.responseJSON)) {
	      xhr.responseJSON = { errorSummary: Okta.loc('error.network.connection', 'login') };
	      return xhr;
	    }
	    if (!xhr.responseJSON) {
	      try {
	        xhr.responseJSON = JSON.parse(xhr.responseText);
	      } catch (parseException) {
	        xhr.responseJSON = { errorSummary: Okta.loc('oform.error.unexpected', 'login') };
	        return xhr;
	      }
	    }
	    // Temporary solution to display field errors
	    // Assuming there is only one field error in a response
	    if (xhr.responseJSON && xhr.responseJSON.errorCauses && xhr.responseJSON.errorCauses.length) {
	      xhr.responseJSON.errorSummary = xhr.responseJSON.errorCauses[0].errorSummary;
	    }
	    // Replace error messages
	    if (!_.isEmpty(xhr.responseJSON)) {
	      var errorMsg = Okta.loc('errors.' + xhr.responseJSON.errorCode, 'login');
	      if (errorMsg.indexOf('L10N_ERROR[') === -1) {
	        xhr.responseJSON.errorSummary = errorMsg;
	      }
	    }
	    return xhr;
	  };

	  // Simple helper function to lowercase all strings in the given array
	  Util.toLower = function (strings) {
	    return _.map(strings, function (str) {
	      return str.toLowerCase();
	    });
	  };

	  // A languageCode can be composed of multiple parts, i.e:
	  // {{langage}}-{{region}}-{{dialect}}
	  //
	  // In these cases, it's necessary to generate a list of other possible
	  // combinations that we might support (in preferred order).
	  //
	  // For example:
	  // en-US -> [en-US, en]
	  // de-DE-bavarian -> [de-DE-bavarian, de-DE, de]
	  function expandLanguage(language) {
	    var expanded = [language],
	        parts = language.split('-');
	    while (parts.pop() && parts.length > 0) {
	      expanded.push(parts.join('-'));
	    }
	    return expanded;
	  }

	  // Following the rules of expanding one language, this will generate
	  // all potential languages in the given order (where higher priority is
	  // given to expanded languages over other downstream languages).
	  Util.expandLanguages = function (languages) {
	    return _.chain(languages)
	      .map(expandLanguage)
	      .flatten()
	      .uniq()
	      .value();
	  };

	  return Util;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: 0 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(4),
	  __webpack_require__(42),
	  __webpack_require__(45),
	  __webpack_require__(46),
	  __webpack_require__(48),
	  __webpack_require__(51),
	  __webpack_require__(16),
	  __webpack_require__(53),
	  __webpack_require__(16),
	  __webpack_require__(56),
	  __webpack_require__(16),
	  __webpack_require__(16),
	  __webpack_require__(58),
	  __webpack_require__(16),
	  __webpack_require__(16),
	  __webpack_require__(16),
	  __webpack_require__(100),
	  __webpack_require__(16),
	  __webpack_require__(16),
	  __webpack_require__(7),
	  __webpack_require__(49),
	  __webpack_require__(83),
	  __webpack_require__(13),
	  __webpack_require__(16)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, Handlebars, Model, BaseModel, BaseCollection, BaseView, ListView, TableView, BaseRouter,
	          TabbedRouter, BaseController, DataListController, DeadSimpleDataList, BaseForm, BaseFormDialog,
	          BaseModalDialog, MultiViewModalDialog, Callout, DropDown, BaseWizard, StringUtil, TemplateUtil,
	          ButtonFactory, Logger, Metrics) {

	  /**
	   * @class Okta
	   * @singleton
	   *
	   * #### The Okta module holds reference to many frequently used objects and functions
	   *
	   * A quick example:
	   *
	   * ```javascript
	   * define(['okta'], function (Okta) {
	   *
	   *   var Form = Okta.FormDialog.extend({
	   *     title: Okta.loc('my.i18n.key'),
	   *     inputs: [
	   *       {
	   *         type: 'text',
	   *         name: 'name'
	   *       }
	   *     ]
	   *   });
	   *
	   *   var View = Okta.View.extend({
	   *     children: [
	   *       Okta.createButton({
	   *         title: 'Click Me',
	   *         click: function () {
	   *           new Form({model: new Okta.Model()}).render();
	   *         }
	   *       })
	   *     ]
	   *   });
	   *
	   * });
	   *
	   * ```
	   */

	  return {

	    /**
	     * A reference to jQuery
	     * @type {jQuery}
	     */
	    $: $,

	    /**
	     * A reference to underscore
	     * @type {underscore}
	     */
	    _: _,

	    /**
	     * A reference to Handlebars
	     * @type {Handlebars}
	     */
	    Handlebars: Handlebars,

	    /**
	     * @method
	     * @inheritdoc StringUtil#static-method-localize
	     */
	    loc: StringUtil.localize,

	    /**
	     * @method
	     * @inheritdoc ButtonFactory#create
	     */
	    createButton: ButtonFactory.create,

	    /**
	     * @method
	     * @inheritdoc Callout#static-method-create
	     */
	    createCallout: Callout.create,

	    /**
	     * @method
	     * @inheritdoc TemplateUtil#tpl
	     */
	    tpl: TemplateUtil.tpl,


	    Model: Model,
	    BaseModel: BaseModel,
	    Collection: BaseCollection,

	    View: BaseView,
	    ListView: ListView,
	    TableView: TableView,

	    Router: BaseRouter,
	    TabbedRouter: TabbedRouter,

	    Controller: BaseController,
	    DataListController: DataListController,

	    DataList: DeadSimpleDataList,

	    ModalDialog: BaseModalDialog,
	    MultiViewModalDialog: MultiViewModalDialog,

	    Form: BaseForm,
	    FormDialog: BaseFormDialog,

	    DropDown: DropDown,

	    Wizard: BaseWizard,

	    Logger: Logger,

	    Metrics: Metrics

	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(43)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Model) {

	  /**
	  * @class Okta.Model
	  * @extends Archer.Model
	  * @inheritDoc Archer.Model
	  */
	  return Model.extend({

	    /**
	     * Is the end point using the legacy "secureJSON" format
	     * @type {Function|Boolean}
	     */
	    secureJSON: false,

	    _builtInLocalProps: {
	      '__edit__': 'boolean',
	      '__pending__': 'boolean'
	    },

	    constructor: function () {
	      this.local = _.defaults({}, _.result(this, 'local'), this._builtInLocalProps);

	      if (_.result(this, 'secureJSON')) {
	        this.sync = _.wrap(this.sync, function (sync, method, model, options) {
	          return sync.call(this, method, model, _.extend({dataType: 'secureJSON'}, options));
	        });
	      }

	      Model.apply(this, arguments);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(44)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  /* global module, exports */
	  else if (typeof require === 'function' && typeof exports === 'object') {
	    module.exports = factory(require('underscore'), require('backbone'));
	  }
	  else {
	    root.Archer || (root.Archer = {});
	    root.Archer.Model = factory(root._, root.Backbone);
	  }
	}(this, function (_, Backbone) {
	  var Model;

	  /**
	  * @class Archer.Model
	  * @extend Backbone.Model
	  *
	  * Archer.Model is a standard [Backbone.Model](http://backbonejs.org/#Model) with a few additions:
	  *
	  * - {@link #derived Derived properties}
	  * - {@link #props Built in schema validation}
	  * - {@link #local Private properties (with schema validation)}
	  * - {@link #flat Flattening of nested objects}
	  *
	  * Both derived and private properties are filtered out when sending the data to the server.
	  *
	  * Example:
	  *
	  * ```javascript
	  * var Person = Archer.Model.extend({
	  *   props: {
	  *     'fname': 'string',
	  *     'lname': 'string'
	  *   },
	  *   local: {
	  *     isLoggedIn: 'boolean'
	  *   },
	  *   derived: {
	  *     name: {
	  *       deps: ['fname', 'lname'],
	  *       fn: function (fname, lname) {
	  *         return fname + ' ' + lname;
	  *       }
	  *     }
	  *   }
	  * });
	  * var model = new Person({fname: 'Joe', lname: 'Doe'});
	  * model.get('name'); //=> "Joe Doe"
	  * model.toJSON(); //=> {fname: 'Joe', lname: 'Doe'}
	  *
	  * model.set('isLoggedIn', true);
	  * model.get('isLoggedIn'); //=> true
	  * model.toJSON(); //=> {fname: 'Joe', lname: 'Doe'}
	  * ```
	  * See: [Backbone.Model](http://backbonejs.org/#Model-constructor)
	  */

	  function flatten(value, objectTypeFields, key, target) {
	    var filter = _.contains(objectTypeFields, key);
	    target || (target = {});
	    if (!filter && _.isObject(value) && !_.isArray(value) && !_.isFunction(value)) {
	      _.each(value, function (val, i) {
	        flatten(val, objectTypeFields, key ? (key + '.' + i) : i, target);
	      });
	    }
	    // Case where target is an empty object. Guard against returning {undefined: undefined}.
	    else if (key !== undefined) {
	      target[key] = value;
	    }
	    return target;
	  }

	  function unflatten(data) {
	    _.each(data, function (value, key, data) {
	      if (key.indexOf('.') == -1) {
	        return;
	      }
	      var part,
	          ref = data,
	          parts = key.split('.');
	      while ((part = parts.shift()) !== undefined) {
	        if (!ref[part]) {
	          ref[part] = parts.length ? {} : value;
	        }
	        ref = ref[part];
	      }
	      delete data[key];
	    });
	    return data;
	  }

	  function createMessage(field, msg) {
	    var obj = {};
	    obj[field.name] = msg;
	    return obj;
	  }

	  function normalizeSchemaDef(field, name) {
	    var target;
	    if (_.isString(field)) {
	      target = {
	        type: field
	      };
	    }
	    else if (_.isArray(field)) {
	      target = {
	        type: field[0],
	        required: field[1],
	        value: field[2]
	      };
	    }
	    else {
	      target = _.clone(field);
	    }
	    _.defaults(target, {required: false, name: name});
	    return target;
	  }

	  function capitalize(string) {
	    return string.toLowerCase().replace(/\b[a-z]/g, function (letter) {
	      return letter.toUpperCase();
	    });
	  }

	  function allowExtraProperties(rule, key) {
	    if (_.isBoolean(rule)) {
	      return rule;
	    }
	    else if (_.isRegExp(rule)) {
	      return rule.test(key);
	    }
	    else if (_.isFunction(rule)) {
	      return rule.call(this, key);
	    }
	    return false;
	  }

	  function _validateRegex(value, pattern, error) {
	    if (!pattern.test(value)) {
	      return error;
	    }
	  }

	  var StringFormatValidators = {
	    /*eslint max-len: 0 */
	    email: function (value) {
	      // source: http://emailregex.com/
	      var pattern = /^[-a-z0-9~!$%^&*_=+}{\'?]+(\.[-a-z0-9~!$%^&*_=+}{\'?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i;
	      return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_EMAIL);
	    },
	    uri: function (value) {
	      // source: https://mathiasbynens.be/demo/url-regex
	      var pattern = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i;
	      return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_URI);
	    },
	    ipv4: function (value) {
	      // source: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
	      var pattern = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
	      return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_IPV4);
	    },
	    hostname: function (value) {
	      // source: http://www.regextester.com/23
	      var pattern = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
	      return _validateRegex(value, pattern, Model.ERROR_INVALID_FORMAT_HOSTNAME);
	    }
	  };

	  function validateStringFormat(field, value) {
	    var validator = StringFormatValidators[field.format];
	    if (field.format && !validator) {
	      throw new TypeError(field.format + ' is not a supported string format');
	    }
	    return validator && validator(value);
	  }

	  function validateString(field, value) {
	    var createMessageWith = _.partial(createMessage, field),
	        invalidFormat = validateStringFormat(field, value);
	    if (invalidFormat) {
	      return createMessageWith(invalidFormat);
	    }
	    if (value && field.minLength && value.length < field.minLength) {
	      return createMessageWith(Model.ERROR_STRING_STRING_MIN_LENGTH, value.length);
	    }
	    if (value && field.maxLength && value.length > field.maxLength) {
	      return createMessageWith(Model.ERROR_STRING_STRING_MAX_LENGTH, value.length);
	    }
	  }

	  function validateField(field, value) {
	    /* eslint complexity: [2, 13], max-statements: [2, 19]*/
	    var createMessageWith = _.partial(createMessage, field),
	        isDefined = !_.isUndefined(value) && !_.isNull(value),
	        checkType,
	        errorMessage;

	    // check required fields
	    if (field.required && (!isDefined || _.isNull(value) || value === '')) {
	      return createMessageWith(Model.ERROR_BLANK);
	    }
	    // check type
	    checkType = _['is' + capitalize(field.type)];
	    if (isDefined && field.type != 'any' && (!_.isFunction(checkType) || !checkType(value))) {
	      return createMessageWith(Model.ERROR_WRONG_TYPE);
	    }
	    // validate string format
	    if (value && field.type == 'string') {
	      var error = validateString(field, value);
	      if (error) {
	        return error;
	      }
	    }
	    // check pre set values (enum)
	    if (isDefined && field.values && !_.contains(field.values, value)) {
	      return createMessageWith(Model.ERROR_NOT_ALLOWED);
	    }
	    // check validate method
	    if (_.isFunction(field.validate)) {
	      var result = field.validate(value);
	      if (_.isString(result) && result) {
	        return createMessageWith(result);
	      }
	      else if (result === false) {
	        return createMessageWith(Model.ERROR_INVALID);
	      }
	    }
	     // check array items
	    if (isDefined && field.type == 'array' && (errorMessage = validateArrayField(field, value))) {
	      return createMessageWith(errorMessage);
	    }
	  }

	  function validateArrayField(field, arr) {
	    if (field.minItems && arr.length < field.minItems) {
	      return 'model.validation.field.array.minItems';
	    }
	    else if (field.maxItems && arr.length > field.maxItems) {
	      return 'model.validation.field.array.maxItems';
	    }
	    else if (field.uniqueItems && arr.length > _.uniq(arr).length) {
	      return Model.ERROR_IARRAY_UNIQUE;
	    }
	    else if (field.items) {
	      /* eslint max-depth: [2, 3] */
	      var arrayField = normalizeSchemaDef(field.items, 'placeholder');
	      for (var i = 0; i < arr.length; i++) {
	        var value = arr[i];
	        var error = validateField(arrayField, value);
	        if (error) {
	          return error['placeholder'];
	        }
	      }
	    }
	  }

	  Model = Backbone.Model.extend({

	    /**
	     * Pass props as an object to extend, describing the observable properties of your model. The props
	     * properties should not be set on an instance, as this won't define new properties, they should only be passed to
	     * extend.
	     * Properties can be defined in three different ways:
	     *
	     * - As a string with the expected dataType. One of string, number, boolean, array, object, date, or any.
	     * Eg: `name: 'string'`.
	     * - An array of `[dataType, required, default]`
	     * - An object `{type: 'string', format: '', required: true, value: '', values: [], validate: function() {}`
	     *   - `value` will be the value that the property will be set to if it is undefined, either by not being set during
	     *   initialization, or by being explicitly set to undefined.
	     *   - `format` is a json-schame derived string format. Supported formats are: `email`, `uri`, `hostname` and `ipv4`.
	     *   - If `required` is true, one of two things will happen. If a default is set for the property, the property will
	     *   start with that value. If a default is not set for the property, validation will fail
	     *   - If `values` array is passed, then you'll be able to change a property to one of those values only.
	     *   - If `validate` is defined, it should return false or a custom message string when the validation fails.
	     *   - If the type is defined as `array`, the array elements could be defined by `minItems` (Number),
	     *   `uniqueItems` (Boolean) and `items` (a field definition such as this one that will validate each array member)
	     *   To the `validate` method
	     *   - Trying to set a property to an invalid type will raise an exception.
	     *
	     * ```javascript
	     * var Person = Model.extend({
	     *   props: {
	     *     name: 'string',
	     *     age: 'number',
	     *     paying: ['boolean', true, false], //required attribute, defaulted to false
	     *     type: {
	     *       type: 'string',
	     *       values: ['regular-hero', 'super-hero', 'mega-hero']
	     *     },
	     *     likes: {
	     *       type: 'string',
	     *       validate: function (value) {
	     *         return /^[\w]+ing$/.test(value)
	     *       }
	     *     }
	     *   }
	     * });
	     * ```
	     *
	     * @type {Mixed}
	     */
	    props: {},

	    /**
	     * Derived properties (also known as computed properties) are properties of the model that depend on the
	     * other (props, local or even derived properties to determine their value. Best demonstrated with an example:
	     *
	     * ```javascript
	     * var Person = Model.extend({
	     *   props: {
	     *     firstName: 'string',
	     *     lastName: 'string'
	     *   },
	     *   derived: {
	     *     fullName: {
	     *       deps: ['firstName', 'lastName'],
	     *       fn: function (firstName, lastName) {
	     *         return firstName + ' ' + lastName;
	     *       }
	     *     }
	     *   }
	     * });
	     *
	     * var person = new Person({ firstName: 'Phil', lastName: 'Roberts' })
	     * console.log(person.get('fullName')) //=> "Phil Roberts"
	     *
	     * person.set('firstName', 'Bob');
	     * console.log(person.get('fullName')) //=> "Bob Roberts"
	     * ```
	     *
	     * Each derived property, is defined as an object with the current properties:
	     *
	     * - `deps` {Array} - An array of property names which the derived property depends on.
	     * - `fn` {Function} - A function which returns the value of the computed property. It is called in the context of
	     * the current object, so that this is set correctly.
	     * - `cache` {Boolean} -  - Whether to cache the property. Uncached properties are computed every time they are
	     * accessed. Useful if it depends on the current time for example. Defaults to `true`.
	     *
	     * Derived properties are retrieved and fire change events just like any other property. They cannot be set
	     * directly.
	     * @type {Object}
	     */
	    derived: {},

	    /**
	     * local properties are defined and work in exactly the same way as {@link #props}, but generally only exist for
	     * the lifetime of the page.
	     * They would not typically be persisted to the server, and are not returned by calls to {@link #toJSON}.
	     *
	     * ```javascript
	     * var Person = Model.extend({
	     *   props: {
	     *     name: 'string',
	     *   },
	     *   local: {
	     *     isLoggedIn: 'boolean'
	     *   }
	     * );
	     * ```
	     * @type {Object}
	     */
	    local: {},

	    /**
	     * A boolean, a regexp or a predicate function to sanitize arbitrary extra model properties.
	     *
	     * Useful for embedded values such as [HAL](http://stateless.co/hal_specification.html) `_links` and `_embedded`.
	     *
	     * ```javascript
	     * var Person = Model.extend({
	     *   flat: true, //defaults to true, emphasizing for this example
	     *   extraProperties: /^_(links|embedded)\./
	     * );
	     * model.set('_links', '/orders'); // => throws an error
	     * model.set('links.self.href', '/orders'); // => throws an error
	     * model.set('_links.self.href', '/orders'); //=> no error
	     * ```
	     * @type {Boolean|RegExp|Function}
	     */
	    extraProperties: false,


	    /**
	    * Flatten the payload into dot notation string keys:
	    *
	    * ```javascript
	    * var Person = Model.extend({
	    *   props: {
	    *     'profile.fname': 'string',
	    *     'profile.lname': 'string',
	    *     'profile.languages': 'object'
	    *   },
	    *   flat: true
	    * });
	    * var person = new Person({'profile': {
	    *                            'fname': 'John',
	    *                            'lname': 'Doe',
	    *                            'languages': {name: "English", value: "EN"}
	    *                         }}, {parse: true});
	    * person.get('profile'); //=> undefined
	    * person.get('profile.fname'); //=> 'John'
	    * person.get('profile.lname'); //=> 'Doe'
	    * person.get('profile.languages'); //=> {name: "English", value: "EN"}
	    * person.get('profile.languages.name'); //=> undefined
	    * person.toJSON(); //=> {'profile': {'fname': 'John'} }
	    * ```
	     * @type {Boolean}
	     */
	    flat: true,

	    /**
	     * @deprecated
	     * @alias Backbone.Model#defaults
	     */
	    defaults: {},

	    /**
	    * @constructor
	    * @param {Object} [attributes] - Initial model attributes (data)
	    * @param {Object} [options] - Options hash
	    */
	    constructor: function (options) {
	      this.options = options || {};

	      var schema = this['__schema__'] = {},
	          objectTypeFields = [];

	      schema.computedProperties = {};

	      schema.extraProperties = this.extraProperties;
	      schema.props = _.clone(_.result(this, 'props') || {});
	      schema.derived = _.clone(_.result(this, 'derived') || {});
	      schema.local = _.clone(_.result(this, 'local') || {});

	      var defaults = {};
	      _.each(_.extend({}, schema.props, schema.local), function (options, name) {
	        var schemaDef = normalizeSchemaDef(options, name);
	        if (!_.isUndefined(schemaDef.value)) {
	          defaults[name] = schemaDef.value;
	        }
	        if (schemaDef.type === 'object') {
	          objectTypeFields.push(name);
	        }
	      }, this);
	      if (_.size(defaults)) {
	        var localDefaults = _.result(this, 'defaults');
	        this.defaults = function () {
	          return _.defaults({}, defaults, localDefaults);
	        };
	      }

	      // override `validate`
	      this.validate = _.wrap(this.validate, function (validate) {
	        var args = _.rest(arguments),
	            res = _.extend(this._validateSchema.apply(this, args), validate.apply(this, args));
	        return _.size(res) && res || undefined;
	      });

	      // override `parse`
	      this.parse = _.wrap(this.parse, function (parse) {
	        var target = parse.apply(this, _.rest(arguments));
	        if (this.flat) {
	          target = flatten(target, objectTypeFields);
	        }
	        return target;
	      });

	      Backbone.Model.apply(this, arguments);

	      _.each(schema.derived, function (options, name) {
	        schema.computedProperties[name] = this.__getDerivedValue(name); // set initial value;
	        var deps = options.deps || [];
	        if (deps.length) {
	          this.on('cache:clear change:' + deps.join(' change:'), function () {
	            var value = this.__getDerivedValue(name);
	            if (value !== schema.computedProperties[name]) {
	              schema.computedProperties[name] = value;
	              this.trigger('change:' + name, this, value);
	            }
	          }, this);
	        }
	      }, this);

	      this.on('sync', function () {
	        this.__syncedData = this.toJSON();
	      }, this);
	    },

	    validate: function () {},

	    /**
	     * Check if the schema settings allow this field to exist in the model
	     * @param  {String} key
	     * @return {Boolean}
	     */
	    allows: function (key) {
	      var schema = this['__schema__'],
	          all = _.extend({}, schema.props, schema.local);
	      if (_.has(all, key)) {
	        return true;
	      }
	      else if (allowExtraProperties.call(this, schema.extraProperties, key)) {
	        return true;
	      }
	      else {
	        return false;
	      }
	    },

	    /**
	     * Returns the schema for the specific property
	     *
	     * @param propName - The name of the property
	     * @returns {*} | null
	     */
	    getPropertySchema: function (propName) {
	      var schema = this['__schema__'];
	      return _.reduce([schema.props, schema.local], function (result, options) {
	        return result || normalizeSchemaDef(options[propName], propName);
	      }, null);
	    },

	    set: function (key, val) {
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	      } else {
	        (attrs = {})[key] = val;
	      }

	       // Don't override a computed properties
	      _.each(attrs, function (value, key) {
	        if (_.has(this['__schema__'].derived, key)) {
	          throw 'overriding derived properties is not supported: ' + key;
	        }
	      }, this);

	      // Schema validation
	      var errorFields = [];
	      _.each(attrs, function (value, key) {
	        this.allows(key) || errorFields.push(key);
	      }, this);
	      if (errorFields.length) {
	        throw 'field not allowed: ' + errorFields.join(', ');
	      }

	      return Backbone.Model.prototype.set.apply(this, arguments);
	    },

	    get: function (attr) {
	      var schema = this['__schema__'];
	      if (_.has(schema.derived, attr)) {
	        if (schema.derived[attr].cache !== false) {
	          return schema.computedProperties[attr];
	        }
	        else {
	          return this.__getDerivedValue(attr);
	        }
	      }
	      return Backbone.Model.prototype.get.apply(this, arguments);
	    },

	    /**
	     * Return a shallow copy of the model's attributes for JSON stringification.
	     * This can be used for persistence, serialization, or for augmentation before being sent to the server.
	     * The name of this method is a bit confusing, as it doesn't actually return a JSON string —
	     *  but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.
	     *
	     * ```javascript
	     * var artist = new Model({
	     *   firstName: 'Wassily',
	     *   lastName: 'Kandinsky'
	     * });
	     *
	     * artist.set({birthday: 'December 16, 1866'});
	     * JSON.stringify(artist); //=> {'firstName':'Wassily','lastName':'Kandinsky','birthday':'December 16, 1866'}
	     * ```
	     * See [Backbone.Model.toJSON](http://backbonejs.org/#Model-toJSON)
	     * @param  {Object} options
	     * @return {Object}
	     */
	    toJSON: function (options) {
	      options || (options = {});
	      var res = _.clone(Backbone.Model.prototype.toJSON.apply(this, arguments)),
	          schema = this['__schema__'];

	      // cleanup local properties
	      if (!options.verbose) {
	        res = _.omit(res, _.keys(schema.local));
	      }
	      else { // add derived properties
	        _.each(schema.derived, function (options, name) {
	          res[name] = this.get(name);
	        }, this);
	      }

	      if (this.flat) {
	        res = unflatten(res);
	      }

	      return res;
	    },

	    /**
	     * Removes all attributes from the model, including the id attribute.
	     * Fires a `"change"` event unless `silent` is passed as an option.
	     * Sets the default values to the model
	     * @param {Object} [options]
	     */
	    reset: function (options) {
	      this.clear(options);
	      this.set(_.result(this, 'defaults'), options);
	    },

	    /**
	     * Is the data on the model has local modifications since the last sync event?
	     * @return {Boolean} is the model in sync with the server
	     */
	    isSynced: function () {
	      return _.isEqual(this.__syncedData, this.toJSON());
	    },

	    /**
	     * validate a specific field in the model.
	     * @param  {String} key
	     * @return {Object} returns `{fieldName: errorMessage}` if invalid, otherwise undefined.
	     * @readonly
	     */
	    validateField: function (key) {
	      var schema = key && this.getPropertySchema(key);
	      return schema && validateField(schema, this.get(key));
	    },

	    /**
	     * Runs local schema validation. Invoked internally by {@link #validate}.
	     * @return {Object}
	     * @protected
	     */
	    _validateSchema: function () {
	      var schema = this['__schema__'];
	      return _.reduce(_.extend({}, schema.props, schema.local), function (memo, options, name) {
	        return _.extend(memo, this.validateField(name) || {});
	      }, {}, this);
	    },

	    __getDerivedValue: function (name) {
	      var options = this['__schema__'].derived[name];
	      if (_.isString(options)) {
	        var key = options;
	        options = {
	          deps: [key],
	          fn: function () {
	            return this.get(key);
	          }
	        };
	      }
	      var deps = options.deps || [];
	      return options.fn.apply(this, _.map(deps, this.get, this));
	    }

	  },
	    {
	      ERROR_BLANK: 'model.validation.field.blank',
	      ERROR_WRONG_TYPE: 'model.validation.field.wrong.type',
	      ERROR_NOT_ALLOWED: 'model.validation.field.value.not.allowed',
	      ERROR_INVALID: 'model.validation.field.invalid',
	      ERROR_IARRAY_UNIQUE: 'model.validation.field.array.unique',
	      ERROR_INVALID_FORMAT_EMAIL: 'model.validation.field.invalid.format.email',
	      ERROR_INVALID_FORMAT_URI: 'model.validation.field.invalid.format.uri',
	      ERROR_INVALID_FORMAT_IPV4: 'model.validation.field.invalid.format.ipv4',
	      ERROR_INVALID_FORMAT_HOSTNAME: 'model.validation.field.invalid.format.hostname',
	      ERROR_STRING_STRING_MIN_LENGTH: 'model.validation.field.string.minLength',
	      ERROR_STRING_STRING_MAX_LENGTH: 'model.validation.field.string.maxLength'
	    }
	  );

	  return Model;

	}));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {//     Backbone.js 1.2.1

	//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org

	(function(factory) {

	  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
	  // We use `self` instead of `window` for `WebWorker` support.
	  var root = (typeof self == 'object' && self.self == self && self) ||
	            (typeof global == 'object' && global.global == global && global);

	  // Set up Backbone appropriately for the environment. Start with AMD.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(6), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
	      // Export global even in AMD case in case this script is loaded with
	      // others that may still expect a global Backbone.
	      root.Backbone = factory(root, exports, _, $);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
	  } else if (typeof exports !== 'undefined') {
	    var _ = require('underscore'), $;
	    try { $ = require('jquery'); } catch(e) {}
	    factory(root, exports, _, $);

	  // Finally, as a browser global.
	  } else {
	    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
	  }

	}(function(root, Backbone, _, $) {

	  // Initial Setup
	  // -------------

	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;

	  // Create a local reference to a common array method we'll want to use later.
	  var slice = [].slice;

	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.2.1';

	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = $;

	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };

	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;

	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... this will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;

	  // Proxy Underscore methods to a Backbone class' prototype using a
	  // particular attribute as the data argument
	  var addMethod = function(length, method, attribute) {
	    switch (length) {
	      case 1: return function() {
	        return _[method](this[attribute]);
	      };
	      case 2: return function(value) {
	        return _[method](this[attribute], value);
	      };
	      case 3: return function(iteratee, context) {
	        return _[method](this[attribute], iteratee, context);
	      };
	      case 4: return function(iteratee, defaultVal, context) {
	        return _[method](this[attribute], iteratee, defaultVal, context);
	      };
	      default: return function() {
	        var args = slice.call(arguments);
	        args.unshift(this[attribute]);
	        return _[method].apply(_, args);
	      };
	    }
	  };
	  var addUnderscoreMethods = function(Class, methods, attribute) {
	    _.each(methods, function(length, method) {
	      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
	    });
	  };

	  // Backbone.Events
	  // ---------------

	  // A module that can be mixed in to *any object* in order to provide it with
	  // custom events. You may bind with `on` or remove with `off` callback
	  // functions to an event; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {};

	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;

	  // Iterates over the standard `event, callback` (as well as the fancy multiple
	  // space-separated events `"change blur", callback` and jQuery-style event
	  // maps `{event: callback}`), reducing them by manipulating `memo`.
	  // Passes a normalized single event name and callback, as well as any
	  // optional `opts`.
	  var eventsApi = function(iteratee, memo, name, callback, opts) {
	    var i = 0, names;
	    if (name && typeof name === 'object') {
	      // Handle event maps.
	      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
	      for (names = _.keys(name); i < names.length ; i++) {
	        memo = iteratee(memo, names[i], name[names[i]], opts);
	      }
	    } else if (name && eventSplitter.test(name)) {
	      // Handle space separated event names.
	      for (names = name.split(eventSplitter); i < names.length; i++) {
	        memo = iteratee(memo, names[i], callback, opts);
	      }
	    } else {
	      memo = iteratee(memo, name, callback, opts);
	    }
	    return memo;
	  };

	  // Bind an event to a `callback` function. Passing `"all"` will bind
	  // the callback to all events fired.
	  Events.on = function(name, callback, context) {
	    return internalOn(this, name, callback, context);
	  };

	  // An internal use `on` function, used to guard the `listening` argument from
	  // the public API.
	  var internalOn = function(obj, name, callback, context, listening) {
	    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
	        context: context,
	        ctx: obj,
	        listening: listening
	    });

	    if (listening) {
	      var listeners = obj._listeners || (obj._listeners = {});
	      listeners[listening.id] = listening;
	    }

	    return obj;
	  };

	  // Inversion-of-control versions of `on`. Tell *this* object to listen to
	  // an event in another object... keeping track of what it's listening to.
	  Events.listenTo =  function(obj, name, callback) {
	    if (!obj) return this;
	    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
	    var listeningTo = this._listeningTo || (this._listeningTo = {});
	    var listening = listeningTo[id];

	    // This object is not listening to any other events on `obj` yet.
	    // Setup the necessary references to track the listening callbacks.
	    if (!listening) {
	      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
	      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
	    }

	    // Bind callbacks on obj, and keep track of them on listening.
	    internalOn(obj, name, callback, this, listening);
	    return this;
	  };

	  // The reducing API that adds a callback to the `events` object.
	  var onApi = function(events, name, callback, options) {
	    if (callback) {
	      var handlers = events[name] || (events[name] = []);
	      var context = options.context, ctx = options.ctx, listening = options.listening;
	      if (listening) listening.count++;

	      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
	    }
	    return events;
	  };

	  // Remove one or many callbacks. If `context` is null, removes all
	  // callbacks with that function. If `callback` is null, removes all
	  // callbacks for the event. If `name` is null, removes all bound
	  // callbacks for all events.
	  Events.off =  function(name, callback, context) {
	    if (!this._events) return this;
	    this._events = eventsApi(offApi, this._events, name, callback, {
	        context: context,
	        listeners: this._listeners
	    });
	    return this;
	  };

	  // Tell this object to stop listening to either specific events ... or
	  // to every object it's currently listening to.
	  Events.stopListening =  function(obj, name, callback) {
	    var listeningTo = this._listeningTo;
	    if (!listeningTo) return this;

	    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

	    for (var i = 0; i < ids.length; i++) {
	      var listening = listeningTo[ids[i]];

	      // If listening doesn't exist, this object is not currently
	      // listening to obj. Break out early.
	      if (!listening) break;

	      listening.obj.off(name, callback, this);
	    }
	    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

	    return this;
	  };

	  // The reducing API that removes a callback from the `events` object.
	  var offApi = function(events, name, callback, options) {
	    // No events to consider.
	    if (!events) return;

	    var i = 0, listening;
	    var context = options.context, listeners = options.listeners;

	    // Delete all events listeners and "drop" events.
	    if (!name && !callback && !context) {
	      var ids = _.keys(listeners);
	      for (; i < ids.length; i++) {
	        listening = listeners[ids[i]];
	        delete listeners[listening.id];
	        delete listening.listeningTo[listening.objId];
	      }
	      return;
	    }

	    var names = name ? [name] : _.keys(events);
	    for (; i < names.length; i++) {
	      name = names[i];
	      var handlers = events[name];

	      // Bail out if there are no events stored.
	      if (!handlers) break;

	      // Replace events if there are any remaining.  Otherwise, clean up.
	      var remaining = [];
	      for (var j = 0; j < handlers.length; j++) {
	        var handler = handlers[j];
	        if (
	          callback && callback !== handler.callback &&
	            callback !== handler.callback._callback ||
	              context && context !== handler.context
	        ) {
	          remaining.push(handler);
	        } else {
	          listening = handler.listening;
	          if (listening && --listening.count === 0) {
	            delete listeners[listening.id];
	            delete listening.listeningTo[listening.objId];
	          }
	        }
	      }

	      // Update tail event if the list has any events.  Otherwise, clean up.
	      if (remaining.length) {
	        events[name] = remaining;
	      } else {
	        delete events[name];
	      }
	    }
	    if (_.size(events)) return events;
	  };

	  // Bind an event to only be triggered a single time. After the first time
	  // the callback is invoked, it will be removed. When multiple events are
	  // passed in using the space-separated syntax, the event will fire once for every
	  // event you passed in, not once for a combination of all events
	  Events.once =  function(name, callback, context) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
	    return this.on(events, void 0, context);
	  };

	  // Inversion-of-control versions of `once`.
	  Events.listenToOnce =  function(obj, name, callback) {
	    // Map the event into a `{event: once}` object.
	    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
	    return this.listenTo(obj, events);
	  };

	  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
	  // `offer` unbinds the `onceWrapper` after it has been called.
	  var onceMap = function(map, name, callback, offer) {
	    if (callback) {
	      var once = map[name] = _.once(function() {
	        offer(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	    }
	    return map;
	  };

	  // Trigger one or many events, firing all bound callbacks. Callbacks are
	  // passed the same arguments as `trigger` is, apart from the event name
	  // (unless you're listening on `"all"`, which will cause your callback to
	  // receive the true name of the event as the first argument).
	  Events.trigger =  function(name) {
	    if (!this._events) return this;

	    var length = Math.max(0, arguments.length - 1);
	    var args = Array(length);
	    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

	    eventsApi(triggerApi, this._events, name, void 0, args);
	    return this;
	  };

	  // Handles triggering the appropriate event callbacks.
	  var triggerApi = function(objEvents, name, cb, args) {
	    if (objEvents) {
	      var events = objEvents[name];
	      var allEvents = objEvents.all;
	      if (events && allEvents) allEvents = allEvents.slice();
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, [name].concat(args));
	    }
	    return objEvents;
	  };

	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
	    }
	  };

	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;

	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);

	  // Backbone.Model
	  // --------------

	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.

	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId(this.cidPrefix);
	    this.attributes = {};
	    if (options.collection) this.collection = options.collection;
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };

	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {

	    // A hash of attributes whose current and previous value differ.
	    changed: null,

	    // The value returned during the last failed validation.
	    validationError: null,

	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',

	    // The prefix is used to create the client id which is used to identify models locally.
	    // You may want to override this if you're experiencing name clashes with model ids.
	    cidPrefix: 'c',

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },

	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },

	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },

	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },

	    // Special-cased proxy to underscore's `_.matches` method.
	    matches: function(attrs) {
	      return !!_.iteratee(attrs, this)(this.attributes);
	    },

	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      if (key == null) return this;

	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options || (options = {});

	      // Run validation.
	      if (!this._validate(attrs, options)) return false;

	      // Extract attributes and options.
	      var unset      = options.unset;
	      var silent     = options.silent;
	      var changes    = [];
	      var changing   = this._changing;
	      this._changing = true;

	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }

	      var current = this.attributes;
	      var changed = this.changed;
	      var prev    = this._previousAttributes;

	      // Check for changes of `id`.
	      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

	      // For each `set` attribute, update or delete the current value.
	      for (var attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          changed[attr] = val;
	        } else {
	          delete changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }

	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = options;
	        for (var i = 0; i < changes.length; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }

	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          options = this._pending;
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },

	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },

	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },

	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },

	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      var changed = {};
	      for (var attr in diff) {
	        var val = diff[attr];
	        if (_.isEqual(old[attr], val)) continue;
	        changed[attr] = val;
	      }
	      return _.size(changed) ? changed : false;
	    },

	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },

	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },

	    // Fetch the model from the server, merging the response with the model's
	    // local attributes. Any changed attributes will trigger a "change" event.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (!model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      var attrs;
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options = _.extend({validate: true, parse: true}, options);
	      var wait = options.wait;

	      // If we're not waiting and attributes exist, save acts as
	      // `set(attr).save(null, opts)` with validation. Otherwise, check if
	      // the model will be valid when the attributes, if any, are set.
	      if (attrs && !wait) {
	        if (!this.set(attrs, options)) return false;
	      } else {
	        if (!this._validate(attrs, options)) return false;
	      }

	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      var model = this;
	      var success = options.success;
	      var attributes = this.attributes;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
	        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
	        if (serverAttrs && !model.set(serverAttrs, options)) return false;
	        if (success) success.call(options.context, model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);

	      // Set temporary attributes if `{wait: true}` to properly find new ids.
	      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

	      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch' && !options.attrs) options.attrs = attrs;
	      var xhr = this.sync(method, this, options);

	      // Restore attributes.
	      this.attributes = attributes;

	      return xhr;
	    },

	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;
	      var wait = options.wait;

	      var destroy = function() {
	        model.stopListening();
	        model.trigger('destroy', model, model.collection, options);
	      };

	      options.success = function(resp) {
	        if (wait) destroy();
	        if (success) success.call(options.context, model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };

	      var xhr = false;
	      if (this.isNew()) {
	        _.defer(options.success);
	      } else {
	        wrapError(this, options);
	        xhr = this.sync('delete', this, options);
	      }
	      if (!wait) destroy();
	      return xhr;
	    },

	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base =
	        _.result(this, 'urlRoot') ||
	        _.result(this.collection, 'url') ||
	        urlError();
	      if (this.isNew()) return base;
	      var id = this.get(this.idAttribute);
	      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
	    },

	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },

	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return !this.has(this.idAttribute);
	    },

	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.defaults({validate: true}, options));
	    },

	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
	      return false;
	    }

	  });

	  // Underscore methods that we want to implement on the Model.
	  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
	      omit: 0, chain: 1, isEmpty: 1 };

	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  addUnderscoreMethods(Model, modelMethods, 'attributes');

	  // Backbone.Collection
	  // -------------------

	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analogous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.

	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };

	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, remove: false};

	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {

	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model) { return model.toJSON(options); });
	    },

	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Add a model, or list of models to the set.
	    add: function(models, options) {
	      return this.set(models, _.extend({merge: false}, options, addOptions));
	    },

	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      options = _.extend({}, options);
	      var singular = !_.isArray(models);
	      models = singular ? [models] : _.clone(models);
	      var removed = this._removeModels(models, options);
	      if (!options.silent && removed) this.trigger('update', this, options);
	      return singular ? removed[0] : removed;
	    },

	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      options = _.defaults({}, options, setOptions);
	      if (options.parse && !this._isModel(models)) models = this.parse(models, options);
	      var singular = !_.isArray(models);
	      models = singular ? (models ? [models] : []) : models.slice();
	      var id, model, attrs, existing, sort;
	      var at = options.at;
	      if (at != null) at = +at;
	      if (at < 0) at += this.length + 1;
	      var sortable = this.comparator && (at == null) && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
	      var toAdd = [], toRemove = [], modelMap = {};
	      var add = options.add, merge = options.merge, remove = options.remove;
	      var order = !sortable && add && remove ? [] : false;
	      var orderChanged = false;

	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      for (var i = 0; i < models.length; i++) {
	        attrs = models[i];

	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        if (existing = this.get(attrs)) {
	          if (remove) modelMap[existing.cid] = true;
	          if (merge && attrs !== existing) {
	            attrs = this._isModel(attrs) ? attrs.attributes : attrs;
	            if (options.parse) attrs = existing.parse(attrs, options);
	            existing.set(attrs, options);
	            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
	          }
	          models[i] = existing;

	        // If this is a new, valid model, push it to the `toAdd` list.
	        } else if (add) {
	          model = models[i] = this._prepareModel(attrs, options);
	          if (!model) continue;
	          toAdd.push(model);
	          this._addReference(model, options);
	        }

	        // Do not add multiple models with the same `id`.
	        model = existing || model;
	        if (!model) continue;
	        id = this.modelId(model.attributes);
	        if (order && (model.isNew() || !modelMap[id])) {
	          order.push(model);

	          // Check to see if this is actually a new model at this index.
	          orderChanged = orderChanged || !this.models[i] || model.cid !== this.models[i].cid;
	        }

	        modelMap[id] = true;
	      }

	      // Remove nonexistent models if appropriate.
	      if (remove) {
	        for (var i = 0; i < this.length; i++) {
	          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this._removeModels(toRemove, options);
	      }

	      // See if sorting is needed, update `length` and splice in new models.
	      if (toAdd.length || orderChanged) {
	        if (sortable) sort = true;
	        this.length += toAdd.length;
	        if (at != null) {
	          for (var i = 0; i < toAdd.length; i++) {
	            this.models.splice(at + i, 0, toAdd[i]);
	          }
	        } else {
	          if (order) this.models.length = 0;
	          var orderedModels = order || toAdd;
	          for (var i = 0; i < orderedModels.length; i++) {
	            this.models.push(orderedModels[i]);
	          }
	        }
	      }

	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});

	      // Unless silenced, it's time to fire all appropriate add/sort events.
	      if (!options.silent) {
	        var addOpts = at != null ? _.clone(options) : options;
	        for (var i = 0; i < toAdd.length; i++) {
	          if (at != null) addOpts.index = at + i;
	          (model = toAdd[i]).trigger('add', model, this, addOpts);
	        }
	        if (sort || orderChanged) this.trigger('sort', this, options);
	        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
	      }

	      // Return the added (or merged) model (or models).
	      return singular ? models[0] : models;
	    },

	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options = options ? _.clone(options) : {};
	      for (var i = 0; i < this.models.length; i++) {
	        this._removeReference(this.models[i], options);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      models = this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return models;
	    },

	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      return this.add(model, _.extend({at: this.length}, options));
	    },

	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      return this.remove(model, options);
	    },

	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      return this.add(model, _.extend({at: 0}, options));
	    },

	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      return this.remove(model, options);
	    },

	    // Slice out a sub-array of models from the collection.
	    slice: function() {
	      return slice.apply(this.models, arguments);
	    },

	    // Get a model from the set by id.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
	      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
	    },

	    // Get the model at the given index.
	    at: function(index) {
	      if (index < 0) index += this.length;
	      return this.models[index];
	    },

	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      var matches = _.matches(attrs);
	      return this[first ? 'find' : 'filter'](function(model) {
	        return matches(model.attributes);
	      });
	    },

	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },

	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});

	      // Run sort based on type of `comparator`.
	      if (_.isString(this.comparator) || this.comparator.length === 1) {
	        this.models = this.sortBy(this.comparator, this);
	      } else {
	        this.models.sort(_.bind(this.comparator, this));
	      }

	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },

	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return _.invoke(this.models, 'get', attr);
	    },

	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = _.extend({parse: true}, options);
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success.call(options.context, collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      var wait = options.wait;
	      model = this._prepareModel(model, options);
	      if (!model) return false;
	      if (!wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(model, resp, callbackOpts) {
	        if (wait) collection.add(model, callbackOpts);
	        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
	      };
	      model.save(null, options);
	      return model;
	    },

	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models, {
	        model: this.model,
	        comparator: this.comparator
	      });
	    },

	    // Define how to uniquely identify models in the collection.
	    modelId: function (attrs) {
	      return attrs[this.model.prototype.idAttribute || 'id'];
	    },

	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },

	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (this._isModel(attrs)) {
	        if (!attrs.collection) attrs.collection = this;
	        return attrs;
	      }
	      options = options ? _.clone(options) : {};
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model.validationError) return model;
	      this.trigger('invalid', this, model.validationError, options);
	      return false;
	    },

	    // Internal method called by both remove and set.
	    // Returns removed models, or false if nothing is removed.
	    _removeModels: function(models, options) {
	      var removed = [];
	      for (var i = 0; i < models.length; i++) {
	        var model = this.get(models[i]);
	        if (!model) continue;

	        var index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;

	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }

	        removed.push(model);
	        this._removeReference(model, options);
	      }
	      return removed.length ? removed : false;
	    },

	    // Method for checking whether an object should be considered a model for
	    // the purposes of adding to the collection.
	    _isModel: function (model) {
	      return model instanceof Model;
	    },

	    // Internal method to create a model's ties to a collection.
	    _addReference: function(model, options) {
	      this._byId[model.cid] = model;
	      var id = this.modelId(model.attributes);
	      if (id != null) this._byId[id] = model;
	      model.on('all', this._onModelEvent, this);
	    },

	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model, options) {
	      delete this._byId[model.cid];
	      var id = this.modelId(model.attributes);
	      if (id != null) delete this._byId[id];
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },

	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if ((event === 'add' || event === 'remove') && collection !== this) return;
	      if (event === 'destroy') this.remove(model, options);
	      if (event === 'change') {
	        var prevId = this.modelId(model.previousAttributes());
	        var id = this.modelId(model.attributes);
	        if (prevId !== id) {
	          if (prevId != null) delete this._byId[prevId];
	          if (id != null) this._byId[id] = model;
	        }
	      }
	      this.trigger.apply(this, arguments);
	    }

	  });

	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
	      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
	      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 2,
	      contains: 2, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
	      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
	      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
	      isEmpty: 1, chain: 1, sample: 3, partition: 3 };

	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  addUnderscoreMethods(Collection, collectionMethods, 'models');

	  // Underscore methods that take a property name as an argument.
	  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

	  // Use attributes instead of properties.
	  _.each(attributeMethods, function(method) {
	    if (!_[method]) return;
	    Collection.prototype[method] = function(value, context) {
	      var iterator = _.isFunction(value) ? value : function(model) {
	        return model.get(value);
	      };
	      return _[method](this.models, iterator, context);
	    };
	  });

	  // Backbone.View
	  // -------------

	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.

	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    _.extend(this, _.pick(options, viewOptions));
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	  // List of view options to be merged as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {

	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',

	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be preferred to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },

	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this._removeElement();
	      this.stopListening();
	      return this;
	    },

	    // Remove this view's element from the document and all event listeners
	    // attached to it. Exposed for subclasses using an alternative DOM
	    // manipulation API.
	    _removeElement: function() {
	      this.$el.remove();
	    },

	    // Change the view's element (`this.el` property) and re-delegate the
	    // view's events on the new element.
	    setElement: function(element) {
	      this.undelegateEvents();
	      this._setElement(element);
	      this.delegateEvents();
	      return this;
	    },

	    // Creates the `this.el` and `this.$el` references for this view using the
	    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
	    // context or an element. Subclasses can override this to utilize an
	    // alternative DOM manipulation API and are only required to set the
	    // `this.el` property.
	    _setElement: function(el) {
	      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
	      this.el = this.$el[0];
	    },

	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save',
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    delegateEvents: function(events) {
	      events || (events = _.result(this, 'events'));
	      if (!events) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[method];
	        if (!method) continue;
	        var match = key.match(delegateEventSplitter);
	        this.delegate(match[1], match[2], _.bind(method, this));
	      }
	      return this;
	    },

	    // Add a single event listener to the view's element (or a child element
	    // using `selector`). This only works for delegate-able events: not `focus`,
	    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
	    delegate: function(eventName, selector, listener) {
	      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Clears all callbacks previously bound to the view by `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },

	    // A finer-grained `undelegateEvents` for removing a single delegated event.
	    // `selector` and `listener` are both optional.
	    undelegate: function(eventName, selector, listener) {
	      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
	      return this;
	    },

	    // Produces a DOM element to be assigned to your view. Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _createElement: function(tagName) {
	      return document.createElement(tagName);
	    },

	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        this.setElement(this._createElement(_.result(this, 'tagName')));
	        this._setAttributes(attrs);
	      } else {
	        this.setElement(_.result(this, 'el'));
	      }
	    },

	    // Set attributes from a hash on this view's element.  Exposed for
	    // subclasses using an alternative DOM manipulation API.
	    _setAttributes: function(attributes) {
	      this.$el.attr(attributes);
	    }

	  });

	  // Backbone.sync
	  // -------------

	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];

	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });

	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};

	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }

	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }

	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }

	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }

	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }

	    // Pass along `textStatus` and `errorThrown` from jQuery.
	    var error = options.error;
	    options.error = function(xhr, textStatus, errorThrown) {
	      options.textStatus = textStatus;
	      options.errorThrown = errorThrown;
	      if (error) error.call(options.context, xhr, textStatus, errorThrown);
	    };

	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };

	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch':  'PATCH',
	    'delete': 'DELETE',
	    'read':   'GET'
	  };

	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };

	  // Backbone.Router
	  // ---------------

	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        if (router.execute(callback, args, name) !== false) {
	          router.trigger.apply(router, ['route:' + name].concat(args));
	          router.trigger('route', name, args);
	          Backbone.history.trigger('route', router, name, args);
	        }
	      });
	      return this;
	    },

	    // Execute a route handler with the provided parameters.  This is an
	    // excellent place to do pre-route setup or post-route cleanup.
	    execute: function(callback, args, name) {
	      if (callback) callback.apply(this, args);
	    },

	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },

	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },

	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	                   .replace(optionalParam, '(?:$1)?')
	                   .replace(namedParam, function(match, optional) {
	                     return optional ? match : '([^/?]+)';
	                   })
	                   .replace(splatParam, '([^?]*?)');
	      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
	    },

	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param, i) {
	        // Don't decode the search params.
	        if (i === params.length - 1) return param || null;
	        return param ? decodeURIComponent(param) : null;
	      });
	    }

	  });

	  // Backbone.History
	  // ----------------

	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    _.bindAll(this, 'checkUrl');

	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };

	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;

	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;

	  // Cached regex for stripping urls of hash.
	  var pathStripper = /#.*$/;

	  // Has the history handling already been started?
	  History.started = false;

	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {

	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,

	    // Are we at the app root?
	    atRoot: function() {
	      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
	      return path === this.root && !this.getSearch();
	    },

	    // Does the pathname match the root?
	    matchRoot: function() {
	      var path = this.decodeFragment(this.location.pathname);
	      var root = path.slice(0, this.root.length - 1) + '/';
	      return root === this.root;
	    },

	    // Unicode characters in `location.pathname` are percent encoded so they're
	    // decoded for comparison. `%25` should not be decoded since it may be part
	    // of an encoded parameter.
	    decodeFragment: function(fragment) {
	      return decodeURI(fragment.replace(/%25/g, '%2525'));
	    },

	    // In IE6, the hash fragment and search params are incorrect if the
	    // fragment contains `?`.
	    getSearch: function() {
	      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
	      return match ? match[0] : '';
	    },

	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },

	    // Get the pathname and search params, without the root.
	    getPath: function() {
	      var path = this.decodeFragment(
	        this.location.pathname + this.getSearch()
	      ).slice(this.root.length - 1);
	      return path.charAt(0) === '/' ? path.slice(1) : path;
	    },

	    // Get the cross-browser normalized URL fragment from the path or hash.
	    getFragment: function(fragment) {
	      if (fragment == null) {
	        if (this._usePushState || !this._wantsHashChange) {
	          fragment = this.getPath();
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },

	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error('Backbone.history has already been started');
	      History.started = true;

	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._hasHashChange   = 'onhashchange' in window;
	      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.history && this.history.pushState);
	      this._usePushState    = this._wantsPushState && this._hasPushState;
	      this.fragment         = this.getFragment();

	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

	      // Transition from hashChange to pushState or vice versa if both are
	      // requested.
	      if (this._wantsHashChange && this._wantsPushState) {

	        // If we've started off with a route from a `pushState`-enabled
	        // browser, but we're currently in a browser that doesn't support it...
	        if (!this._hasPushState && !this.atRoot()) {
	          var root = this.root.slice(0, -1) || '/';
	          this.location.replace(root + '#' + this.getPath());
	          // Return immediately as browser will do redirect to new url
	          return true;

	        // Or if we've started out with a hash-based route, but we're currently
	        // in a browser where it could be `pushState`-based instead...
	        } else if (this._hasPushState && this.atRoot()) {
	          this.navigate(this.getHash(), {replace: true});
	        }

	      }

	      // Proxy an iframe to handle location events if the browser doesn't
	      // support the `hashchange` event, HTML5 history, or the user wants
	      // `hashChange` but not `pushState`.
	      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
	        this.iframe = document.createElement('iframe');
	        this.iframe.src = 'javascript:0';
	        this.iframe.style.display = 'none';
	        this.iframe.tabIndex = -1;
	        var body = document.body;
	        // Using `appendChild` will throw on IE < 9 if the document is not ready.
	        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
	        iWindow.document.open();
	        iWindow.document.close();
	        iWindow.location.hash = '#' + this.fragment;
	      }

	      // Add a cross-platform `addEventListener` shim for older browsers.
	      var addEventListener = window.addEventListener || function (eventName, listener) {
	        return attachEvent('on' + eventName, listener);
	      };

	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._usePushState) {
	        addEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        addEventListener('hashchange', this.checkUrl, false);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }

	      if (!this.options.silent) return this.loadUrl();
	    },

	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      // Add a cross-platform `removeEventListener` shim for older browsers.
	      var removeEventListener = window.removeEventListener || function (eventName, listener) {
	        return detachEvent('on' + eventName, listener);
	      };

	      // Remove window listeners.
	      if (this._usePushState) {
	        removeEventListener('popstate', this.checkUrl, false);
	      } else if (this._useHashChange && !this.iframe) {
	        removeEventListener('hashchange', this.checkUrl, false);
	      }

	      // Clean up the iframe if necessary.
	      if (this.iframe) {
	        document.body.removeChild(this.iframe);
	        this.iframe = null;
	      }

	      // Some environments will throw when clearing an undefined interval.
	      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },

	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },

	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();

	      // If the user pressed the back button, the iframe's hash will have
	      // changed and we should use that for comparison.
	      if (current === this.fragment && this.iframe) {
	        current = this.getHash(this.iframe.contentWindow);
	      }

	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl();
	    },

	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragment) {
	      // If the root doesn't match, no routes can match either.
	      if (!this.matchRoot()) return false;
	      fragment = this.fragment = this.getFragment(fragment);
	      return _.any(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	    },

	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: !!options};

	      // Normalize the fragment.
	      fragment = this.getFragment(fragment || '');

	      // Don't include a trailing slash on the root.
	      var root = this.root;
	      if (fragment === '' || fragment.charAt(0) === '?') {
	        root = root.slice(0, -1) || '/';
	      }
	      var url = root + fragment;

	      // Strip the hash and decode for matching.
	      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

	      if (this.fragment === fragment) return;
	      this.fragment = fragment;

	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._usePushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
	          var iWindow = this.iframe.contentWindow;

	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if (!options.replace) {
	            iWindow.document.open();
	            iWindow.document.close();
	          }

	          this._updateHash(iWindow.location, fragment, options.replace);
	        }

	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) return this.loadUrl(fragment);
	    },

	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }

	  });

	  // Create the default Backbone.history.
	  Backbone.history = new History;

	  // Helpers
	  // -------

	  // Helper function to correctly set up the prototype chain for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;

	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }

	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);

	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent` constructor function.
	    var Surrogate = function(){ this.constructor = child; };
	    Surrogate.prototype = parent.prototype;
	    child.prototype = new Surrogate;

	    // Add prototype properties (instance properties) to the subclass,
	    // if supplied.
	    if (protoProps) _.extend(child.prototype, protoProps);

	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;

	    return child;
	  };

	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };

	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function(model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error.call(options.context, model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };

	  return Backbone;

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(42)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Model) {

	  /**
	   * @class Okta.BaseModel
	   * @extends {Okta.Model}
	   * @deprecated Use `{@link Okta.Model}` instead
	   *
	   * ```javascript
	   * var Model = BaseModel.extend({
	   *   defaults: {
	   *     name: BaseModel.ComputedProperty(['fname', 'lname'], function (fname, lname) {
	   *       return fname + ' ' + lname;
	   *     })
	   *   }
	   * });
	   * var model = new Model({fname: 'Joe', lname: 'Doe'});
	   * model.get('name'); //=> "Joe Doe"
	   * model.toJSON(); //=> {fname: 'Joe', lname: 'Doe'}
	   *
	   * model.set('__private__', 'private property');
	   * model.get('__private__'); //=> "private property"
	   * model.toJSON(); //=> {fname: 'Joe', lname: 'Doe'}
	   * ```
	   */

	  var hasProps = function (model) {
	    var local = _.omit(model.local, _.keys(model._builtInLocalProps));
	    return _.size(model.props) + _.size(local) > 0;
	  };

	  var BaseModel = Model.extend({
	    /**
	     * @inheritdoc Okta.Model#flat
	     * @type {Boolean}
	     */
	    flat: false,

	    constructor: function () {
	      Model.apply(this, arguments);
	      this.on('sync', this._setSynced);
	    },

	    allows: function () {
	      if (hasProps(this)) {
	        return Model.prototype.allows.apply(this, arguments);
	      }
	      else {
	        return true;
	      }
	    },

	    // bw compatibility support for old computed properties
	    set: function (key, val) {
	      var attrs;
	      if (typeof key === 'object') {
	        attrs = key;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      // computed properties
	      _(attrs).each(function (fn, attr) {
	        if (!fn || !_.isArray(fn.__attributes)) { return; }
	        this.on('change:' + fn.__attributes.join(' change:'), function () {
	          var val = this.get(attr);
	          if (val !== this['__schema__'].computedProperties[attr]) {
	            this['__schema__'].computedProperties[attr] = val;
	            this.trigger('change:' + attr, val);
	          }
	        }, this);
	      }, this);

	      return Model.prototype.set.apply(this, arguments);
	    },

	    /**
	     * Get the current value of an attribute from the model. For example: `note.get("title")`
	     *
	     * See [Model.get](http://backbonejs.org/#Model-get)
	     * @param {String} attribute
	     * @return {Mixed} The value of the model attribute
	     */
	    get: function () {
	      var value = Model.prototype.get.apply(this, arguments);
	      if (_.isFunction(value)) {
	        return value.apply(this, _.map(value.__attributes || [], this.get, this));
	      }
	      return value;
	    },

	    /**
	     * Return a shallow copy of the model's attributes for JSON stringification.
	     * This can be used for persistence, serialization, or for augmentation before being sent to the server.
	     * The name of this method is a bit confusing, as it doesn't actually return a JSON string —
	     *  but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.
	     *
	     * ```javascript
	     * var artist = new Model({
	     *   firstName: "Wassily",
	     *   lastName: "Kandinsky"
	     * });
	     *
	     * artist.set({birthday: "December 16, 1866"});
	     * alert(JSON.stringify(artist)); // {"firstName":"Wassily","lastName":"Kandinsky","birthday":"December 16, 1866"}
	     * ```
	     * See [Model.toJSON](http://backbonejs.org/#Model-toJSON)
	     * @param  {Object} options
	     * @return {Object}
	     */
	    toJSON: function (options) {
	      options || (options = {});
	      var res = Model.prototype.toJSON.apply(this, arguments);

	      // cleanup computed properties
	      _(res).each(function (value, key) {
	        if (typeof value == 'function') {
	          if (options.verbose) {
	            res[key] = this.get(key);
	          } else {
	            delete res[key];
	          }
	        }
	      }, this);

	      // cleanup private properties
	      if (!options.verbose) {
	        _(res).each(function (value, key) {
	          if (/^__\w+__$/.test(key)) {
	            delete res[key];
	          }
	        });
	      }

	      return res;
	    },

	    sanitizeAttributes: function (attributes) {
	      var attrs = {};
	      _.each(attributes, function (value, key) {
	        if (!_.isFunction(value)) {
	          attrs[key] = value;
	        }
	      });
	      return attrs;
	    },

	    reset: function (options) {
	      this.clear(options);
	      this.set(this.sanitizeAttributes(this.defaults), options);
	    },

	    clear: function (options) {
	      var attrs = {};
	      _.each(this.sanitizeAttributes(this.attributes), function (value, key) {
	        attrs[key] = void 0;
	      });
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },

	    /**
	     * @private
	     */
	    _setSynced: function (newModel) {
	      this._syncedData = newModel && _.isFunction(newModel.toJSON) ? newModel.toJSON() : {};
	    },

	    /**
	     * @private
	     */
	    _getSynced: function () {
	      return this._syncedData;
	    },

	    isSynced: function () {
	      return _.isEqual(this._getSynced(), this.toJSON());
	    }
	  }, {
	    /**
	     * @static
	     *
	     * Example:
	     *
	     * ```javascript
	     * var Model = BaseModel.extend({
	     *   defaults: {
	     *     name: BaseModel.ComputedProperty(['fname', 'lname'], function (fname, lname) {
	     *       return fname + ' ' + lname;
	     *     })
	     *   }
	     * });
	     * var model = new Model({fname: 'Joe', lname: 'Doe'});
	     * model.get('name'); // Joe Doe
	     * model.toJSON(); // {fname: 'Joe', lname: 'Doe'}
	     * ```
	     *
	     * @param {Array} attributes - an array of the attribute names this method depends on
	     * @param {Function} callback the function that computes the value of the property
	     *
	     * @deprecated Use {@link #derived} instead
	     */
	    ComputedProperty: function () {
	      var args = _.toArray(arguments);
	      var fn = args.pop();
	      fn.__attributes = args.pop();
	      return fn;
	    }
	  });

	  return BaseModel;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(47)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Collection) {
	  /**
	  * @class Okta.Collection
	  * @extend Archer.Collection
	  * @inheritDoc Archer.Collection
	  */
	  return Collection.extend({

	    /**
	     * Is the end point using the legacy "secureJSON" format
	     * @type {Function|Boolean}
	     */
	    secureJSON: false,

	    constructor: function () {
	      if (_.result(this, 'secureJSON')) {
	        this.sync = _.wrap(this.sync, function (sync, method, collection, options) {
	          return sync.call(this, method, collection, _.extend({dataType: 'secureJSON'}, options));
	        });
	      }
	      Collection.apply(this, arguments);
	    }

	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(44)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  /* global module, exports */
	  else if (typeof require == 'function' && typeof exports == 'object') {
	    module.exports = factory(require('underscore'), require('backbone'));
	  }
	  else {
	    root.Archer || (root.Archer = {});
	    root.Archer.Collection = factory(root._, root.Backbone);
	  }
	}(this, function (_, Backbone) {
	  var STATE = '__STATE__',
	      FETCH_DATA = 'FETCH_DATA',
	      PAGINATION_DATA = 'PAGINATION_DATA',
	      DEFAULT_PARAMS = 'DEFAULT_PARAMS',
	      LINK_BY_HEADER = 'LINK_BY_HEADER',
	      XHR = 'XHR';

	  /*
	   * Sets the next page URL on the collection from link headers
	   * See: http://www.rfc-editor.org/rfc/rfc5988.txt
	   *
	   * This method is looking for a link header with `rel="next"`
	   * An set's it as the next page's URL.
	   *
	   * If it doesn't find a next page, and current page is set by a link header
	   * it assumes we are at the last page and deletes the current `next`
	   */
	  function setLinkHeadersPagination(collection, xhr) {
	    try {
	      var links = parseLinkHeader(xhr.getResponseHeader('link'));
	      collection[STATE].set(LINK_BY_HEADER, true);
	      collection.setPagination(links['next'].href);
	    }
	    catch (e) {
	      if (collection[STATE].get(LINK_BY_HEADER)) {
	        collection.setPagination(null);
	      }
	    }
	  }

	  function parseQuery(url) {
	    var params = {},
	        rawQueryStr = url && url.split('?')[1],
	        queryString = rawQueryStr && decodeURIComponent(rawQueryStr.split('#')[0]).replace(/\+/g, ' '),
	        props = queryString ? queryString.split('&') : [];
	    for (var i = 0; i < props.length; i++) {
	      var parts = props[i].split('=');
	      params[parts.shift()] = parts.join('=');
	    }
	    return params;
	  }

	  // ################################################
	  // # Source: https://gist.github.com/deiu/9335803
	  // ################################################

	  // unquote string (utility)
	  function unquote(value) {
	    if (value.charAt(0) == '"' && value.charAt(value.length - 1) == '"') {
	      return value.substring(1, value.length - 1);
	    }
	    return value;
	  }
	  /*
	  parse a Link header
	  Link:<https://example.org/.meta>; rel=meta
	  var r = parseLinkHeader(xhr.getResponseHeader('Link');
	  r['meta']['href'] outputs https://example.org/.meta
	  */
	  function parseLinkHeader(header) {
	    /* eslint max-statements: 0 */
	    var linkexp = /<[^>]*>\s*(\s*;\s*[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|$)/g,
	        paramexp = /[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g;

	    var matches = header.match(linkexp);
	    var rels = {};
	    for (var i = 0; i < matches.length; i++) {
	      var split = matches[i].split('>');
	      var href = split[0].substring(1);
	      var link = {};
	      link.href = href;
	      var s = split[1].match(paramexp);
	      for (var j = 0; j < s.length; j++) {
	        var paramsplit = s[j].split('=');
	        var name = paramsplit[0];
	        link[name] = unquote(paramsplit[1]);
	      }

	      if (link.rel !== undefined) {
	        rels[link.rel] = link;
	      }
	    }

	    return rels;
	  }

	  // ################################################
	  // # /Source
	  // ################################################
	  //

	  /**
	  * @class Archer.Collection
	  * @extend Backbone.Collection
	  *
	  * Archer.Collection is a standard [Backbone.Collection](http://backbonejs.org/#Collection) with pre-set `data`
	  * parameters and built in pagination - works with [http link headers](https://tools.ietf.org/html/rfc5988)
	  * out of the box:
	  *
	  * ```javascript
	  * var Users = Archer.Collection.extend({
	  *   url: '/api/v1/users'
	  *   params: {expand: true}
	  * });
	  * var users = new Users(null, {params: {type: 'new'}}),
	  *     $button = this.$('a.fetch-more');
	  *
	  * $button.click(function () {
	  *   users.fetchMore();
	  * });
	  *
	  * this.listenTo(users, 'sync', function () {
	  *   $button.toggle(users.hasMore());
	  * });
	  *
	  * collection.fetch(); //=> '/api/v1/users?expand=true&type=new'
	  *
	  * ```
	  */
	  return Backbone.Collection.extend({

	    /**
	     * Default fetch parametrers
	     * @type {Object}
	     */
	    params: {},

	    constructor: function (models, options) {
	      var state = this[STATE] = new Backbone.Model();
	      state.set(DEFAULT_PARAMS, _.defaults(options && options.params || {}, this.params || {}));
	      Backbone.Collection.apply(this, arguments);
	    },

	    sync: function (method, collection, options) {
	      var self = this,
	          success = options.success;
	      options.success = function (resp, status, xhr) {
	        // its important to set the pagination data *before* we call the success callback
	        // because we want the pagination data to be ready when the collection triggers the `sync` event
	        setLinkHeadersPagination(self, xhr);
	        success.apply(null, arguments);
	      };
	      return Backbone.Collection.prototype.sync.call(this, method, collection, options);
	    },

	    fetch: function (options) {
	      options || (options = {});
	      var state = this[STATE],
	          xhr = state.get(XHR);

	      options.data = _.extend({}, state.get(DEFAULT_PARAMS), options.data || {});
	      options.fromFetch = true;

	      state.set(FETCH_DATA, options.data);
	      if (xhr && xhr.abort && options.abort !== false) {
	        xhr.abort();
	      }
	      xhr = Backbone.Collection.prototype.fetch.call(this, options);
	      state.set(XHR, xhr);
	      return xhr;
	    },

	    /**
	     * Set pagination data to get to the next page
	     *
	     * ```javascript
	     * collection.setPagination({q: 'foo', page: '2'}); //=> {q: 'foo', page: '2'}
	     *
	     * collection.setPagination('/path/to/resource?q=baz&page=4'); //=> {q: 'baz', page: '4'}
	     *
	     * collection.setPagination('/path/to/resource'); //=> {}
	     *
	     * collection.fetch({data: {q: 'foo'}});
	     * collection.setPagination({page: 2}, {fromFetch: true}); //=> {q: 'foo', page: 2}
	     *
	     * any "falsy" value resets pagination
	     * collection.setPagination(); //=> {}
	     * collection.setPagination(null); //=> {}
	     * collection.setPagination(false); //=> {}
	     * collection.setPagination(''); //=> {}
	     * collection.setPagination(0); //=> {}
	     * ```
	     *
	     * @param {Mixed} params
	     * @param {Object} [options]
	     * @param {Boolean} [options.fromFetch] should we include data from the previous fetch call in this object
	     * @protected
	     *
	     */
	    setPagination: function (params, options) {
	      if (_.isString(params) && params) {
	        params = parseQuery(params);
	      }
	      if (!_.isObject(params) || _.isArray(params) || !_.size(params)) {
	        params = null;
	      }
	      else if (options && options.fromFetch) {
	        params = _.extend({}, this.getFetchData(), params);
	      }
	      this[STATE].set(PAGINATION_DATA, params);
	    },

	    /**
	     * Returns the `data` parameters applied in th most recent `fetch` call
	     * It will include parameters set by {@link #params} and optios.params passed to the constructor
	     * @return {Object}
	     * @protected
	     */
	    getFetchData: function () {
	      return this[STATE].get(FETCH_DATA) || {};
	    },

	    /**
	     * Data object for constructing a request to fetch the next page
	     * @return {Object}
	     * @protected
	     */
	    getPaginationData: function () {
	      return this[STATE].get(PAGINATION_DATA) || {};
	    },

	    /**
	     * Does this collection have more data on the server (e.g is there a next "page")
	     * @return {Boolean}
	     */
	    hasMore: function () {
	      return _.size(this.getPaginationData()) > 0;
	    },

	    /**
	     * Get the next page from the server
	     * @return {Object} xhr returned by {@link #fetch}
	     */
	    fetchMore: function () {
	      if (!this.hasMore()) {
	        throw new Error('Invalid Request');
	      }
	      return this.fetch({data: this.getPaginationData(), add: true, remove: false, update: true});
	    },

	    reset: function (models, options) {
	      options || (options = {});
	      // only reset the pagination when reset is being called explicitly.
	      // this is to avoid link headers pagination being overriden and reset when
	      // fetching the collection using `collection.fetch({reset: true})`
	      if (!options.fromFetch) {
	        this.setPagination(null);
	      }
	      return Backbone.Collection.prototype.reset.apply(this, arguments);
	    },

	    // we want "where" to be able to search through derived properties as well
	    where: function (attrs, first) {
	      if (_.isEmpty(attrs)) {
	        return first ? void 0 : [];
	      }
	      return this[first ? 'find' : 'filter'](function (model) {
	        for (var key in attrs) {
	          if (attrs[key] !== model.get(key)) {
	            return false;
	          }
	        }
	        return true;
	      });
	    },

	    create: function (model, options) {
	      options || (options = {});
	      if (!_.result(model, 'urlRoot')) {
	        options.url = _.result(this, 'url');
	      }
	      return Backbone.Collection.prototype.create.call(this, model, options);
	    }

	  });

	}));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(44),
	  __webpack_require__(49),
	  __webpack_require__(50)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, TemplateUtil, View) {

	  // add `broadcast` and `listen` functionality to all views
	  // We use one event emitter per all views
	  // This means we need to be very careful with event names

	  var eventBus = _.clone(Backbone.Events);

	  var proto = {

	    /**
	    * @class Okta.View
	    * @extend Archer.View
	    * @inheritdoc Archer.View
	    */

	    constructor: function () {
	      View.apply(this, arguments);
	      this.module && this.$el.attr('data-view', this.module.id);
	    },

	    /**
	     * @deprecated Use {@link #removeChildren}
	     */
	    empty: function () {
	      return this.removeChildren();
	    },

	    compileTemplate: TemplateUtil.tpl,

	    /**
	    * Broadcasts a global event that all views and controllers can subscribe to
	    * for framework use only - prefer using a shared model
	    *
	    * @param {String} eventName A unique identifier for the event
	    * @param {...String} param Parameter to pass with the event (can pass more than one parameter)
	    * @deprecated For internal use only
	    * @private
	    */
	    broadcast: function () {
	      eventBus.trigger.apply(eventBus, arguments);
	      return this;
	    },

	    /**
	    * Subscribe to broadcast events
	    * for framework use only - prefer using a shared model
	    *
	    * @param {String} eventName The event identifier to subscribe
	    * @param {Function} fn The callback function to invoke
	    * @deprecated For internal use only
	    * @private
	    */
	    listen: function (name, fn) {
	      this.listenTo(eventBus, name, fn);
	      return this;
	    },

	    /**
	    * Shows a notification box
	    *
	    * Examples:
	    *
	    * ```javascript
	    * view.notify('success', 'Group created successfully');
	    * ```
	    *
	    * @param {String} level success / warning / error
	    * @param {String} message The message to display
	    * @param {Object} [options]
	    * @param {Number} [options.width] Set a custom width
	    * @param {String} [options.title] Set a custom title
	    * @param {Boolean} [options.hide=true] Do we want to auto-hide this notification?
	    * @param {Boolean} [options.dismissable] Show a dismiss button
	    */
	    notify: function (level, message, options) {
	      this.broadcast('notification', _.defaults({message: message, level: level}, options));
	      return this;
	    },

	    /**
	    * Shows a confirmation dialog
	    *
	    * The main difference between this and the native javascript `confirm` method
	    * Is this method is non blocking (note the callback pattern).
	    *
	    * The callback function will run in the context (`this`) of the invoking view.
	    *
	    * Examples:
	    *
	    * ```javascript
	    * view.confirm('Delete Group', 'Are you sure you want to delete the selected group?', function () {
	    *   model.destroy();
	    * });
	    *
	    * // title will be auto-set to "Okta"
	    * view.confirm('Are you sure you want to delete the selected group?', function () {
	    *   model.destroy();
	    * });
	    *
	    * view.confirm({
	    *   title: 'Delete Group', //=> Modal title
	    *   subtitle: 'Are you sure you want to delete the selected group?', //=> Modal subtitle
	    *   content: '<h3 color="red">THIS WILL DELETE THE GROUP!</h3>', //=> A template or a view to add to the modal
	    *   save: 'Delete Group', //=> Button label
	    *   ok: _.bind(model.save, model) // Callback function on hitting "ok" button
	    *   cancel: 'Cancel', //=> Button label
	    *   cancelFn: _.bind(model.destroy, model) // Callback function on hitting "cancel" button
	    * });
	    *
	    * ```
	    *
	    * @param {String} [title] The title of the confirmation dialog
	    * @param {String} [message] The message of the confirmation dialog
	    * @param {Function} [okfn] The callback to run when the user hits "OK" (runs in the context of the invoking view)
	    * @param {Function} [cancelfn] The callback to run when the user hits "Cancel"
	    *        (runs in the context of the invoking view)
	    */
	    confirm: function (title, message, okfn, cancelfn) {
	      /* eslint max-statements: [2, 12] */

	      var options;
	      if (typeof title == 'object') {
	        options = title;
	      }
	      else {
	        if (arguments.length == 2 && _.isFunction(message)) {
	          options = {
	            title: 'Okta',
	            subtitle: title,
	            ok: message
	          };
	        }
	        else {
	          options = {
	            title: title,
	            subtitle: message,
	            ok: okfn,
	            cancelFn: cancelfn
	          };
	        }
	      }
	      if (_.isFunction(options.ok)) {
	        options.ok = _.bind(options.ok, this);
	      }
	      if (_.isFunction(options.cancelFn)) {
	        options.cancelFn = _.bind(options.cancelFn, this);
	      }
	      this.broadcast('confirmation', options);
	      return this;
	    },

	    /**
	    * Shows a alert box
	    *
	    * The main difference between this and the native javascript `alert` method
	    * Is this method is non blocking.
	    *
	    * Examples:
	    *
	    * ```javascript
	    * view.alert('Mission complete');
	    * ```
	    *
	    * @param {String} message The message
	    */
	    alert: function (params) {
	      if (_.isString(params)) {
	        params = {
	          subtitle: params
	        };
	      }
	      this.confirm(_.extend({}, params, {
	        noCancelButton: true
	      }));
	      return this;
	    }
	  };

	  return View.extend(proto, {
	    decorate: function (TargetView) {
	      var View = TargetView.extend({});
	      _.defaults(View.prototype, proto);
	      return View;
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Handlebars) {

	  /**
	   * @class TemplateUtil
	   * @private
	   */

	  return {

	    /**
	     * @method
	     * Compiles a Handlebars template
	     */
	    tpl: _.memoize(function (tpl) {
	      /* eslint okta/no-specific-methods: 0 */
	      return Handlebars.compile(tpl);
	    })

	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(44)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  /* global module, exports */
	  else if (typeof require === 'function' && typeof exports === 'object') {
	    module.exports = factory(require('underscore'), require('backbone'));
	  }
	  else {
	    root.Archer || (root.Archer = {});
	    root.Archer.View = factory(root._, root.Backbone);
	  }
	}(this, function (_, Backbone) {

	  var CHILDREN = '__children__',
	      RENDERED = '__rendered__',
	      PARENT = '__parent__',
	      CHILD_DEFINITIONS = '__children_definitions__',
	      ADD_TO_CONTAINER = '__add_to_container__';

	  function getIndex(container, view) {
	    for (var i = 0; i < container[CHILDREN].length; i++) {
	      if (view.cid === container[CHILDREN][i].cid) {
	        return i;
	      }
	    }
	  }

	  function noop() {}

	  function doRender(view) {
	    view[RENDERED] = true;

	    var html = view.renderTemplate(view.template);
	    if (html) {
	      view.$el.html(html);
	    }
	    else if (view.length) {
	      view.$el.empty();
	    }

	    view.each(function (view) {
	      view[ADD_TO_CONTAINER]();
	    });
	  }

	  function subscribeEvents(view) {
	    var isEventPropertyRe = /^(?!(?:delegate|undelegate|_))([a-zA-Z0-9]+)(?:Events)$/;
	    _.each(_.allKeys(view), function (key) {
	      var matchKeys = key.match(isEventPropertyRe);
	      if (!matchKeys) {
	        return;
	      }
	      var bindings = _.result(view, key),
	          entity = view.options[matchKeys[1]] || view[matchKeys[1]];
	      if (!entity || !_.isObject(bindings) || !_.isFunction(entity.trigger)) {
	        return;
	      }
	      _.each(bindings, function (callback, event) {
	        var callbacks = _.isFunction(callback) ? [callback] : _.reduce(callback.split(/\s+/), function (arr, name) {
	          if (_.isFunction(view[name])) {
	            arr.push(view[name]);
	          }
	          return arr;
	        }, []);
	        _.each(callbacks, function (cb) {
	          view.listenTo(entity, event, cb);
	        });
	      });
	    });
	  }

	  var View = Backbone.View.extend({

	    /**
	    * @class Archer.View
	    * @extend Backbone.View
	    *
	    * A View operates on a string template, an token based template, or a model based template, with a few added hooks.
	    * It provides a collection of child views, when a child view could be a View or another View.
	    * Conceptually, if we were in a file system, the View is a folder, when the concrete child views are files,
	    * and the child Views are sub folders.
	    *
	    * *Technically, when using a View as a container, it could have its own concrete logic,
	    * but conceptually we like to keep it separated so a view is either a concrete view or a collection of child views.*
	    *
	    * ```javascript
	    * var DocumentView = Archer.View.extend({
	    *   template: [
	    *     '<header></header>',
	    *     '<article></article>',
	    *     '<footer></footer>'
	    *   ].join(''),
	    *   children: [[HeaderView, 'header'], [ContentView, 'article'], [FooterView, 'footer']]
	    * });
	    * ```
	    * @constructor
	    *
	    * In addition to the standard backbone options, we added `settings` and `state` as first class options.
	    * it will automatically assign `options` to `this.options` as an instance member.
	    * @param {Object} [options] options hash
	    */

	    /**
	     * @property {Object|Function} [entityEvents] an object listing events and callback bind to this.{entity}
	     *
	     * ```javascript
	     * var FooView = View.extend({
	     *   modelEvents: {
	     *     'change:name': 'render'
	     *   }
	     * })
	     * //equivalent to ==>
	     * var FooView = View.extend({
	     *   initialize: function() {
	     *     this.listenTo(this.model, 'change:name', this.render);
	     *   }
	     * });
	     *
	     *
	     * //Multiple callbacks:
	     * var FooView = View.extend({
	     *   modelEvents: {
	     *     'change:name': 'render foo'
	     *   },
	     *   foo: function() {}
	     * });
	     *
	     * //Callbacks As Function:
	     * var FooView = View.extend({
	     *   stateEvents: {
	     *     'change': function() {
	     *   }
	     * });
	     *
	     * //Event Configuration As Function
	     * var FooView = View.extend({
	     *   collectionEvents: function() {
	     *     var events = { 'change:name deleteItem': 'render' };
	     *     events['changeItem'] = 'spin';
	     *     events['addItem'] = function() {};
	     *     return events;
	     *   }
	     * });
	     * ```
	     */
	    constructor: function (options) {
	      /* eslint max-statements: [2, 17] */
	      this.options = options || {};
	      _.extend(this, _.pick(this.options, 'state', 'settings'));

	      // init per-instance children collection
	      this[CHILDREN] = [];
	      this[RENDERED] = false;
	      this[PARENT] = null;
	      this[CHILD_DEFINITIONS] = this.children;

	      // we want to make sure initialize is triggered *after* we append the views from the `this.views` array
	      var initialize = this.initialize;
	      this.initialize = noop;

	      Backbone.View.apply(this, arguments);

	      _.each(_.result(this, CHILD_DEFINITIONS), function (childDefinition) {
	        this.add.apply(this, _.isArray(childDefinition) ? childDefinition : [childDefinition]);
	      }, this);
	      delete this[CHILD_DEFINITIONS];

	      if (this.autoRender && this.model) {
	        var event = _.isArray(this.autoRender) ? _.map(this.autoRender, function (field) {
	          return 'change:' + field;
	        }).join(' ') : 'change';
	        this.listenTo(this.model, event, function () {
	          this.render();
	        });
	      }

	      this.initialize = initialize;
	      this.initialize.apply(this, arguments);
	      subscribeEvents(this);
	    },

	    /**
	    * Unregister view from container
	    * Note: this will not remove the view from the dom
	    * and will not call the `remove` method on the view
	    *
	    * @param {Archer.View} view the view to unregister
	    * @private
	    */
	    unregister: function (view) {

	      this.stopListening(view);
	      var viewIndex = getIndex(this, view);
	      // viewIndex is undefined when the view is not found (may have been removed)
	      // check if it is undefined to prevent unexpected thing to happen
	      // array.splice(undefined, x) removes the first x element(s) from the array
	      // this protects us against issues when calling `remove` on a child view multiple times
	      if (_.isNumber(viewIndex)) {
	        this[CHILDREN].splice(viewIndex, 1);
	      }
	    },

	    /**
	     * Should we auto render the view upon model change. Boolean or array of field names to listen to.
	     * @type {Boolean|Array}
	     * @deprecated Instead, please use modelEvents
	     * modelEvents: {
	     *   change:name: 'render'
	     * }
	     */
	    autoRender: false,

	    /**
	    * @type {(String|Function)}
	    * @alias Backbone.View#template
	    *
	    * When the template is an underscore template, the render method will pass the options has to the template
	    * And the associated model, if exists, when it will prefer the model over the options in case of a conflict.
	    * {@link #render View.render}
	    *
	    * Example:
	    *
	    * ```javascript
	    * var View = View.extend({
	    *   template: '<p class="name">{{name}}</p>'
	    * };
	    * ```
	    */
	    template: null,

	    /**
	     * A list of child view definitions to be passed to {@link #add this.add()}
	     *
	     * ```javascript
	     * var Container = View.extend({
	     *    template: '<p class="content"></p>',
	     *    children: [
	     *      [ContentView, '.content'],
	     *      [OtherContentView, '.content'],
	     *      OtherView
	     *    ]
	     *  })
	     *
	     * var Container = View.extend({
	     *    template: '<dov class="form-wrap"></div>',
	     *    children: function () {
	     *      return [
	     *        [FormView, '.form-wrap', {options: {model: this.optiosn.otherModel}}]
	     *      ]
	     *    }
	     *  })
	     * ```
	     * Note: these definitions will be added **before** the {@link #constructor initiliaze} method invokes.
	     * @type {Array|Function}
	     */
	    children: [],

	    /**
	    * Add a child view to the container.
	    * If the container is already rendered, will also render the view  and append it to the DOM.
	    * Otherwise will render and append once the container is rendered.
	    *
	    * Examples:
	    *
	    * ```javascript
	    * var Container = View.extend({
	    *
	    *   template: [
	    *     '<h1></h1>',
	    *     '<section></section>',
	    *   ].join(''),
	    *
	    *   initalize: function () {
	    *
	    *     this.add(TitleView, 'h1'); // will be added to <h1>
	    *
	    *     this.add(ContentView1, 'section'); // will be added to <section>
	    *
	    *     this.add(ContentView2, 'section', {prepend: true}); // will be add into <section> **before** ContentView1
	    *
	    *     this.add(OtherView, {
	    *       options: {
	    *         model: new Model()
	    *       }
	    *     }); // will be added **after** the <section> element
	    *
	    *     this.add('<p class="name">some html</p>'); //=> "<p class="name">some html</p>"
	    *     this.add('<p class="name">{{name}}</p>'); //=> "<p class="name">John Doe</p>"
	    *     this.add('{{name}}') //=> "<div>John Doe</div>"
	    *     this.add('<span>{{name}}</span> w00t') //=> "<div><span>John Doe</span> w00t</div>"
	    *   }
	    *
	    * });
	    *
	    * var container - new View({name: 'John Doe'});
	    *
	    * ```
	    * *We believe that for the sake of encapsulation, a view should control its own chilren, so we treat this method as
	    * protected and even though technically you can call `view.add` externally we strongly discourage it.*
	    *
	    * @param {(Archer.View|String)} view A class (or an instance which is discouraged) of a View - or an HTML
	    * string/template
	    * @param {String} [selector] selector in the view's template on which the view will be added to
	    * @param {Object} [options]
	    * @param {Boolean} [options.bubble=false] Bubble (proxy) events from this view up the chain
	    * @param {Boolean} [options.prepend=false] Prepend the view instend of appending
	    * @param {String} [options.selector] Selector in the view's template on which the view will be added to
	    * @param {Object} [options.options] Extra options to pass to the child constructor
	    * @protected
	    * @returns {Archer.View} - The instance of itself for the sake of chaining
	    */
	    add: function (view, selector, bubble, prepend, extraOptions) {
	      /* eslint max-statements: [2, 28], complexity: [2, 8] */

	      var options = {},
	          args = _.toArray(arguments);

	      if (_.isObject(selector)) {
	        options = selector;
	        selector = options.selector;
	        bubble = options.bubble;
	        prepend = options.prepend;
	        extraOptions = options.options;
	      }
	      else if (_.isObject(bubble)) {
	        options = bubble;
	        bubble = options.bubble;
	        prepend = options.prepend;
	        extraOptions = options.options;
	      }

	      if (_.isString(view)) {
	        view = (function (template) {
	          return View.extend({
	            constructor: function () {
	              try {
	                var $el = Backbone.$(template);
	                if ($el.length != 1) { throw 'invalid Element'; }
	                this.template = $el.html();
	                this.el = $el.empty()[0];
	              }
	              catch (e) { // not a valid html tag.
	                this.template = template;
	              }
	              View.apply(this, arguments);
	            }
	          });
	        }(view));
	      }

	      if (view.prototype && view.prototype instanceof View) {
	        /* eslint new-cap: 0 */
	        var viewOptions = _.omit(_.extend({}, this.options, extraOptions), 'el');
	        args[0] = new view(viewOptions);
	        return this.add.apply(this, args);
	      }

	      // prevent dups
	      if (_.isNumber(getIndex(this, view))) {
	        throw new Error('Duplicate child');
	      }

	      view[PARENT] = this;

	      // make the view responsible for adding itself to the parent:
	      // * register the selector in the closure
	      // * register a reference the parent in the closure
	      view[ADD_TO_CONTAINER] = (function (selector) {
	        return function () {
	          if (selector && view[PARENT].$(selector).length != 1) {
	            throw new Error('Invalid selector: ' + selector);
	          }
	          var $el = selector ? this[PARENT].$(selector) : this[PARENT].$el;
	          this.render();
	          // we need to delegate events in case
	          // the view was added and removed before
	          this.delegateEvents();

	          // this[PARENT].at(index).$el.before(this.el);
	          prepend ? $el.prepend(this.el) : $el.append(this.el);
	        };
	      }).call(view, selector);

	      // if flag to bubble events is set
	      // proxy all child view events
	      if (bubble) {
	        this.listenTo(view, 'all', function () {
	          this.trigger.apply(this, arguments);
	        });
	      }

	      // add to the dom if `render` has been called
	      if (this.rendered()) {
	        view[ADD_TO_CONTAINER]();
	      }

	      // add view to child views collection
	      this[CHILDREN].push(view);

	      return this;

	    },

	    /**
	    * Remove all children from container
	    */
	    removeChildren: function () {
	      this.each(function (view) {
	        view.remove();
	      });
	      return this;
	    },

	    /**
	    *  Removes a view from the DOM, and calls stopListening to remove any bound events that the view has listenTo'd.
	    *  Also removes all childern of the view if any, and removes itself from its parent view(s)
	    */
	    remove: function () {
	      this.removeChildren();
	      if (this[PARENT]) {
	        this[PARENT].unregister(this);
	      }
	      return Backbone.View.prototype.remove.apply(this, arguments);
	    },

	    /**
	     * Compile the template to function you can apply tokens on on render time.
	     * Uses the underscore tempalting engine by default
	     * @protected
	     * @param  {String} template
	     * @return {Function} a compiled template
	     */
	    compileTemplate: function (template) {
	      /* eslint  okta/no-specific-methods: 0*/
	      return _.template(template);
	    },

	    /**
	     * Render a template with `this.model` and `this.options` as parameters
	     * preferring the model over the options.
	     *
	     * @param  {(String|Function)} template The template to build
	     * @return {String} An HTML string
	     * @protected
	     */
	    renderTemplate: function (template) {
	      if (_.isString(template)) {
	        template = this.compileTemplate(template);
	      }
	      if (_.isFunction(template)) {
	        return template(this.getTemplateData());
	      }
	    },

	    /**
	     * The data hash passed to the compiled template
	     * @return {Object}
	     * @protected
	     */
	    getTemplateData: function () {
	      var modelData = this.model && this.model.toJSON({verbose: true}) || {};
	      var options = _.omit(this.options, ['state', 'settings', 'model', 'collection']);
	      return _.defaults({}, modelData, options);
	    },

	    /**
	    * Renders the template to `$el` and append all children in order
	    * {@link #template View.template}
	    */
	    render: function () {
	      this.preRender();
	      doRender(this);
	      this.postRender();
	      return this;
	    },

	    /**
	     * Pre render routine. Will be called right *before* the logic in {@link #render} is executed
	     * @method
	     */
	    preRender: noop,

	    /**
	     * Post render routine. Will be called right *after* the logic in {@link #render} is executed
	     * @method
	     */
	    postRender: noop,

	    /**
	     * Was this instance rendered
	     */
	    rendered: function () {
	      return this[RENDERED];
	    },

	    /**
	     * get all direct child views.
	     *
	     * ```javascript
	     * var container = View.extend({
	     *   children: [View1, View2]
	     * }).render();
	     * container.getChildren() //=> [view1, view2];
	     * ```
	     *
	     * @return {Archer.View[]}
	     */
	    getChildren: function () {
	      return this.toArray();
	    },

	    /**
	    * Get a child by index
	    * @param {number} index
	    * @returns {Archer.View} The child view
	    */
	    at: function (index) {
	      return this.getChildren()[index];
	    },

	    /**
	    * Invokes a method on all children down the tree
	    *
	    * @param {String} method The method to invoke
	    */
	    invoke: function (methodName) {
	      var args = _.toArray(arguments);
	      this.each(function (child) {
	        // if child has children, bubble down the tree
	        if (child.size()) {
	          child.invoke.apply(child, args);
	        }
	        // run the function on the child
	        if (_.isFunction(child[methodName])) {
	          child[methodName].apply(child, args.slice(1));
	        }
	      });
	      return this;
	    }
	  });

	  // Code borrowed from Backbone.js source
	  // Underscore methods that we want to implement on the Container.
	  var methods = ['each', 'map', 'reduce', 'reduceRight', 'find', 'filter', 'reject', 'every',
	    'some', 'contains', 'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without',
	    'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain', 'where', 'findWhere'];

	  _.each(methods, function (method) {
	    View.prototype[method] = function () {
	      var args = _.toArray(arguments);
	      args.unshift(_.toArray(this[CHILDREN]));
	      return _[method].apply(_, args);
	    };
	  }, this);

	  return View;


	  /**
	   * @method each
	   * @param {Function} iterator
	   * @param {Object} [context]
	   * See [_.each](http://underscorejs.org/#each)
	   */
	  /**
	   * @method map
	   * @param {Function} iterator
	   * @param {Object} [context]
	   * See [_.map](http://underscorejs.org/#map)
	   */
	  /**
	   * @method reduce
	   * @param {Function} iterator
	   * @param {Mixed} memo
	   * @param {Object} [context]
	   * See [_.reduce](http://underscorejs.org/#reduce)
	   */
	  /**
	   * @method reduceRight
	   * @param {Function} iterator
	   * @param {Mixed} memo
	   * @param {Object} [context]
	   * See [_.reduceRight](http://underscorejs.org/#reduceRight)
	   */
	  /**
	   * @method find
	   * @param {Function} predicate
	   * @param {Object} [context]
	   * See [_.find](http://underscorejs.org/#find)
	   */
	  /**
	   * @method filter
	   * @param {Function} predicate
	   * @param {Object} [context]
	   * See [_.filter](http://underscorejs.org/#filter)
	   */
	  /**
	   * @method reject
	   * @param {Function} predicate
	   * @param {Object} [context]
	   * See [_.reject](http://underscorejs.org/#reject)
	   */
	  /**
	   * @method every
	   * @param {Function} [predicate]
	   * @param {Object} [context]
	   * See [_.every](http://underscorejs.org/#every)
	   */
	  /**
	   * @method some
	   * @param {Function} [predicate]
	   * @param {Object} [context]
	   * See [_.some](http://underscorejs.org/#some)
	   */
	  /**
	   * @method contains
	   * @param {Mixed} value
	   * See [_.contains](http://underscorejs.org/#contains)
	   */
	  /**
	   * @method toArray
	   * See [_.toArray](http://underscorejs.org/#toArray)
	   */
	  /**
	   * @method size
	   * See [_.size](http://underscorejs.org/#size)
	   */
	  /**
	   * @method first
	   * @param {Number} [n]
	   * See [_.first](http://underscorejs.org/#first)
	   */
	  /**
	   * @method initial
	   * @param {Number} [n]
	   * See [_.initial](http://underscorejs.org/#initial)
	   */
	  /**
	   * @method last
	   * @param {Number} [n]
	   * See [_.last](http://underscorejs.org/#last)
	   */
	  /**
	   * @method rest
	   * @param {Number} [index]
	   * See [_.rest](http://underscorejs.org/#rest)
	   */
	  /**
	   * @method without
	   * See [_.without](http://underscorejs.org/#without)
	   */
	  /**
	   * @method indexOf
	   * @param {Mixed} value
	   * @param {Boolean} [isSorted]
	   * See [_.indexOf](http://underscorejs.org/#indexOf)
	   */
	  /**
	   * @method shuffle
	   * See [_.shuffle](http://underscorejs.org/#shuffle)
	   */
	  /**
	   * @method lastIndexOf
	   * @param {Mixed} value
	   * @param {Number} [fromIndex]
	   * See [_.shuffle](http://underscorejs.org/#lastIndexOf)
	   */
	  /**
	   * @method isEmpty
	   * See [_.isEmpty](http://underscorejs.org/#isEmpty)
	   */
	  /**
	   * @method chain
	   * See [_.chain](http://underscorejs.org/#chain)
	   */
	  /**
	   * @method where
	   * @param {Object} properties
	   * See [_.where](http://underscorejs.org/#where)
	   */
	  /**
	   * @method findWhere
	   * @param {Object} properties
	   * See [_.findWhere](http://underscorejs.org/#findWhere)
	   */


	}));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(48),
	  __webpack_require__(52)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (BaseView, ListView) {
	   /**
	   * @class Okta.ListView
	   * @extends Archer.ListView
	   * @inheritdoc Archer.ListView
	   */
	  return BaseView.decorate(ListView);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(50)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  /* global module, exports */
	  else if (typeof require == 'function' && typeof exports == 'object') {
	    module.exports = factory(require('underscore'), require('./View'));
	  }
	  else {
	    root.Archer || (root.Archer = {});
	    root.Archer.ListView = factory(root._, root.Archer.View);
	  }
	}(this, function (_, View) {

	  return View.extend({

	    /**
	    * @class Archer.ListView
	    * @extends Archer.View
	    * Archer.ListView is a {@link Archer.View} that operates on a collection and builds a list of "things" of the
	    * same type.
	    *
	    * Automagically adds, removes and sorts upon standard collection events.
	    *
	    * Example:
	    *
	    * ```javascript
	    * var UserList = Archer.ListView.extend({
	    *   tagName: 'ul',
	    *   item: '<li>{{fname}} {{lname}}</li>'
	    * });
	    *
	    * var users = new Archer.Collection([
	    *   {fname: 'John', lname: 'Doe'},
	    *   {fname: 'Jane', lname: 'Doe'}
	    * ]);
	    *
	    * var userList = new UserList({collection: users}).render();
	    * userList.el; //=> "<ul><li>John Doe</li><li>Jane Doe</li></ul>"
	    *
	    * users.push({fname: 'Jim', lname: 'Doe'});
	    * userList.el; //=> "<ul><li>John Doe</li><li>Jane Doe</li><li>Jim Doe</li></ul>"
	    *
	    * users.first().destroy();
	    * userList.el; //=> "<ul><li>Jane Doe</li><li>Jim Doe</li></ul>"
	    * ```
	    *
	    * @constructor
	    * @param {Object} options options hash
	    * @param {Object} options.collection The collection which this view operates on
	    *
	    * Listen to collection events so the ListView will do the right thing when a model is added or the collection
	    * is reset or sorted
	    *
	    */
	    constructor: function () {
	      View.apply(this, arguments);
	      if (!this.collection) {
	        throw new Error('Missing collection');
	      }
	      this.listenTo(this.collection, 'reset sort', this.reset);
	      this.listenTo(this.collection, 'add', this.addItem);
	      this.collection.each(this.addItem, this);
	    },

	   /**
	    * The view/template we will use to render each model in the collection.
	    * @type {String|Archer.View}
	    */
	    item: null,

	    /**
	     * A selector in the local template where to append each item
	     * @type {String}
	     */
	    itemSelector: null,


	    /**
	    * Empty the list and re-add everything from the collection.
	    * Usefull for handling `collection.reset()` or for handling the initial load
	    * @protected
	    */
	    reset: function () {
	      this.removeChildren();
	      this.collection.each(this.addItem, this);
	      return this;
	    },

	    /**
	    * Add an item view to the list that will represent one model from the collection
	    *
	    * Listen to the model so when it is destoyed or removed from the collection
	    * this item will remove itself from the list
	    *
	    * @param {Backbone.Model} model The model this row operates on
	    * @protected
	    */
	    addItem: function (model) {
	      var view = this.add(this.item, this.itemSelector, {options: {model: model}}).last();
	      view.listenTo(model, 'destroy remove', view.remove);
	      return this;
	    }

	  });

	}));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-len: [2, 150], max-params: [2, 6] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(44),
	  __webpack_require__(54),
	  __webpack_require__(55),
	  __webpack_require__(16)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, Backbone, SettingsModel, Notification, ConfirmationDialog) {

	  return Backbone.Router.extend({

	    listen: Notification.prototype.listen,

	    /**
	    * @class Okta.Router
	    * A simple state machine that maps a route to a controller
	    *
	    *  Typically it will:
	    *
	    * - define which routes/modules the application has
	    * - Map a route to a controller
	    *
	    * See:
	    * [Hello World Tutorial](https://github.com/okta/courage/wiki/Hello-World),
	    * [Jasmine Spec](https://github.com/okta/okta-core/blob/master/WebContent/js/test/unit/spec/shared/util/BaseRouter_spec.js),
	    * [Backbone.Router](http://backbonejs.org/#Router)
	    *
	    * @constructor
	    *
	    * Creates the application settings object
	    *
	    * @param {Object} options options hash
	    * @param {String} options.el a jQuery selector string stating where to attach the controller in the DOM
	    *
	    * @extends {Backbone.Router}
	    *
	    */
	    constructor: function (options) {
	      options || (options = {});
	      this.el = options.el;
	      this.settings = new SettingsModel(_.omit(options, 'el'));

	      Backbone.Router.apply(this, arguments);

	      this.listen('notification', this._notify);
	      this.listen('confirmation', this._confirm);
	    },

	    /**
	     * Fires up a confirmation dialog
	     *
	     * @param  {Object} options Options Hash
	     * @param  {String} options.title The title
	     * @param  {String} options.subtitle The explain text
	     * @param  {String} options.save The text for the save button
	     * @param  {Function} options.ok The callback function to run when hitting "OK"
	     * @param  {String} options.cancel The text for the cancel button
	     * @param  {Function} options.cancelFn The callback function to run when hitting "Cancel"
	     * @param  {Boolean} options.noCancelButton Don't render the cancel button (useful for alert dialogs)
	     *
	     * @private
	     *
	     * @return {Okta.View} the dialog view
	     */
	    _confirm: function (options) {
	      options || (options = {});
	      var Dialog = ConfirmationDialog.extend(
	       _.pick(options, 'title', 'subtitle', 'save', 'ok', 'cancel', 'cancelFn', 'noCancelButton', 'content', 'danger'));
	      // The model is here because itsa part of the BaseForm paradigm.
	      // It will be ignored in the context of a confirmation dialog.
	      var dialog = new Dialog({model: this.settings});
	      dialog.render();
	      return dialog; // test hook
	    },

	    /**
	     * Fires up a notification banner
	     *
	     * @param  {Object} options Options Hash
	     * @return {Okta.View} the notification view
	     * @private
	     */
	    _notify: function (options) {
	      var notification = new Notification(options);
	      $('#content').prepend(notification.render().el);
	      return notification; // test hook
	    },

	    /**
	     * Renders a Controller
	     * This will initialize new instance of a controller and call render on it
	     *
	     * @param  {Okta.Controller} Controller The controller Class we which to render
	     * @param  {Object} [options] Extra options to the controller constructor
	     */
	    render: function (Controller, options) {
	      if (this.controller) {
	        this.stopListening(this.controller);
	        this.stopListening(this.controller.state);
	        this.controller.remove();
	      }
	      options = _.extend(_.pick(this, 'settings', 'el'), options || {});
	      this.controller = new Controller(options);
	      this.controller.render();
	    },

	    /**
	    * Starts the backbone history object
	    *
	    * Waits for the dom to be ready before calling `Backbone.history.start()` (IE issue)
	    *
	    * See: [Backbone History](http://backbonejs.org/#History)
	    */
	    start: function () {
	      var args = arguments;
	      $(function () {
	        Backbone.history.start.apply(Backbone.history, args);
	      });
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Model) {

	  /**
	   * @class SettingsModel
	   * @extends {Okta.Model}
	   * @private
	   */

	  return Model.extend({
	    local: function () {
	      var settings = (window.okta && window.okta.settings) || {};
	      return {
	        orgId: ['string', false, settings.orgId],
	        orgName: ['string', false, settings.orgName],
	        isPreview: ['boolean', false, settings.isPreview],
	        serverStatus: ['string', false, settings.serverStatus],
	        permissions: ['array', true, settings.permissions || []]
	      };
	    },

	    extraProperties: true,

	    constructor: function () {
	      this.features = window._features || [];
	      Model.apply(this, arguments);
	    },

	    /**
	     * Checks if the user have a feature flag enabled (Based of the org level feature flag)
	     * @param  {String}  feature Feature name
	     * @return {Boolean}
	     */
	    hasFeature: function (feature) {
	      return _.contains(this.features, feature);
	    },

	    /**
	     * Checks if any of the given feature flags are enabled (Based of the org level feature flags)
	     * @param  {Array}  featureArray Features names
	     * @return {Boolean} true if any of the give features are enabled. False otherwise
	     */
	    hasAnyFeature: function (featureArray) {
	      return _.some(featureArray, this.hasFeature, this);
	    },

	    /**
	     * Checks if the user have a specific permission (based on data passed from JSP)
	     * @param  {String}  permission Permission name
	     * @return {Boolean}
	     */
	    hasPermission: function (permission) {
	      return _.contains(this.get('permissions'), permission);
	    }
	    
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6), __webpack_require__(2), __webpack_require__(48)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, BaseView) {

	  var defaults = {
	    level: 'success',
	    message: 'Great Success!',
	    hide: true,
	    fade: 400,
	    delay: 3000,
	    width: 0,
	    dismissable: false
	  };

	  return BaseView.extend({

	    className: 'infobox infobox-confirm infobox-confirm-fixed',

	    events: {
	      'click .infobox-dismiss-link': 'fadeOut'
	    },

	    template: '\
	      {{#if dismissable}}\
	      <a class="infobox-dismiss-link" title="Dismiss" href="#">\
	        <span class="dismiss-icon"></span>\
	      </a>\
	      {{/if}}\
	      <span class="icon {{level}}-16"></span>\
	      {{#if title}}<h3>{{title}}</h3>{{/if}}\
	      <p>{{message}}</p>\
	    ',

	    initialize: function () {
	      this.options = _.defaults({}, this.options, defaults);
	      this.$el.addClass('infobox-' + this.options.level);
	      if (this.options.width) {
	        this.$el.width(this.options.width).css({
	          'margin-left': '0px',
	          'left': Math.round(($(window).width() - this.options.width) / 2)
	        });
	      }
	    },

	    getTemplateData: function () {
	      return _.extend(_.pick(this.options, 'level', 'message', 'title'), {
	        dismissable: this.options.hide === false || this.options.dismissable === true
	      });
	    },

	    postRender: function () {
	      if (this.options.hide) {
	        _.delay(_.bind(this.fadeOut, this), this.options.delay);
	      }
	    },

	    fadeOut: function () {
	      this.$el.fadeOut(this.options.fade, _.bind(this.remove, this));
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: [2, 6], max-len: [2, 150] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(48),
	  __webpack_require__(57),
	  __webpack_require__(54),
	  __webpack_require__(53)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, BaseView, StateMachine, SettingsModel, BaseRouter) {

	  function clean(obj) {
	    var res = {};
	    _.each(obj, function (value, key) {
	      if (!_.isNull(value)) {
	        res[key] = value;
	      }
	    });
	    return res;
	  }

	  return BaseView.extend({

	    /**
	    * @class Okta.Controller
	    * A Controller is our application control flow component.
	    *
	    *  Typically it will:
	    *
	    * - Initialize the models, controller and main views
	    * - Listen to events
	    * - Create, read, update and delete models
	    * - Create modal dialogs, confirmation dialogs and alert dialogs
	    * - Control the application flow
	    *
	    * See:
	    * [Hello World Tutorial](https://github.com/okta/courage/wiki/Hello-World),
	    * [Jasmine Spec](https://github.com/okta/okta-core/blob/master/WebContent/js/test/unit/spec/shared/util/BaseController_spec.js)
	    *
	    * @constructor
	    *
	    * The constructor is responsible for:
	    *
	    * - Create the application state object
	    * - Assign or creates the application settings object
	    * - Create an instance of the main view with the relevant parameters
	    *
	    * @param {Object} options Options Hash
	    * @param {SettingsModel} [options.settings] Application Settings Model
	    * @param {String} options.el a jQuery selector string stating where to attach the controller in the DOM
	    *
	    */
	    constructor: function (options) {
	      /* eslint max-statements: [2, 13], complexity: [2, 7]*/
	      options || (options = {});

	      var stateData = _.defaults(clean(options.state), this.state || {});
	      this.state = new StateMachine(stateData);
	      delete options.state;

	      if (options.settings) {
	        this.settings = options.settings;
	      }
	      else { // allow the controller to live without a router
	        this.settings = new SettingsModel(_.omit(options || {}, 'el'));
	        this.listen('notification', BaseRouter.prototype._notify);
	        this.listen('confirmation', BaseRouter.prototype._confirm);
	      }

	      BaseView.call(this, options);

	      this.listenTo(this.state, '__invoke__', function () {
	        var args = _.toArray(arguments),
	            method = args.shift();
	        if (_.isFunction(this[method])) {
	          this[method].apply(this, args);
	        }
	      });


	      if (this.View) {
	        this.add(new this.View(this.toJSON()));
	      }
	    },

	    /**
	     * @property {Object} [state={}]
	     * The default values of our application state
	     */
	    state: {},


	    /**
	     * @property {Okta.View} [View=null]
	     * The main view this controller operate on
	     */
	    View: null,

	    /**
	     * Renders the {@link Okta.Controller#View main view} after the DOM is ready
	     * in case the controller is the root component of the page (e.g there's no router)
	     */
	    render: function () {
	      var args = arguments,
	          self = this;
	      $(function () {
	        BaseView.prototype.render.apply(self, args);
	      });
	      return this;
	    },

	    /**
	     * Creates the view constructor options
	     * @param {Object} [options] Extra options
	     * @return {Object} The view constructor options
	     */
	    toJSON: function (options) {
	      return _.extend(_.pick(this, 'state', 'settings', 'collection', 'model'), options || {});
	    },

	    /**
	     * Removes the child views, empty the DOM element and stop listening to events
	     */
	    remove: function () {
	      this.removeChildren();
	      this.stopListening();
	      this.$el.empty();
	      return this;
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Model) {

	  /**
	   * @class StateMachine
	   * @extends Okta.Model
	   * @private
	   *
	   * A state object that holds the applciation state
	   */

	  return Model.extend({
	    extraProperties: true,
	    /**
	     * Invokes a method on the applicable {@link Okta.Controller}
	     *
	     * ```javascript
	     * state.invoke('methodName', 'param1', 'param2')
	     * // Will call
	     * contoller.methodName('param1', 'param2')
	     * ```
	     * @param {String} methodName the name of the controller method to invoke on the controller
	     */
	    invoke: function () {
	      var args = _.toArray(arguments);
	      args.unshift('__invoke__');
	      this.trigger.apply(this, args);
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: [2, 14], max-statements: [2, 11] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(49),
	  __webpack_require__(7),
	  __webpack_require__(48),
	  __webpack_require__(60),
	  __webpack_require__(93),
	  __webpack_require__(59),
	  __webpack_require__(95),
	  __webpack_require__(97),
	  __webpack_require__(89),
	  __webpack_require__(96),
	  __webpack_require__(98),
	  __webpack_require__(99)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, TemplateUtil, StringUtil, BaseView,
	          InputFactory, InputLabel, InputContainer, InputWrapper,
	          ErrorBanner, ErrorParser, FormUtil, ReadModeBar, Toolbar) {

	  var template = '\
	    {{#if hasReadMode}}\
	      <h2 class="o-form-title-bar" data-se="o-form-title-bar">\
	        {{title}}\
	      </h2>\
	    {{/if}}\
	    <div data-se="o-form-content" class="o-form-content {{layout}} clearfix">\
	      {{#unless hasReadMode}}\
	        {{#if title}}\
	          <h2 data-se="o-form-head" class="okta-form-title o-form-head">{{title}}</h2>\
	        {{/if}}\
	      {{/unless}}\
	      {{#if subtitle}}\
	        <p class="okta-form-subtitle o-form-explain" data-se="o-form-explain">{{subtitle}}</p>\
	      {{/if}}\
	      <div class="o-form-error-container" data-se="o-form-error-container"></div>\
	      <div class="o-form-fieldset-container" data-se="o-form-fieldset-container"></div>\
	    </div>\
	  ';

	  // polyfill for `pointer-events: none;` in IE < 11
	  // Logic borrowed from https://github.com/kmewhort/pointer_events_polyfill (BSD)
	  var pointerEventsSupported = ($('<div>').css({'pointer-events': 'auto'})[0].style.pointerEvents === 'auto');
	  function pointerEventsPolyfill(e) {
	    if (!pointerEventsSupported && this.$el.hasClass('o-form-saving')) {
	      var $el = $(e.currentTarget);

	      $el.css('display', 'none');
	      var underneathElem = document.elementFromPoint(e.clientX, e.clientY);
	      $el.css('display', 'block');

	      e.target = underneathElem;
	      $(underneathElem).trigger(e);

	      return false;
	    }
	  }


	  var events = {
	    submit: function (e) {
	      e.preventDefault();
	      this.__save();
	    }
	  };

	  _.each(['click', 'dblclick', 'mousedown', 'mouseup'], function (event) {
	    events[event + ' .o-form-input'] = pointerEventsPolyfill;
	  });

	  var attributes = function (model) {
	    model || (model = {});
	    var collection = model && model.collection || {};
	    return {
	      method: 'POST',
	      action: _.result(model, 'urlRoot') || _.result(collection, 'url') || window.location.pathname,
	      'data-se': 'o-form'
	    };
	  };

	  var convertSavingState = function (rawSavingStateEvent, defaultEvent) {
	    rawSavingStateEvent || (rawSavingStateEvent = '');
	    var savingStateEvent = [];
	    if (_.isString(rawSavingStateEvent)) {
	      savingStateEvent = rawSavingStateEvent.split(' ');
	    }
	    savingStateEvent = _.union(savingStateEvent, defaultEvent);
	    return savingStateEvent.join(' ');
	  };

	  /**
	  * @class Okta.Form
	  *
	  * A Form utility framework
	  *
	  * Okta.Form is a form that operates on one flat model
	  * It expose one main factory method, {@link #addInput}, which add inputs to the form,
	  * and each inputs operates on one field in the model, identified by the `name` field.
	  *
	  * See:
	  * [Basic O-Form Tutorial](https://github.com/okta/courage/wiki/Basic-O-Form)
	  *
	  * @extends Okta.View
	  */

	  /**
	  * @event save
	  * Fired when the "Save" button is clicked
	  * @param {Okta.BaseModel} model Model used in the form
	  */
	  /**
	  * @event saved
	  * Fired after the model is successfully saved - applies when {@link Okta.Form#autoSave} is set to true
	  * @param {Okta.BaseModel} model Model used in the form
	  */
	  /**
	  * @event error
	  * Fired when the model fires an invalid event or an error event;
	  * @param {Okta.BaseModel} model Model used in the form
	  */
	  /**
	  * @event resize
	  * Fired when the form layout is likely to be resized
	  * @param {Okta.BaseModel} model Model used in the form
	  */
	  /**
	  * @event cancel
	  * Fired when the "Cancel" button is clicked
	  */
	  /**
	   * @property {String|Array|Function} [validate]
	   * Specifies how to validate form:
	   * - In case "local" string provided as a value of the property,
	   * the form will validate only fields added as inputs to the form;
	   * - In case array is provided, the validation will be performed only for fields specified in array;
	   * - In case function is provided, provided function will be used as a validation function,
	   * it must return an error object with the format {fieldName: 'error text'} with as many fields as you need.
	   */

	  return BaseView.extend({

	    /**
	    * @constructor
	    * @param {Object} options options hash (See {@link Okta.View})
	    * @param {Object} options.model the model this form operates on
	    * @param {Boolean} [options.label-top=false] position label on top of inputs
	    * @param {Boolean} [options.wide=false] Use a wide input layout for all input
	    */

	    constructor: function (options) {
	      /* eslint max-statements: 0, complexity: 0 */
	      options || (options = {});
	      this.options = options;

	      this.id = _.uniqueId('form');
	      this.tagName = 'form';

	      _.defaults(this.events, events);
	      _.defaults(this.attributes, attributes(options.model));

	      this.__buttons = [];
	      this.__errorFields = {};

	      this.__saveModelState(options.model);

	      if (this.step) {
	        if (!this.save) {
	          this.save = (!this.totalSteps || this.step === this.totalSteps) ? 'Finish' : 'Next';
	        }
	        this.className += ' wizard';
	      }
	      this.className += ' o-form';

	      this.__toolbar = this.__createToolbar(options);

	      BaseView.call(this, options);

	      _.each(_.result(this, 'inputs') || [], function (input) {
	        // to ingore extra argumests from `each` iteratee function
	        // http://underscorejs.org/#each
	        this.__addLayoutItem(input);
	      }, this);

	      this.add(this.__toolbar, '');

	      this.listenTo(this.model, 'change:__edit__', this.__applyMode);

	      this.listenTo(this.model, 'invalid error', _.throttle(function (model, resp, showBanner) {
	        this.__showErrors(model, resp, showBanner !== false);
	      }, 100, {trailing: false}));

	      this.listenTo(this.model, 'form:resize', function () {
	        this.trigger('resize');
	      });

	      this.listenTo(this.model, 'form:cancel', _.throttle(this.__cancel, 100, {trailing: false}));
	      this.listenTo(this.model, 'form:previous', _.throttle(this.__previous, 100, {trailing: false}));

	      this.__save = _.throttle(this.__save, 200, {trailing: false});
	      this.listenTo(this.model, 'form:save', function () {
	        this.$el.submit();
	      });

	      this.listenTo(this.model, 'sync', function () {
	        if (this.model.get('__edit__')) {
	          this.model.set('__edit__', false, {silent: true});
	        }
	        this.__saveModelState(this.model);
	        this.render();
	      });

	      var hasSavingState = this.getAttribute('hasSavingState');

	      if (this.getAttribute('autoSave')) {
	        this.listenTo(this, 'save', function (model) {
	          var xhr = model.save();
	          if (xhr && xhr.done) {
	            xhr.done(_.bind(function () {
	              this.trigger('saved', model);
	            }, this));
	          }
	        });
	        if (_.isUndefined(hasSavingState)) {
	          hasSavingState = true;
	        }
	      }

	      /*
	       * Attach model event listeners
	       * by default, model's request event starts the form saving state,
	       * error and sync event stops it
	       * you can define customized saving start and stop state, like
	       * customSavingState: {start: 'requestingAdditionalInfo', stop: 'retrievedAdditionalInfo'}
	       * doing this does not override the default events
	       */
	      if (hasSavingState) {
	        var customSavingState = this.getAttribute('customSavingState', {});
	        this.listenTo(
	          this.model,
	          convertSavingState(customSavingState.start || '', ['request']),
	          this.__setSavingState
	        );
	        this.listenTo(
	          this.model,
	          convertSavingState(customSavingState.stop || '', ['error', 'sync']),
	          this.__clearSavingState
	        );
	      }
	    },

	    /**
	     * Create the bottom button bar
	     * @param  {Object} options options h
	     * @return {Okta.View} The toolbar
	     * @private
	     */
	    __createToolbar: function (options) {

	      var danger = this.getAttribute('danger'),
	          saveBtnClassName = danger === true ? 'button-error' : 'button-primary';

	      var toolbar = new Toolbar(_.extend({
	        save: this.save || StringUtil.localize('oform.save'),
	        saveClassName: saveBtnClassName,
	        cancel: this.cancel || StringUtil.localize('oform.cancel'),
	        noCancelButton: this.noCancelButton || false,
	        hasPrevStep: this.step && this.step > 1
	      }, options || this.options));

	      _.each(this.__buttons, function (args) {
	        toolbar.addButton.apply(toolbar, args);
	      });

	      return toolbar;
	    },

	    className: '',

	    attributes: {},

	    events: {},

	    /**
	    * @property {Array} [inputs] An array of input configurations to render in the form
	    */
	    inputs: [],

	    /**
	     * @private
	     */
	    template: null,

	    /**
	     * @property {Boolean|Function} [read=false] does the form support read/edit toggle.
	     */
	    read: false,

	    /**
	     * @property {Boolean|Function} [readOnly=false] Is the form in readOnly mode.
	     */
	    readOnly: false,

	    /**
	     * @property {Boolean|Function} [noButtonBar=false] Should we not render the button bar
	     */
	    noButtonBar: false,

	    /**
	     * @property {Boolean|Function} [noCancelButton=false] Should we not render a cancel button
	     */
	    noCancelButton: false,

	    /**
	     * @property {String} [save="Save"] The text on the save button
	     */
	    save: null,

	    /**
	     * @property {String} [cancel="Cancel"] The text on the cancel button
	     */
	    cancel: null,

	    /**
	     * @property {Boolean|Function} [danger=false] To use button-error to stylish the submit button
	     * instead of button-primary.
	     */
	    danger: false,

	    /**
	     * @property {String|Function} [layout=""] A layout CSS class to add to the form
	     */
	    layout: '',

	    /**
	     * @property {Number} [step] The step this form is in the context of a wizard
	     */
	    step: undefined,

	    /**
	     * @property {Number} [totalSteps] The total numbers of steps the wizard this form is a part of has
	     */
	    totalSteps: undefined,

	    /**
	     * @property {String|Function} [title] The form's title
	     */
	    title: null,

	    /**
	     * @property {String|Function} [subtitle] The form's subtitle
	     */
	    subtitle: null,

	    /**
	     * @property {Boolean} [autoSave=false]
	     * auto-save the model when hitting save.
	     * Trigger a `saved` event when done
	     */
	    autoSave: false,

	    /**
	     * @property {Boolean|Function} [scrollOnError=true] Scroll to the top of the form on error
	     */
	    scrollOnError: true,

	    /**
	     * @property {Boolean|Function} [showErrors=true] Show the error banner upon error
	     */
	    showErrors: true,

	    /**
	     * @property {String} [resizeSelector='.o-form-content'] The form's scrollable area
	     */
	    resizeSelector: '.o-form-content',

	    /**
	     * @property {Boolean} [hasSavingState=false] Sets whether or not the form shows the saving state when
	     * the model is saved.  Has no effect on setSavingState and clearSavingState as those are manual calls
	     * to trigger/clear the saving state.
	     */

	    /**
	     * Get an attribute value from options or instance
	     * Prefer options value over instance value
	     * @param  {String} name Name of the attribute
	     * @param  {Object} defaultValue the default value to return if the attribute is not found
	     * @return {Object} The value
	     */
	    getAttribute: function (name, defaultValue) {
	      var value = _.resultCtx(this.options, name, this);
	      if (_.isUndefined(value)) {
	        value = _.result(this, name);
	      }
	      return !_.isUndefined(value) ? value : defaultValue;
	    },

	    /**
	     * Does this form has a "read" mode
	     * @return {Boolean}
	     */
	    hasReadMode: function () {
	      return !!this.getAttribute('read');
	    },

	    /**
	     * Is this form in "read only" mode
	     * @return {Boolean}
	     */
	    isReadOnly: function () {
	      return !!this.getAttribute('readOnly');
	    },

	    /**
	     * Does this form have a button bar
	     * @return {Boolean}
	     */
	    hasButtonBar: function () {
	      return !(this.getAttribute('noButtonBar') || this.isReadOnly());
	    },

	    render: function () {

	      this.__readModeBar && this.__readModeBar.remove();
	      if (this.hasReadMode() && !this.isReadOnly()) {
	        var readModeBar = ReadModeBar.extend({
	          formTitle: this.getAttribute('title', '')
	        });
	        this.__readModeBar = this.add(readModeBar, '.o-form-title-bar').last();
	      }

	      var html = TemplateUtil.tpl(template)({
	        layout: this.getAttribute('layout', ''),
	        title: this.getAttribute('title', '', true),
	        subtitle: this.getAttribute('subtitle', '', true),
	        hasReadMode: this.hasReadMode()
	      });

	      this.$el.html(html);
	      delete this.template;

	      BaseView.prototype.render.apply(this, arguments);

	      this.__applyMode();

	      return this;
	    },

	    /**
	     * Changes form UI to indicate saving.  Disables all inputs and buttons.  Use this function if you have set
	     * hasSavingState to false on the the form
	     * @private
	     */
	    __setSavingState: function () {
	      this.model.trigger('form:set-saving-state');
	      this.$el.addClass('o-form-saving');
	    },

	    /**
	     * Changes form UI back to normal from the saving state.  Use this function if you are have set hasSavingState
	     * to false on the form
	     * @private
	     */
	    __clearSavingState: function () {
	      this.model.trigger('form:clear-saving-state');
	      this.$el.removeClass('o-form-saving');
	    },

	    /**
	     * Toggles the visibility of the bottom button bar
	     * @private
	     */
	    __toggleToolbar: function () {
	      this.__toolbar && this.__toolbar.remove();
	      if (this.hasButtonBar() && this._editMode()) {
	        this.__toolbar = this.__createToolbar();
	        this.add(this.__toolbar, '');
	      }
	      this.trigger('resize');
	    },

	    /**
	     * Cancels this form
	     * - Reset the model to the previous state
	     * - Clears all errors
	     * - Triggers a `cancel` event
	     * - Sets the model to read mode (if applicable)
	     * @private
	     * @fires cancel
	     */
	    __cancel: function () {
	      /* eslint max-statements: [2, 12] */
	      var edit = this.model.get('__edit__');
	      this.model.clear({silent: true});
	      var data;
	      if (this.model.sanitizeAttributes) {
	        data = this.model.sanitizeAttributes(this.__originalModel);
	      }
	      else {
	        data = _.clone(this.__originalModel);
	      }
	      this.model.set(data, {silent: true});
	      this.trigger('cancel', this.model);
	      this.model.trigger('cache:clear');
	      if (edit) {
	        this.model.set('__edit__', false, {silent: true});
	        this.model.trigger('change:__edit__', this.model, false);
	      }
	      this.clearErrors();
	    },

	    /**
	     * Runs {@link #validate} to check the model state
	     * triggers an "invalid" event on the model if validation fails
	     * @returns {Boolean}
	     */

	    isValid: function () {
	      var res,
	          self = this;

	      function validateArray(arr) {
	        return _.reduce(arr, function (memo, fieldName) {
	          return _.extend(memo, self.model.validateField(fieldName));
	        }, {});
	      }

	      if (_.isUndefined(this.validate)) {
	        return this.model.isValid();
	      }
	      else if (_.isFunction(this.validate)) {
	        res = this.validate();
	      }
	      else if (_.isArray(this.validate)) {
	        res = validateArray(this.validate);
	      }
	      else if (this.validate === 'local') {
	        res = validateArray(this.getInputs().map(function (input) {
	          return input.options.name;
	        }));
	      }

	      if (!_.isEmpty(res)) {
	        this.model.trigger('invalid', this.model, res);
	        return false;
	      }
	      else {
	        return true;
	      }
	    },

	    /**
	     * A throttled function that saves the form not more than once every 100 ms
	     * Basically all this method does is trigger a `save` event
	     * @fires save
	     * @private
	     */
	    __save: function () {
	      this.clearErrors();
	      if (this.isValid()) {
	        this.trigger('save', this.model);
	      }
	    },

	    /**
	     * In the context of a wizard, go to previous state
	     * Technically all this method does is trigger a `previous` event
	     * @param  {Event} e
	     * @private
	     */
	    __previous: function () {
	      this.trigger('previous', this.model);
	    },

	    /**
	     * Renders the form in the correct mode based on the model.
	     * @private
	     */
	    __applyMode: function () {
	      this.clearErrors();
	      this.__toggleToolbar();

	      if (this._editMode()) {
	        this.$el.addClass('o-form-edit-mode');
	        this.$el.removeClass('o-form-read-mode');
	        this.$('.o-form-content').removeClass('rounded-btm-4');
	        this.focus();
	      }
	      else {
	        this.$el.removeClass('o-form-edit-mode');
	        this.$el.addClass('o-form-read-mode');
	        this.$('.o-form-content').addClass('rounded-btm-4');
	      }
	    },

	    /**
	     * Is the form in edit mode
	     * @return {Boolean}
	     * @private
	     */
	    _editMode: function () {
	      return this.model.get('__edit__') || !this.hasReadMode();
	    },

	    /**
	     * Function can be overridden to alter error summary
	     * @param {Object} responseJSON
	     */
	    parseErrorMessage: _.identity,

	    /**
	     * Show an error message based on an XHR error
	     * @param  {Okta.BaseModel} model the model
	     * @param  {jqXHR} xhr The jQuery XmlHttpRequest Object
	     * @private
	     */
	    __showErrors: function (model, resp, showBanner) {
	      this.trigger('error', model);

	      /* eslint max-statements: 0 */
	      if (this.getAttribute('showErrors')) {

	        var errorSummary;

	        // trigger events for field validation errors
	        var validationErrors = ErrorParser.parseFieldErrors(resp);
	        if (_.size(validationErrors)) {
	          _.each(validationErrors, function (errors, field) {
	            this.model.trigger('form:field-error', this.__errorFields[field] || field, _.map(errors, function (error) {
	              return (/^model\.validation/).test(error) ? StringUtil.localize(error) : error;
	            }));
	          }, this);
	        }
	        else {
	          var responseJSON = ErrorParser.getResponseJSON(resp);
	          responseJSON = this.parseErrorMessage(responseJSON);
	          errorSummary = responseJSON && responseJSON.errorSummary;
	        }

	        // show the error message
	        if (showBanner) {
	          this.$('.o-form-error-container').addClass('o-form-has-errors');
	          this.add(ErrorBanner, '.o-form-error-container', {options: {errorSummary: errorSummary}});
	        }

	        // slide to and focus on the error message
	        if (this.getAttribute('scrollOnError')) {
	          var $el = $('#' + this.id + ' .o-form-error-container');
	          $el.length && $('html, body').animate({scrollTop: $el.offset().top}, 400);
	        }

	        this.model.trigger('form:resize');

	      }
	    },

	    /**
	     * Clears the error banner
	     * @private
	     */
	    clearErrors: function () {
	      this.$('.o-form-error-container').removeClass('o-form-has-errors');
	      this.model.trigger('form:clear-errors');
	      this.model.trigger('form:resize');
	    },


	    /**
	     * Toggles between edit and read mode
	     */
	    toggle: function () {
	      this.model.set('__edit__', !this.hasReadMode() || !this.model.get('__edit__'));
	      return this;
	    },

	    __addLayoutItem: function (input) {
	      if (InputFactory.supports(input)) {
	        this.addInput(input);
	      }
	      else {
	        this.__addNonInputLayoutItem(input);
	      }
	    },

	    __addNonInputLayoutItem: function (item) {
	      var itemOptions = _.omit(item, 'type');
	      switch (item.type) {
	      case 'sectionTitle':
	        this.addSectionTitle(item.title, _.omit(itemOptions, 'title'));
	        break;
	      case 'divider':
	        this.addDivider(itemOptions);
	        break;
	      default:
	        throw new Error('unknown input: ' + item.type);
	      }
	    },

	    /**
	     * Adds a view to the buttons tool bar
	     * @param {Object} params parameterized button options
	     * @param {Object} options options to send to {@link Okta.View#add}
	     */
	    addButton: function (params, options) {
	      this.__toolbar && this.__toolbar.addButton(params, options);
	      this.__buttons.push([params, options]);
	    },

	    /**
	     * Adds a divider
	     */
	    addDivider: function (options) {
	      this.add('<div class="okta-form-divider form-divider"></div>');
	      FormUtil.applyShowWhen(this.last(), options && options.showWhen);
	      return this;
	    },

	    /**
	     * Adds section header
	     * @param {String} title
	     */
	    addSectionTitle: function (title, options) {
	      this.add(TemplateUtil.tpl('<h2 class="o-form-head">{{title}}</h2>')({title: title}));
	      FormUtil.applyShowWhen(this.last(), options && options.showWhen);
	      return this;
	    },

	    /**
	     * Add a form input
	     * @param {Object} options Options to describe the input
	     * @param {String} options.type The input type.
	     * The options are: `text`, `textarea`, `select`, `checkbox`, `radio`,
	     * `password`, `number`, `textselect`, `date`, `grouppicker`, `su-orgspicker`
	     * `file/image`, `file/cert`
	     * @param {String} options.name The name of the model field this input mutates
	     * @param {String|Function} [options.label]
	     * The input label text.
	     * When passed as a function, will invoke the function (in the context of the {@link InputLabel})
	     * on render time, and use the returned value.
	     * @param {String} [options.sublabel] The input sub label text
	     * @param {String} [options.tooltip] A popover tooltip to be displayed next to the label
	     * @param {String} [options.placeholder] Placeholder text.
	     * @param {String} [options.explain] Explanation text to render below the input
	     * @param {Okta.View} [options.customExplain] A custom view to render below the input (deprecated)
	     * @param {Boolean} [options.disabled=false] Make this input disabled
	     * @param {Boolean} [options.wide=false] Use a wide input layout
	     * @param {Boolean} [options.label-top=false] position label on top of an input
	     * @param {Number} [options.multi] have multiple in-line inputs. useful when `input` is passed as an array of inputs
	     * @param {String} [options.errorField] The API error field here that maps to this input
	     * @param {Boolean} [options.inlineValidation=true] Validate input on focusout

	     * @param {Object} [options.options]
	     * In the context of `radio` and `select`, a key/value set of options
	     *
	     * @param {Object} [options.params]
	     * Widget specific parameters. Varies per input.
	     *
	     * @param {BaseInput|Object[]} [options.input]
	     * - A custom input "class" or instance - preferably a **class**, so we can automagically assign the right
	     * parameters when initializing it
	     * - An array of input definition object literals (such as this one)
	     *
	     * @param {Object} [options.showWhen]
	     * Setting to define when to show (or hide) the input
	     * In the following example the field will be visible when `advanced` is set to `true`
	     * and `mode` is set to `"ON"`:
	     *
	     * ```javascript
	     * showWhen: {
	     *   'advanced': true,
	     *   'mode': function (value) {
	     *     return value == 'ON' // this is identical to this.model.get('mode') == 'ON'
	     *   }
	     * }
	     * ```
	     * The input is visible by default
	     *
	     * @param {Object} [options.bindings]
	     * Bind a certain model attribute to a callback function, so the function is being called on render,
	     * and any time this model field changes.
	     * This is similar to `showWhen` but is not limited to toggling.
	     *
	     * ```javascript
	     * bindings: {
	     *   'status mode': function (status, mode) {
	     *      var labelView = this.getLabel();
	     *      if (status == 1) {
	     *        labelView.options.label = 'Something';
	     *      }
	     *      else {
	     *        labelView.options.label = mode;
	     *      }
	     *      labelView.render();
	     *   }
	     * }
	     * ```
	     *
	     * @param {Function} [options.render]
	     * A post-render hook that will run upon render on InputWrapper
	     *
	     * @param {String|Function} className   A className to apply on the {@link InputWrapper}
	     *
	     * @param {Function} [options.initialize]
	     * An `initialize` function to run when initializing the {@link InputWrapper}
	     * Useful for state mutation on start time, and complex state logic
	     */
	    addInput: function (_options) {

	      _options = _.clone(_options);

	      FormUtil.validateInput(_options, this.model);

	      var inputsOptions = FormUtil.generateInputOptions(_options, this, this.__createInput).reverse(),
	          inputs = _.map(inputsOptions, this.__createInput, this);

	      _.each(inputsOptions, function (input) {
	        if (input.errorField) {
	          this.__errorFields[input.errorField] = input.name;
	        }
	      }, this);

	      var options = {
	        inputId: _.last(inputs).options.inputId,
	        input: inputs,
	        multi: inputsOptions.length > 1 ? inputsOptions.length : undefined
	      };
	      _.extend(options, _.omit(this.options, 'input'), _.omit(_options, 'input'));

	      var inputWrapper = this.__createWrapper(options);
	      if (options.label !== false) {
	        inputWrapper.add(this.__createLabel(options));
	      }
	      inputWrapper.add(this._createContainer(options));
	      inputWrapper.type = options.type || options.input.type || 'custom';

	      var args = [inputWrapper].concat(_.drop(arguments, 1));
	      return this.add.apply(this, args);
	    },

	    /**
	     * @private
	     */
	    __createInput: function (options) {
	      options = _.pick(options, FormUtil.INPUT_OPTIONS);
	      return InputFactory.create(options);
	    },

	    /**
	     * @private
	     */
	    __createWrapper: function (options) {
	      options = _.pick(options, FormUtil.WRAPPER_OPTIONS);
	      return new InputWrapper(options);
	    },

	    /**
	     * @private
	     */
	    __createLabel: function (options) {
	      options = _.pick(options, FormUtil.LABEL_OPTIONS);
	      return new InputLabel(options);
	    },

	    /**
	     * @private
	     */
	    _createContainer: function (options) {
	      options = _.pick(options, FormUtil.CONTAINER_OPTIONS);
	      return new InputContainer(options);
	    },

	    /**
	     * Stores the current attributes of the model to a private property
	     * @param  {Okta.BaseModel} model The model
	     * @private
	     */
	    __saveModelState: function (model) {
	      this.__originalModel = model.clone().attributes;
	    },

	    /**
	     * @override
	     * @ignore
	     */
	    add: function () {
	      var args = _.toArray(arguments);
	      typeof args[1] === 'undefined' && (args[1] = '> div.o-form-content > .o-form-fieldset-container');
	      return BaseView.prototype.add.apply(this, args);
	    },

	    /**
	     * Set the focus on the first input in the form
	     */
	    focus: function () {
	      var first = this.getInputs().first();
	      if (first && first.focus) {
	        first.focus();
	      }
	      return this;
	    },

	    /**
	     * Disable all inputs in the form
	     * @deprecated not currently in use
	     */
	    disable: function () {
	      this.invoke('disable');
	      return this;
	    },

	    /**
	     * Enable all inputs in the form
	     * @deprecated not currently in use
	     */
	    enable: function () {
	      this.invoke('enable');
	    },

	    /**
	     * Set the max-height for o-form-content class container within the form if a height is provided,
	     * otherwise, get its computed inner height
	     * @param {Number} the height in pixel to set for class o-form-content
	     * @return {Number}
	     */
	    contentHeight: function (height) {
	      var content = this.$('.o-form-content');
	      if (_.isNumber(height)) {
	        content.css('max-height', height);
	      } else {
	        return content.height();
	      }
	    },

	    /**
	     * Get only the input children
	     * @return {InputWrapper[]} An underscore wrapped array of {@link InputWrapper} instances
	     */
	    getInputs: function () {
	      return _(this.filter(function (view) {
	        return view instanceof InputWrapper;
	      }));
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(49),
	  __webpack_require__(13),
	  __webpack_require__(48)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, TemplateUtil, Logger, BaseView) {

	  function extendsBaseView(obj) {
	    return obj instanceof BaseView || obj.prototype instanceof BaseView;
	  }

	  /**
	   * @class InputContainer
	   * @private
	   *
	   * TODO: OKTA-80796
	   * Attention: Please change with caution since this is used in other places
	   */
	  return BaseView.extend({

	    attributes: function () {
	      return {
	        'data-se': 'o-form-input-container'
	      };
	    },

	    className: function () {
	      var className = 'o-form-input';
	      if (this.options.wide) {
	        className += ' o-form-wide';
	      }
	      if (_.contains([1, 2, 3, 4], this.options.multi)) {
	        className += ' o-form-multi-input-' + this.options.multi;
	        if (_.isArray(this.options.input)) {
	          var inputGroup = _.find(this.options.input, function (input) {
	            return _.contains(['text+select', 'select+text'], input.options.type);
	          });
	          inputGroup && (className += ' o-form-multi-input-group-' + this.options.multi);
	        }
	      }
	      return className;
	    },

	    _getNames: function () {
	      /*eslint complexity: 0 */
	      var names = _.isArray(this.options.name) ? this.options.name : [this.options.name];
	      if (this.options.type == 'group') {
	        names.push.apply(names, _.pluck(this.options.input[0].options.params.inputs, 'name'));
	      }
	      else if (_.isArray(this.options.name)) {
	        if (this.options.input && this.options.input.options && this.options.input.options.name) {
	          names.push(this.options.input.options.name);
	        }
	      }
	      else if (this.options.input) {
	        if (_.isArray(this.options.input)) {
	          _.each(this.options.input, function (inputItem) {
	            names.push(inputItem.options.name);
	          });
	        }
	        else {
	          names.push(this.options.input.options.name);
	        }
	      }
	      return _.uniq(_.compact(names));
	    },

	    constructor: function () {
	      /* eslint max-statements: [2, 18] */
	      BaseView.apply(this, arguments);

	      // we want to append the input *before* the explain text
	      if (this.options.input) {
	        if (_.isArray(this.options.input)) {
	          _.each(this.options.input, function (inputItem) {
	            this.add(inputItem, {prepend: true});
	          }, this);
	        } else {
	          this.add(this.options.input, {prepend: true});
	        }
	      }

	      this.__setExplain(this.options);

	      var names = this._getNames();

	      this.listenTo(this.model, 'form:field-error', function (name, errors) {
	        if (_.contains(names, name)) {
	          this.__setError(errors);
	        }
	      });

	      this.listenTo(this.model, 'form:clear-errors change:' + names.join(' change:'), this.__clearError);
	      this.listenTo(this.model, 'form:clear-error:' + names.join(' form:clear-error:'), this.__clearError);

	      if (_.resultCtx(this.options, 'autoRender', this)) {
	        this.listenTo(this.model, 'change:' + this.options.name, this.render);
	      }

	      this.__errorState = false;

	    },

	    /**
	     * Populates the explain on the input container (if it exists). There are
	     * two ways to use this:
	     * 1. Raw text - wraps in the correct html template
	     * 2. Custom html
	     *    - pass in a View class (preferred)
	     *    - pass in an instance of a View
	     * Some additional notes:
	     * - You can pass a function that returns any of the above
	     * - This maintains support for the deprecated "customExplain" property
	     *   that was used before. This pattern is superseded by explain, so use
	     *   that instead.
	     * @private
	     */
	    __setExplain: function (options) {
	      var explain;

	      // Deprecated - if you need custom html, use explain instead
	      if (options.customExplain) {
	        Logger.warn('Deprecated - use explain instead of customExplain');
	        this.add(this.options.customExplain);
	        return;
	      }

	      explain = options.explain;
	      if (_.isFunction(explain) && !extendsBaseView(explain)) {
	        explain = _.resultCtx(this.options, 'explain', this);
	      }
	      if (!explain) {
	        return;
	      }

	      if (extendsBaseView(explain)) {
	        this.template = '<p class="o-form-explain"></p>';
	        this.add(explain, '.o-form-explain');
	      }
	      else {
	        this.template = '<p class="o-form-explain">{{explain}}</p>';
	      }
	    },

	    /**
	     * Highlight the input as invalid (validation failed)
	     * Adds an explaination message of the error
	     * @private
	     */
	    __setError: function (errors) {

	      this.__errorState = true;
	      this.$el.addClass('o-form-has-errors');

	      var tmpl = [
	        '<p class="okta-form-input-error o-form-input-error o-form-explain" role="alert">',
	        '<span class="icon icon-16 error-16-small"></span>',
	        '{{text}}',
	        '</p>'
	      ].join('');

	      var html = TemplateUtil.tpl(tmpl)({text: errors.join(', ')});
	      var $elExplain = this.$('.o-form-explain').not('.o-form-input-error').first();

	      if ($elExplain.length) {
	        $elExplain.before(html);
	      }
	      else {
	        this.$el.append(html);
	      }


	    },

	    /**
	     * Un-highlight the input and remove explaination text
	     * @private
	     */
	    __clearError: function () {
	      if (this.__errorState) {
	        this.$('.o-form-input-error').remove();
	        this.$el.removeClass('o-form-has-errors');
	        this.__errorState = false;
	        _.defer(_.bind(function () {
	          this.model.trigger('form:resize');
	        }, this));
	      }
	    },


	    focus: function () {
	      this.each(function (view) {
	        if (view.focus) {
	          return view.focus();
	        }
	      });

	      return this;
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: 0 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(63),
	  __webpack_require__(62),
	  __webpack_require__(66),
	  __webpack_require__(67),
	  __webpack_require__(69),
	  __webpack_require__(71),
	  __webpack_require__(72),
	  __webpack_require__(73),
	  __webpack_require__(74),
	  __webpack_require__(75),
	  __webpack_require__(61),
	  __webpack_require__(76),
	  __webpack_require__(77),
	  __webpack_require__(78),
	  __webpack_require__(79),
	  __webpack_require__(80),
	  __webpack_require__(81),
	  __webpack_require__(82),
	  __webpack_require__(86),
	  __webpack_require__(87),
	  __webpack_require__(92)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseInput, TextBox, TextArea, Select, Radio, CheckBox, TextSelect, TextPlusSelect, DateBox, NumberBox,
	          GroupPicker, UserPicker, AppPicker, AppInstancePicker, SUOrgsPicker, ZonePicker, ListInput, InputGroup,
	          SimpleCheckBoxSet, ImageFileUploader, CertificationFileUploader) {

	  var inputTypesMap = {
	    'file/image': ImageFileUploader,
	    'file/cert': CertificationFileUploader,
	    'select': Select,
	    'textarea': TextArea,
	    'radio': Radio,
	    'checkbox': CheckBox,
	    'text': TextBox,
	    'password': TextBox,
	    'number': NumberBox,
	    'textselect': TextSelect,
	    'text+select': TextPlusSelect,
	    'select+text': TextPlusSelect,
	    'date': DateBox,
	    'grouppicker': GroupPicker,
	    'userpicker': UserPicker,
	    'apppicker': AppPicker,
	    'appinstancepicker': AppInstancePicker,
	    'su-orgspicker': SUOrgsPicker,
	    'zonepicker': ZonePicker,
	    'list': ListInput,
	    'group': InputGroup,
	    'checkboxset': SimpleCheckBoxSet
	  };

	  function createInput(Input, options) {
	    if (Input.prototype instanceof BaseInput) {
	      return new Input(_.omit(options, 'input'));
	    }
	    else {
	      return Input;
	    }
	  }

	  function create(options) {
	    /* eslint complexity: 0 */
	    options = _.clone(options);

	    if (options.input) {
	      return createInput(options.input, options);
	    }

	    var Input;
	    if (inputTypesMap[options.type]) {
	      Input = inputTypesMap[options.type];
	    }
	    else {
	      throw new Error('unknown input: ' + options.type);
	    }
	    return createInput(Input, options);
	  }

	  function supports(input) {
	    if (input.input || input.type in inputTypesMap) {
	      return true;
	    }
	    return false;
	  }

	  return {
	    create: create,
	    supports: supports
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 61 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(49),
	  __webpack_require__(63),
	  __webpack_require__(64),
	  __webpack_require__(65)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (TemplateUtil, BaseInput, Keys) {

	  var className = 'okta-form-input-field input-fix';

	  return BaseInput.extend({

	    template: TemplateUtil.tpl('<input type="{{type}}" placeholder="{{placeholder}}"\
	      name="{{name}}" id="{{inputId}}" value="{{value}}"/>'),

	    /**
	    * @Override
	    */
	    events: {
	      'input input': 'update',
	      'change input': 'update',
	      'keydown input': 'update',
	      'keyup input': function (e) {
	        if (Keys.isEnter(e)) {
	          this.model.trigger('form:save');
	        }
	        else if (Keys.isEsc(e)) {
	          this.model.trigger('form:cancel');
	        }
	      }
	    },

	    constructor: function () {
	      BaseInput.apply(this, arguments);
	      this.$el.addClass('o-form-control');
	    },

	    /**
	    * @Override
	    */
	    editMode: function () {
	      this.$el.addClass(className);
	      BaseInput.prototype.editMode.apply(this, arguments);
	      this.$('input').placeholder();
	    },

	    /**
	    * @Override
	    */
	    readMode: function () {
	      BaseInput.prototype.readMode.apply(this, arguments);
	      if (this.options.type == 'password') {
	        this.$el.text('********');
	      }
	      this.$el.removeClass(className);
	    },

	    /**
	    * @Override
	    */
	    val: function () {
	      //IE will only read clear text pw if type="password" is explicitly in selector
	      return this.$('input[type="' + this.options.type + '"]').val();
	    },

	    /**
	    * @Override
	    */
	    focus: function () {
	      return this.$('input').focus();
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-statements: [2, 13] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(48)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView) {

	  /**
	   * @class BaseInput
	   * @private
	   * An abstract object that defines an input for {@link Okta.Form}
	   *
	   * BaseInputs are typically not created directly, but being passed to {@link Okta.Form#addInput}
	   * @extends Okta.View
	   */

	  return BaseView.extend({

	    tagName: 'span',

	    attributes: function () {
	      return {
	        'data-se': 'o-form-input-' + this.getNameString()
	      };
	    },

	    /**
	    * default placeholder text when options.placeholder is not defined
	    */
	    defaultPlaceholder: '',

	    constructor: function (options) {
	      options = _.defaults(
	        options || {},
	        {
	          inputId: options.id || _.uniqueId('input'),
	          placeholder: this.defaultPlaceholder,
	          inlineValidation: true
	        }
	      );

	      delete options.id;

	      // decorate the `enable` and `disable` and toggle the `o-form-disabled` class.
	      // so we wont need to worry about this when overriding the methods
	      var self = this;
	      _.each({enable: 'removeClass', disable: 'addClass'}, function (method, action) {
	        self[action] = _.wrap(self[action], function (fn) {
	          fn.apply(self, arguments);
	          self.$el[method]('o-form-disabled');
	        });
	      });

	      BaseView.call(this, options);

	      if (_.result(options, 'readOnly') !== true && _.result(options, 'read') === true) {
	        this.listenTo(this.model, 'change:__edit__', this.render);
	      }

	      if (_.isFunction(this.focus)) {
	        this.focus = _.debounce(_.bind(this.focus, this), 50);
	      }

	      if (_.result(options, 'inlineValidation')) {
	        this.$el.on('focusout', ':input', _.bind(this.validate, this));
	      }

	      this.addModelListeners();
	      this.$el.addClass('o-form-input-name-' + this.getNameString());
	    },

	    toModelValue: function () {
	      var value = this.val();
	      if (_.isFunction(this.to)) {
	        value = this.to.call(this, value);
	      }
	      if (_.isFunction(this.options.to)) {
	        value = this.options.to.call(this, value);
	      }
	      return value;
	    },

	    /**
	     * updates the model with the input's value
	     */
	    update: function () {
	      this.model.set(this.options.name, this.toModelValue());
	    },

	    /**
	     * Is the input in edit mode
	     * @return {Boolean}
	     */
	    isEditMode: function () {
	      var ret = !_.result(this.options, 'readOnly') &&
	        (_.result(this.options, 'read') !== true || this.model.get('__edit__') === true);
	      return ret;
	    },

	    /**
	     * Renders the input
	     * @readonly
	     */
	    render: function () {
	      this.preRender();
	      var params = this.options.params;
	      this.options.params = _.resultCtx(this.options, 'params', this);

	      if (this.isEditMode()) {
	        this.editMode();
	        if (_.resultCtx(this.options, 'disabled', this)) {
	          this.disable();
	        } else {
	          this.enable();
	        }
	      }
	      else {
	        this.readMode();
	      }

	      this.options.params = params;
	      this.postRender();

	      return this;
	    },

	    /**
	     * checks if the current value in the model is valid for this field
	     */
	    validate: function () {
	      if (!this.model.get('__pending__') && this.isEditMode() && _.isFunction(this.model.validateField)) {
	        var validationError = this.model.validateField(this.options.name);
	        if (validationError) {
	          _.delay(function () {
	            this.model.trigger('form:clear-error:' + this.options.name);
	            this.model.trigger('invalid', this.model, validationError, false);
	          }.bind(this), 100);
	        }
	      }
	    },

	    /**
	    * Add model event listeners
	    */
	    addModelListeners: function () {
	      this.listenTo(this.model, 'form:field-error', function (name) {
	        if (this.options.name === name) {
	          this.__markError();
	        }
	      });
	      this.listenTo(this.model, 'form:clear-errors change:' + this.options.name, this.__clearError);
	      this.listenTo(this.model, 'form:clear-error:' + this.options.name, this.__clearError);
	    },

	    /**
	    * The value of the input
	    * @return {Mixed}
	    */
	    val: function () {
	      throw new Error('val() is an abstract method');
	    },

	    /**
	    * Set focus on the input
	    */
	    focus: function () {
	      throw new Error('focus() is an abstract method');
	    },

	    /**
	    * Default value in read mode
	    * When model has no value for the field
	    */
	    defaultValue: function () {
	      return '';
	    },

	    /**
	    * Renders the input in edit mode
	    */
	    editMode: function () {
	      var options = _.extend({}, this.options, {
	        value: this.getModelValue()
	      });
	      this.$el.html(this.template(options));
	      this.options.multi && this.$el.removeClass('margin-r');
	      return this;
	    },

	    /**
	    * Renders the readable value of the input in read mode
	    */
	    readMode: function () {
	      this.$el.text(this.getReadModeString());
	      this.$el.removeClass('error-field');
	      this.options.multi && this.$el.addClass('margin-r');
	      return this;
	    },

	    getReadModeString: function () {
	      var readModeStr = _.resultCtx(this.options, 'readModeString', this);
	      if (readModeStr) {
	        return readModeStr;
	      }
	      return this.toStringValue();
	    },

	    /**
	     * The model value off the field associated with the input
	     * @return {Mixed}
	     */
	    getModelValue: function () {
	      var value = this.model.get(this.options.name);

	      if (_.isFunction(this.from)) {
	        value = this.from.call(this, value);
	      }
	      if (_.isFunction(this.options.from)) {
	        value = this.options.from.call(this, value);
	      }
	      return value;
	    },

	    /*
	    * convenience method to get the textual value from the model
	    * will return the textual label rather than value in case of select/radio
	    * @return {String}
	    */
	    toStringValue: function () {
	      var value = this.getModelValue();
	      if (this.options.options) { // dropdown or radio
	        value = this.options.options[value];
	      }
	      return value || this.defaultValue();
	    },

	    /**
	     * Triggers a form:resize event in order to tell dialogs content size has changed
	     */
	    resize: function () {
	      this.model.trigger('form:resize');
	    },

	    /**
	     * Disable the input
	     */
	    disable: function () {
	      this.$(':input').prop('disabled', true);
	    },

	    /**
	     * Enable the input
	     */
	    enable: function () {
	      this.$(':input').prop('disabled', false);
	    },

	    /**
	     * Change the type of the input field. (e.g., text <--> password)
	     * @param type
	     */
	    changeType: function (type) {
	      this.$(':input').prop('type', type);
	      // Update the options so that it keeps the uptodate state
	      this.options.type = type;
	    },

	    getNameString: function () {
	      if (_.isArray(this.options.name)) {
	        return this.options.name.join('-');
	      }
	      return this.options.name;
	    },

	    __markError: function () {
	      this.$el.addClass('o-form-has-errors');
	    },

	    __clearError: function () {
	      this.$el.removeClass('o-form-has-errors');
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	!(module.exports = {
	  UP: 38,
	  DOWN: 40,
	  DEL: 46,
	  TAB: 9,
	  RETURN: 13,
	  ENTER: 13,
	  ESC: 27,
	  COMMA: 188,
	  PAGEUP: 33,
	  PAGEDOWN: 34,
	  SPACE: 32,
	  BACKSPACE: 8,
	  __isKey: function (e, key) {
	    return (e.which || e.keyCode) == this[key];
	  },
	  isEnter: function (e) {
	    return this.__isKey(e, 'ENTER');
	  },
	  isEsc: function (e) {
	    return this.__isKey(e, 'ESC');
	  },
	  isSpaceBar: function (e) {
	    return this.__isKey(e, 'SPACE');
	  }
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	var jQuery = __webpack_require__(6);

	/*! http://mths.be/placeholder v2.0.7 by @mathias */
	;(function(window, document, $) {

		var isInputSupported = 'placeholder' in document.createElement('input');
		var isTextareaSupported = 'placeholder' in document.createElement('textarea');
		var prototype = $.fn;
		var valHooks = $.valHooks;
		var propHooks = $.propHooks;
		var hooks;
		var placeholder;

		if (isInputSupported && isTextareaSupported) {

			placeholder = prototype.placeholder = function() {
				return this;
			};

			placeholder.input = placeholder.textarea = true;

		} else {

			placeholder = prototype.placeholder = function() {
				var $this = this;
				$this
					.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
					.not('.placeholder')
					.bind({
						'focus.placeholder': clearPlaceholder,
						'blur.placeholder': setPlaceholder
					})
					.data('placeholder-enabled', true)
					.trigger('blur.placeholder');
				return $this;
			};

			placeholder.input = isInputSupported;
			placeholder.textarea = isTextareaSupported;

			hooks = {
				'get': function(element) {
					var $element = $(element);

					var $passwordInput = $element.data('placeholder-password');
					if ($passwordInput) {
						return $passwordInput[0].value;
					}

					return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
				},
				'set': function(element, value) {
					var $element = $(element);

					var $passwordInput = $element.data('placeholder-password');
					if ($passwordInput) {
						return $passwordInput[0].value = value;
					}

					if (!$element.data('placeholder-enabled')) {
						return element.value = value;
					}
					if (value == '') {
						element.value = value;
						// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
						if (element != safeActiveElement()) {
							// We can't use `triggerHandler` here because of dummy text/password inputs :(
							setPlaceholder.call(element);
						}
					} else if ($element.hasClass('placeholder')) {
						clearPlaceholder.call(element, true, value) || (element.value = value);
					} else {
						element.value = value;
					}
					// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
					return $element;
				}
			};

			if (!isInputSupported) {
				valHooks.input = hooks;
				propHooks.value = hooks;
			}
			if (!isTextareaSupported) {
				valHooks.textarea = hooks;
				propHooks.value = hooks;
			}

			$(function() {
				// Look for forms
				$(document).delegate('form', 'submit.placeholder', function() {
					// Clear the placeholder values so they don't get submitted
					var $inputs = $('.placeholder', this).each(clearPlaceholder);
					setTimeout(function() {
						$inputs.each(setPlaceholder);
					}, 10);
				});
			});

			// Clear placeholder values upon page reload
			$(window).bind('beforeunload.placeholder', function() {
				$('.placeholder').each(function() {
					this.value = '';
				});
			});

		}

		function args(elem) {
			// Return an object of element attributes
			var newAttrs = {};
			var rinlinejQuery = /^jQuery\d+$/;
			$.each(elem.attributes, function(i, attr) {
				if (attr.specified && !rinlinejQuery.test(attr.name)) {
					newAttrs[attr.name] = attr.value;
				}
			});
			return newAttrs;
		}

		function clearPlaceholder(event, value) {
			var input = this;
			var $input = $(input);
			if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
				if ($input.data('placeholder-password')) {
					$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
					// If `clearPlaceholder` was called from `$.valHooks.input.set`
					if (event === true) {
						return $input[0].value = value;
					}
					$input.focus();
				} else {
					input.value = '';
					$input.removeClass('placeholder');
					input == safeActiveElement() && input.select();
				}
			}
		}

		function setPlaceholder() {
			var $replacement;
			var input = this;
			var $input = $(input);
			var id = this.id;
			if (input.value == '') {
				if (input.type == 'password') {
					if (!$input.data('placeholder-textinput')) {
						try {
							$replacement = $input.clone().attr({ 'type': 'text' });
						} catch(e) {
							$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
						}
						$replacement
							.removeAttr('name')
							.data({
								'placeholder-password': $input,
								'placeholder-id': id
							})
							.bind('focus.placeholder', clearPlaceholder);
						$input
							.data({
								'placeholder-textinput': $replacement,
								'placeholder-id': id
							})
							.before($replacement);
					}
					$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
					// Note: `$input[0] != input` now!
				}
				$input.addClass('placeholder');
				$input[0].value = $input.attr('placeholder');
			} else {
				$input.removeClass('placeholder');
			}
		}

		function safeActiveElement() {
			// Avoid IE9 `document.activeElement` of death
			// https://github.com/mathiasbynens/jquery-placeholder/pull/99
			try {
				return document.activeElement;
			} catch (err) {}
		}

	}(this, document, jQuery));

	}.call(window));

/***/ },
/* 66 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(64),
	  __webpack_require__(49),
	  __webpack_require__(63),
	  __webpack_require__(68)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, Keys, TemplateUtil, BaseInput) {

	  var template = TemplateUtil.tpl('<select id="{{inputId}}" name="{{name}}"></select>');
	  var option = TemplateUtil.tpl('<option value="{{key}}">{{value}}</option>');

	  // Chosen has known problems when it's at the bottom of a container that has
	  // overflow:hidden set. Because it attaches to the parent container, its
	  // dropdown will be cut off in the UI. Any modal with a chosen select element
	  // at the bottom will manifest this behavior.
	  //
	  // The fix (aside from replacing Chosen) is to change Chosen's behavior -
	  // use the existing styles, but attach it to 'body' and position it correctly
	  // so that it is not affected by a parent overflow.
	  //
	  // More details can be found in OKTA-46489, OKTA-83570
	  var CHOSEN_WINDOW_MARGIN = 20;
	  var CHOSEN_MAX_HEIGHT = 240;
	  var CHOSEN_Z_INDEX = 50000;

	  function defer(fn) {
	    if (this.params.autoWidth) {
	      return fn.call(this);
	    }
	    else {
	      return _.defer(_.bind(fn, this));
	    }
	  }

	  function findSelectWidth(self) {
	    self.$select.hide();
	    var select = $(self.$select[0]).hide();
	    $('body').append(select);
	    var width = self.params.width = (select.width() * 1.2) + 'px';
	    self.$el.append(select.show());
	    return width;
	  }

	  function recalculateChosen($chosen, $results, $clone) {
	    var offset = $clone.offset();
	    $chosen.css({
	      left: offset.left,
	      top: offset.top
	    });
	    // Update the max-height to fit within the constraints of the window. This
	    // is especially important for modals because page scrolling is disabled.
	    var $win = $(window),
	        rHeight = $results.outerHeight(),
	        rBottom = rHeight + $results.offset().top - $win.scrollTop(),
	        wHeight = $win.height() - CHOSEN_WINDOW_MARGIN,
	        maxHeight = Math.min(rHeight + wHeight - rBottom, CHOSEN_MAX_HEIGHT);
	    $results.css('max-height', maxHeight);
	  }

	  function fixChosenModal($select) {
	    var $chosen = $select.next('.chzn-container'),
	        $clone = $chosen.clone(),
	        $results = $chosen.find('.chzn-results');

	    // Use a hidden clone to maintain layout and calculate offset. This is
	    // necessary for more complex layouts (like adding a group rule) where
	    // the chosen element is floated.
	    $clone.css('visibility', 'hidden');
	    $clone.removeAttr('id');
	    $clone.find('li').removeAttr('id');

	    // Save the original styles - we'll revert to them when the select closes
	    var baseStyles = {
	      'left': $chosen.css('left'),
	      'top': $chosen.css('top'),
	      'position': $chosen.css('position'),
	      'float': $chosen.css('float'),
	      'z-index': $chosen.css('z-index')
	    };
	    $results.hide();

	    // Handler for any resize events that happen when the results list is open
	    var resizeHandler = _.debounce(function () {
	      recalculateChosen($chosen, $results, $clone);
	    }, 10);

	    // When the dropdown opens, attach it to body, with the correct absolute
	    // position coordinates
	    $select.on('liszt:showing_dropdown', function () {
	      $chosen.width($chosen.width());
	      $select.after($clone);
	      // .chzn-container can trigger the vertical scrollbar if it causes scrollHeight > window height after append to
	      // the body. Force top -999999 to avoid the scrollbar so $chosen can find the right offset for relocation.
	      $chosen.css({
	        'position': 'absolute',
	        'float': 'none',
	        'z-index': CHOSEN_Z_INDEX,
	        'top': -999999
	      });
	      $('body').append($chosen);
	      $results.show();
	      recalculateChosen($chosen, $results, $clone);
	      // Capture scroll events:
	      // - for forms that use fixed positioning (like editing attributes in
	      //   Profile Editor) - window scroll
	      // - for forms that are too long for the modal - o-form-content scroll
	      $select.parents().scroll(resizeHandler);
	      $(window).on('resize scroll', resizeHandler);
	    });

	    // When the dropdown closes or the element is removed, revert to the
	    // original styles and reattach it to its original placement in the dom.
	    $select.on('liszt:hiding_dropdown remove', function () {
	      $select.parents().off('scroll', resizeHandler);
	      $(window).off('resize scroll', resizeHandler);
	      $chosen.css(baseStyles);
	      $results.hide();
	      $results.css('max-height', CHOSEN_MAX_HEIGHT);
	      $clone.remove();
	      $select.after($chosen);
	    });
	  }

	  return BaseInput.extend({

	    className: 'o-form-select',

	    /**
	    * @Override
	    */
	    events: {
	      'change select': 'update',
	      'keyup .chzn-search > :text': function (e) {
	        if (Keys.isEsc(e)) {
	          this.$('.chzn-search > :text').val('');
	          e.stopPropagation();
	        }
	      }
	    },

	    constructor: function () {
	      BaseInput.apply(this, arguments);
	      this.params = this.options.params || {};
	    },

	    /**
	    * @Override
	    */
	    editMode: function () {
	      /* eslint max-statements: [2, 13] */

	      this.$el.html(template(this.options));
	      this.$select = this.$('select');


	      var options = this.getOptions();
	      _.each(options, function (value, key) {
	        this.$select.append(option({key: key, value: value}));
	      }, this);

	      // Fix a regression in jQuery 1.x on Firefox
	      // jQuery.val(value) prepends an empty option to the dropdown
	      // if value doesnt exist in the dropdown.
	      // http://bugs.jquery.com/ticket/13514
	      var value = this.getModelValue();
	      if (value) {
	        this.$select.val(value);
	      }
	      else {
	        this.$('option:first-child').prop('selected', true);
	      }
	      this.$el.addClass('o-form-control');

	      if (this.params.chosen !== false) {
	        this.__applyChosen();
	      }
	      return this;
	    },

	    __applyChosen: function () {
	      var width = this.options.wide ? '100%' : this.params.width || '62%';
	      if (this.params.autoWidth) {
	        width = findSelectWidth(this);
	      }

	      defer.call(this, function () {
	        var searchThreshold;
	        if (this.params && this.params.searchThreshold) {
	          searchThreshold = _.result(this.params, 'searchThreshold');
	        } else {
	          searchThreshold = 10;
	        }
	        if (!_.result(this.options, 'autoRender')) {
	          this.update();
	        }
	        this.$select.chosen({
	          'width': width,
	          'disable_search_threshold': searchThreshold,
	          'placeholder_text': this.options['placeholder']
	        });
	        fixChosenModal(this.$select);

	        if (this.params.autoWidth) { // fix a chosen css bug
	          this.$el.width(0);
	        }

	        this.model.trigger('form:resize');
	      });
	    },


	    /**
	    * @Override
	    */
	    val: function () {
	      return this.$select && this.$select.val();
	    },

	    /**
	    * @Override
	    */
	    focus: function () {
	      if (this.$select) {
	        return this.$select.focus();
	      }
	    },

	    /**
	     * @Override
	     */
	    toStringValue: function () {
	      var selectedOption = this.getModelValue(),
	          displayString = selectedOption,
	          options = this.getOptions();
	      if (!_.isEmpty(options)) {
	        displayString = options[selectedOption];
	      }
	      if (_.isUndefined(displayString)) {
	        displayString = this.defaultValue();
	      }
	      return displayString || '';
	    },

	    /**
	     * Convert options to an object
	     * support input options that is a
	     * 1. a static object such as {key1: val1, key2: val2...}
	     * 2. a function to be called to return a static object
	     * will return an object with key-value pairs or with empty content
	     * @return {Object} The value
	     */
	    getOptions: function () {
	      var options = this.options.options;

	      if (_.isFunction(options)) {
	        options = options.call(this);
	      }

	      return _.isObject(options) ? options : {};
	    },

	    remove: function () {
	      if (this.$select) {
	        this.$select.trigger('remove');
	      }
	      return BaseInput.prototype.remove.apply(this, arguments);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Chosen, a Select Box Enhancer for jQuery and Prototype
	// by Patrick Filler for Harvest, http://getharvest.com
	//
	// Version 0.11.1
	// Full source at https://github.com/harvesthq/chosen
	// Copyright (c) 2011 Harvest http://getharvest.com

	// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
	// This file is generated by `grunt build`, do not edit it by hand.

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (jQuery) {
	  (function() {
	    var SelectParser;

	    SelectParser = (function() {
	      function SelectParser() {
	        this.options_index = 0;
	        this.parsed = [];
	      }

	      SelectParser.prototype.add_node = function(child) {
	        if (child.nodeName.toUpperCase() === "OPTGROUP") {
	          return this.add_group(child);
	        } else {
	          return this.add_option(child);
	        }
	      };

	      SelectParser.prototype.add_group = function(group) {
	        var group_position, option, _i, _len, _ref, _results;

	        group_position = this.parsed.length;
	        this.parsed.push({
	          array_index: group_position,
	          group: true,
	          label: group.label,
	          children: 0,
	          disabled: group.disabled
	        });
	        _ref = group.childNodes;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          option = _ref[_i];
	          _results.push(this.add_option(option, group_position, group.disabled));
	        }
	        return _results;
	      };

	      SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
	        if (option.nodeName.toUpperCase() === "OPTION") {
	          if (option.text !== "") {
	            if (group_position != null) {
	              this.parsed[group_position].children += 1;
	            }
	            this.parsed.push({
	              array_index: this.parsed.length,
	              options_index: this.options_index,
	              value: option.value,
	              text: option.text,
	              html: option.innerHTML,
	              selected: option.selected,
	              disabled: group_disabled === true ? group_disabled : option.disabled,
	              group_array_index: group_position,
	              classes: option.className,
	              style: option.style.cssText
	            });
	          } else {
	            this.parsed.push({
	              array_index: this.parsed.length,
	              options_index: this.options_index,
	              empty: true
	            });
	          }
	          return this.options_index += 1;
	        }
	      };

	      return SelectParser;

	    })();

	    SelectParser.select_to_array = function(select) {
	      var child, parser, _i, _len, _ref;

	      parser = new SelectParser();
	      _ref = select.childNodes;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        child = _ref[_i];
	        parser.add_node(child);
	      }
	      return parser.parsed;
	    };

	    this.SelectParser = SelectParser;

	  }).call(this);

	  (function() {
	    var AbstractChosen, root;

	    root = this;

	    AbstractChosen = (function() {
	      function AbstractChosen(form_field, options) {
	        this.form_field = form_field;
	        this.options = options != null ? options : {};
	        if (!AbstractChosen.browser_is_supported()) {
	          return;
	        }
	        this.is_multiple = this.form_field.multiple;
	        this.set_default_text();
	        this.set_default_values();
	        this.setup();
	        this.set_up_html();
	        this.register_observers();
	        this.finish_setup();
	      }

	      AbstractChosen.prototype.set_default_values = function() {
	        var _this = this;

	        this.click_test_action = function(evt) {
	          return _this.test_active_click(evt);
	        };
	        this.activate_action = function(evt) {
	          return _this.activate_field(evt);
	        };
	        this.active_field = false;
	        this.mouse_on_container = false;
	        this.results_showing = false;
	        this.result_highlighted = null;
	        this.result_single_selected = null;
	        this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
	        this.disable_search_threshold = this.options.disable_search_threshold || 0;
	        this.disable_search = this.options.disable_search || false;
	        this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
	        this.search_contains = this.options.search_contains || false;
	        this.single_backstroke_delete = this.options.single_backstroke_delete || false;
	        this.max_selected_options = this.options.max_selected_options || Infinity;
	        return this.inherit_select_classes = this.options.inherit_select_classes || false;
	      };

	      AbstractChosen.prototype.set_default_text = function() {
	        if (this.form_field.getAttribute("data-placeholder")) {
	          this.default_text = this.form_field.getAttribute("data-placeholder");
	        } else if (this.is_multiple) {
	          this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
	        } else {
	          this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
	        }
	        return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
	      };

	      AbstractChosen.prototype.mouse_enter = function() {
	        return this.mouse_on_container = true;
	      };

	      AbstractChosen.prototype.mouse_leave = function() {
	        return this.mouse_on_container = false;
	      };

	      AbstractChosen.prototype.input_focus = function(evt) {
	        var _this = this;

	        if (this.is_multiple) {
	          if (!this.active_field) {
	            return setTimeout((function() {
	              return _this.container_mousedown();
	            }), 50);
	          }
	        } else {
	          if (!this.active_field) {
	            return this.activate_field();
	          }
	        }
	      };

	      AbstractChosen.prototype.input_blur = function(evt) {
	        var _this = this;

	        if (!this.mouse_on_container) {
	          this.active_field = false;
	          return setTimeout((function() {
	            return _this.blur_test();
	          }), 100);
	        }
	      };

	      AbstractChosen.prototype.result_add_option = function(option) {
	        var classes, style;

	        option.dom_id = this.container_id + "_o_" + option.array_index;
	        classes = [];
	        if (!option.disabled && !(option.selected && this.is_multiple)) {
	          classes.push("active-result");
	        }
	        if (option.disabled && !(option.selected && this.is_multiple)) {
	          classes.push("disabled-result");
	        }
	        if (option.selected) {
	          classes.push("result-selected");
	        }
	        if (option.group_array_index != null) {
	          classes.push("group-option");
	        }
	        if (option.classes !== "") {
	          classes.push(option.classes);
	        }
	        style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
	        return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
	      };

	      AbstractChosen.prototype.results_update_field = function() {
	        this.set_default_text();
	        if (!this.is_multiple) {
	          this.results_reset_cleanup();
	        }
	        this.result_clear_highlight();
	        this.result_single_selected = null;
	        return this.results_build();
	      };

	      AbstractChosen.prototype.results_toggle = function() {
	        if (this.results_showing) {
	          return this.results_hide();
	        } else {
	          return this.results_show();
	        }
	      };

	      AbstractChosen.prototype.results_search = function(evt) {
	        if (this.results_showing) {
	          return this.winnow_results();
	        } else {
	          return this.results_show();
	        }
	      };

	      AbstractChosen.prototype.choices_count = function() {
	        var option, _i, _len, _ref;

	        if (this.selected_option_count != null) {
	          return this.selected_option_count;
	        }
	        this.selected_option_count = 0;
	        _ref = this.form_field.options;
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          option = _ref[_i];
	          if (option.selected) {
	            this.selected_option_count += 1;
	          }
	        }
	        return this.selected_option_count;
	      };

	      AbstractChosen.prototype.choices_click = function(evt) {
	        evt.preventDefault();
	        if (!(this.results_showing || this.is_disabled)) {
	          return this.results_show();
	        }
	      };

	      AbstractChosen.prototype.keyup_checker = function(evt) {
	        var stroke, _ref;

	        stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
	        this.search_field_scale();
	        switch (stroke) {
	          case 8:
	            if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
	              return this.keydown_backstroke();
	            } else if (!this.pending_backstroke) {
	              this.result_clear_highlight();
	              return this.results_search();
	            }
	            break;
	          case 13:
	            evt.preventDefault();
	            if (this.results_showing) {
	              return this.result_select(evt);
	            }
	            break;
	          case 27:
	            if (this.results_showing) {
	              this.results_hide();
	            }
	            return true;
	          case 9:
	          case 38:
	          case 40:
	          case 16:
	          case 91:
	          case 17:
	            break;
	          default:
	            return this.results_search();
	        }
	      };

	      AbstractChosen.prototype.generate_field_id = function() {
	        var new_id;

	        new_id = this.generate_random_id();
	        this.form_field.id = new_id;
	        return new_id;
	      };

	      AbstractChosen.prototype.generate_random_char = function() {
	        var chars, newchar, rand;

	        chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	        rand = Math.floor(Math.random() * chars.length);
	        return newchar = chars.substring(rand, rand + 1);
	      };

	      AbstractChosen.prototype.container_width = function() {
	        if (this.options.width != null) {
	          return this.options.width;
	        } else {
	          return "" + this.form_field.offsetWidth + "px";
	        }
	      };

	      AbstractChosen.browser_is_supported = function() {
	        var _ref;

	        if (window.navigator.appName === "Microsoft Internet Explorer") {
	          return (null !== (_ref = document.documentMode) && _ref >= 8);
	        }
	        return true;
	      };

	      AbstractChosen.default_multiple_text = "Select Some Options";

	      AbstractChosen.default_single_text = "Select an Option";

	      AbstractChosen.default_no_result_text = "No results match";

	      return AbstractChosen;

	    })();

	    root.AbstractChosen = AbstractChosen;

	  }).call(this);

	  (function() {
	    var $, Chosen, root, _ref,
	      __hasProp = {}.hasOwnProperty,
	      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

	    root = this;

	    // OKTA-93521 - plugin assumes root is global scope
	    var AbstractChosen = root.AbstractChosen;

	    $ = jQuery;

	    $.fn.extend({
	      chosen: function(options) {
	        if (!AbstractChosen.browser_is_supported()) {
	          return this;
	        }
	        return this.each(function(input_field) {
	          var $this;

	          $this = $(this);
	          if (!$this.hasClass("chzn-done")) {
	            return $this.data('chosen', new Chosen(this, options));
	          }
	        });
	      }
	    });

	    Chosen = (function(_super) {
	      __extends(Chosen, _super);

	      function Chosen() {
	        _ref = Chosen.__super__.constructor.apply(this, arguments);
	        return _ref;
	      }

	      Chosen.prototype.setup = function() {
	        this.form_field_jq = $(this.form_field);
	        this.current_selectedIndex = this.form_field.selectedIndex;
	        return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
	      };

	      Chosen.prototype.finish_setup = function() {
	        return this.form_field_jq.addClass("chzn-done");
	      };

	      Chosen.prototype.set_up_html = function() {
	        var container_classes, container_props;

	        this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, '_') : this.generate_field_id();
	        this.container_id += "_chzn";
	        container_classes = ["chzn-container"];
	        container_classes.push("chzn-container-" + (this.is_multiple ? "multi" : "single"));
	        if (this.inherit_select_classes && this.form_field.className) {
	          container_classes.push(this.form_field.className);
	        }
	        if (this.is_rtl) {
	          container_classes.push("chzn-rtl");
	        }
	        container_props = {
	          'id': this.container_id,
	          'class': container_classes.join(' '),
	          'style': "width: " + (this.container_width()) + ";",
	          'title': this.form_field.title
	        };
	        this.container = $("<div />", container_props);
	        if (this.is_multiple) {
	          this.container.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop"><ul class="chzn-results"></ul></div>');
	        } else {
	          this.container.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
	        }
	        this.form_field_jq.hide().after(this.container);
	        this.dropdown = this.container.find('div.chzn-drop').first();
	        this.search_field = this.container.find('input').first();
	        this.search_results = this.container.find('ul.chzn-results').first();
	        this.search_field_scale();
	        this.search_no_results = this.container.find('li.no-results').first();
	        if (this.is_multiple) {
	          this.search_choices = this.container.find('ul.chzn-choices').first();
	          this.search_container = this.container.find('li.search-field').first();
	        } else {
	          this.search_container = this.container.find('div.chzn-search').first();
	          this.selected_item = this.container.find('.chzn-single').first();
	        }
	        this.results_build();
	        this.set_tab_index();
	        this.set_label_behavior();
	        return this.form_field_jq.trigger("liszt:ready", {
	          chosen: this
	        });
	      };

	      Chosen.prototype.register_observers = function() {
	        var _this = this;

	        this.container.mousedown(function(evt) {
	          _this.container_mousedown(evt);
	        });
	        this.container.mouseup(function(evt) {
	          _this.container_mouseup(evt);
	        });
	        this.container.mouseenter(function(evt) {
	          _this.mouse_enter(evt);
	        });
	        this.container.mouseleave(function(evt) {
	          _this.mouse_leave(evt);
	        });
	        this.search_results.mouseup(function(evt) {
	          _this.search_results_mouseup(evt);
	        });
	        this.search_results.mouseover(function(evt) {
	          _this.search_results_mouseover(evt);
	        });
	        this.search_results.mouseout(function(evt) {
	          _this.search_results_mouseout(evt);
	        });
	        this.search_results.bind('mousewheel DOMMouseScroll', function(evt) {
	          _this.search_results_mousewheel(evt);
	        });
	        this.form_field_jq.bind("liszt:updated", function(evt) {
	          _this.results_update_field(evt);
	        });
	        this.form_field_jq.bind("liszt:activate", function(evt) {
	          _this.activate_field(evt);
	        });
	        this.form_field_jq.bind("liszt:open", function(evt) {
	          _this.container_mousedown(evt);
	        });
	        this.search_field.blur(function(evt) {
	          _this.input_blur(evt);
	        });
	        this.search_field.keyup(function(evt) {
	          _this.keyup_checker(evt);
	        });
	        this.search_field.keydown(function(evt) {
	          _this.keydown_checker(evt);
	        });
	        this.search_field.focus(function(evt) {
	          _this.input_focus(evt);
	        });
	        if (this.is_multiple) {
	          return this.search_choices.click(function(evt) {
	            _this.choices_click(evt);
	          });
	        } else {
	          return this.container.click(function(evt) {
	            evt.preventDefault();
	          });
	        }
	      };

	      Chosen.prototype.search_field_disabled = function() {
	        this.is_disabled = this.form_field_jq[0].disabled;
	        if (this.is_disabled) {
	          this.container.addClass('chzn-disabled');
	          this.search_field[0].disabled = true;
	          if (!this.is_multiple) {
	            this.selected_item.unbind("focus", this.activate_action);
	          }
	          return this.close_field();
	        } else {
	          this.container.removeClass('chzn-disabled');
	          this.search_field[0].disabled = false;
	          if (!this.is_multiple) {
	            return this.selected_item.bind("focus", this.activate_action);
	          }
	        }
	      };

	      Chosen.prototype.container_mousedown = function(evt) {
	        if (!this.is_disabled) {
	          if (evt && evt.type === "mousedown" && !this.results_showing) {
	            evt.preventDefault();
	          }
	          if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
	            if (!this.active_field) {
	              if (this.is_multiple) {
	                this.search_field.val("");
	              }
	              $(document).click(this.click_test_action);
	              this.results_show();
	            } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
	              evt.preventDefault();
	              this.results_toggle();
	            }
	            return this.activate_field();
	          }
	        }
	      };

	      Chosen.prototype.container_mouseup = function(evt) {
	        if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
	          return this.results_reset(evt);
	        }
	      };

	      Chosen.prototype.search_results_mousewheel = function(evt) {
	        var delta, _ref1, _ref2;

	        delta = -((_ref1 = evt.originalEvent) != null ? _ref1.wheelDelta : void 0) || ((_ref2 = evt.originialEvent) != null ? _ref2.detail : void 0);
	        if (delta != null) {
	          evt.preventDefault();
	          if (evt.type === 'DOMMouseScroll') {
	            delta = delta * 40;
	          }
	          return this.search_results.scrollTop(delta + this.search_results.scrollTop());
	        }
	      };

	      Chosen.prototype.blur_test = function(evt) {
	        if (!this.active_field && this.container.hasClass("chzn-container-active")) {
	          return this.close_field();
	        }
	      };

	      Chosen.prototype.close_field = function() {
	        $(document).unbind("click", this.click_test_action);
	        this.active_field = false;
	        this.results_hide();
	        this.container.removeClass("chzn-container-active");
	        this.clear_backstroke();
	        this.show_search_field_default();
	        return this.search_field_scale();
	      };

	      Chosen.prototype.activate_field = function() {
	        this.container.addClass("chzn-container-active");
	        this.active_field = true;
	        this.search_field.val(this.search_field.val());
	        return this.search_field.focus();
	      };

	      Chosen.prototype.test_active_click = function(evt) {
	        if ($(evt.target).parents('#' + this.container_id).length) {
	          return this.active_field = true;
	        } else {
	          return this.close_field();
	        }
	      };

	      Chosen.prototype.results_build = function() {
	        var content, data, _i, _len, _ref1;

	        this.parsing = true;
	        this.selected_option_count = null;
	        this.results_data = root.SelectParser.select_to_array(this.form_field);
	        if (this.is_multiple) {
	          this.search_choices.find("li.search-choice").remove();
	        } else if (!this.is_multiple) {
	          this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
	          if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
	            this.search_field[0].readOnly = true;
	            this.container.addClass("chzn-container-single-nosearch");
	          } else {
	            this.search_field[0].readOnly = false;
	            this.container.removeClass("chzn-container-single-nosearch");
	          }
	        }
	        content = '';
	        _ref1 = this.results_data;
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          data = _ref1[_i];
	          if (data.group) {
	            content += this.result_add_group(data);
	          } else if (!data.empty) {
	            content += this.result_add_option(data);
	            if (data.selected && this.is_multiple) {
	              this.choice_build(data);
	            } else if (data.selected && !this.is_multiple) {
	              this.selected_item.removeClass("chzn-default").find("span").text(data.text);
	              if (this.allow_single_deselect) {
	                this.single_deselect_control_build();
	              }
	            }
	          }
	        }
	        this.search_field_disabled();
	        this.show_search_field_default();
	        this.search_field_scale();
	        this.search_results.html(content);
	        return this.parsing = false;
	      };

	      Chosen.prototype.result_add_group = function(group) {
	        group.dom_id = this.container_id + "_g_" + group.array_index;
	        return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
	      };

	      Chosen.prototype.result_do_highlight = function(el) {
	        var high_bottom, high_top, maxHeight, visible_bottom, visible_top;

	        if (el.length) {
	          this.result_clear_highlight();
	          this.result_highlight = el;
	          this.result_highlight.addClass("highlighted");
	          maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
	          visible_top = this.search_results.scrollTop();
	          visible_bottom = maxHeight + visible_top;
	          high_top = this.result_highlight.position().top + this.search_results.scrollTop();
	          high_bottom = high_top + this.result_highlight.outerHeight();
	          if (high_bottom >= visible_bottom) {
	            return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
	          } else if (high_top < visible_top) {
	            return this.search_results.scrollTop(high_top);
	          }
	        }
	      };

	      Chosen.prototype.result_clear_highlight = function() {
	        if (this.result_highlight) {
	          this.result_highlight.removeClass("highlighted");
	        }
	        return this.result_highlight = null;
	      };

	      Chosen.prototype.results_show = function() {
	        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
	          this.form_field_jq.trigger("liszt:maxselected", {
	            chosen: this
	          });
	          return false;
	        }
	        this.container.addClass("chzn-with-drop");
	        this.form_field_jq.trigger("liszt:showing_dropdown", {
	          chosen: this
	        });
	        this.results_showing = true;
	        this.search_field.focus();
	        this.search_field.val(this.search_field.val());
	        return this.winnow_results();
	      };

	      Chosen.prototype.results_hide = function() {
	        if (this.results_showing) {
	          this.result_clear_highlight();
	          this.container.removeClass("chzn-with-drop");
	          this.form_field_jq.trigger("liszt:hiding_dropdown", {
	            chosen: this
	          });
	        }
	        return this.results_showing = false;
	      };

	      Chosen.prototype.set_tab_index = function(el) {
	        var ti;

	        if (this.form_field_jq.attr("tabindex")) {
	          ti = this.form_field_jq.attr("tabindex");
	          this.form_field_jq.attr("tabindex", -1);
	          return this.search_field.attr("tabindex", ti);
	        }
	      };

	      Chosen.prototype.set_label_behavior = function() {
	        var _this = this;

	        this.form_field_label = this.form_field_jq.parents("label");
	        if (!this.form_field_label.length && this.form_field.id.length) {
	          this.form_field_label = $("label[for='" + this.form_field.id + "']");
	        }
	        if (this.form_field_label.length > 0) {
	          return this.form_field_label.click(function(evt) {
	            if (_this.is_multiple) {
	              return _this.container_mousedown(evt);
	            } else {
	              return _this.activate_field();
	            }
	          });
	        }
	      };

	      Chosen.prototype.show_search_field_default = function() {
	        if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
	          this.search_field.val(this.default_text);
	          return this.search_field.addClass("default");
	        } else {
	          this.search_field.val("");
	          return this.search_field.removeClass("default");
	        }
	      };

	      Chosen.prototype.search_results_mouseup = function(evt) {
	        var target;

	        target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
	        if (target.length) {
	          this.result_highlight = target;
	          this.result_select(evt);
	          return this.search_field.focus();
	        }
	      };

	      Chosen.prototype.search_results_mouseover = function(evt) {
	        var target;

	        target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
	        if (target) {
	          return this.result_do_highlight(target);
	        }
	      };

	      Chosen.prototype.search_results_mouseout = function(evt) {
	        if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
	          return this.result_clear_highlight();
	        }
	      };

	      Chosen.prototype.choice_build = function(item) {
	        var choice, close_link,
	          _this = this;

	        choice = $('<li />', {
	          "class": "search-choice"
	        }).html("<span>" + item.html + "</span>");
	        if (item.disabled) {
	          choice.addClass('search-choice-disabled');
	        } else {
	          close_link = $('<a />', {
	            href: '#',
	            "class": 'search-choice-close',
	            rel: item.array_index
	          });
	          close_link.click(function(evt) {
	            return _this.choice_destroy_link_click(evt);
	          });
	          choice.append(close_link);
	        }
	        return this.search_container.before(choice);
	      };

	      Chosen.prototype.choice_destroy_link_click = function(evt) {
	        evt.preventDefault();
	        evt.stopPropagation();
	        if (!this.is_disabled) {
	          return this.choice_destroy($(evt.target));
	        }
	      };

	      Chosen.prototype.choice_destroy = function(link) {
	        if (this.result_deselect(link.attr("rel"))) {
	          this.show_search_field_default();
	          if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
	            this.results_hide();
	          }
	          link.parents('li').first().remove();
	          return this.search_field_scale();
	        }
	      };

	      Chosen.prototype.results_reset = function() {
	        this.form_field.options[0].selected = true;
	        this.selected_option_count = null;
	        this.selected_item.find("span").text(this.default_text);
	        if (!this.is_multiple) {
	          this.selected_item.addClass("chzn-default");
	        }
	        this.show_search_field_default();
	        this.results_reset_cleanup();
	        this.form_field_jq.trigger("change");
	        if (this.active_field) {
	          return this.results_hide();
	        }
	      };

	      Chosen.prototype.results_reset_cleanup = function() {
	        this.current_selectedIndex = this.form_field.selectedIndex;
	        return this.selected_item.find("abbr").remove();
	      };

	      Chosen.prototype.result_select = function(evt) {
	        var high, high_id, item, position;

	        if (this.result_highlight) {
	          high = this.result_highlight;
	          high_id = high.attr("id");
	          this.result_clear_highlight();
	          if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
	            this.form_field_jq.trigger("liszt:maxselected", {
	              chosen: this
	            });
	            return false;
	          }
	          if (this.is_multiple) {
	            high.removeClass("active-result");
	          } else {
	            this.search_results.find(".result-selected").removeClass("result-selected");
	            this.result_single_selected = high;
	            this.selected_item.removeClass("chzn-default");
	          }
	          high.addClass("result-selected");
	          position = high_id.substr(high_id.lastIndexOf("_") + 1);
	          item = this.results_data[position];
	          item.selected = true;
	          this.form_field.options[item.options_index].selected = true;
	          this.selected_option_count = null;
	          if (this.is_multiple) {
	            this.choice_build(item);
	          } else {
	            this.selected_item.find("span").first().text(item.text);
	            if (this.allow_single_deselect) {
	              this.single_deselect_control_build();
	            }
	          }
	          if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
	            this.results_hide();
	          }
	          this.search_field.val("");
	          if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
	            this.form_field_jq.trigger("change", {
	              'selected': this.form_field.options[item.options_index].value
	            });
	          }
	          this.current_selectedIndex = this.form_field.selectedIndex;
	          return this.search_field_scale();
	        }
	      };

	      Chosen.prototype.result_activate = function(el, option) {
	        if (option.disabled) {
	          return el.addClass("disabled-result");
	        } else if (this.is_multiple && option.selected) {
	          return el.addClass("result-selected");
	        } else {
	          return el.addClass("active-result");
	        }
	      };

	      Chosen.prototype.result_deactivate = function(el) {
	        return el.removeClass("active-result result-selected disabled-result");
	      };

	      Chosen.prototype.result_deselect = function(pos) {
	        var result, result_data;

	        result_data = this.results_data[pos];
	        if (!this.form_field.options[result_data.options_index].disabled) {
	          result_data.selected = false;
	          this.form_field.options[result_data.options_index].selected = false;
	          this.selected_option_count = null;
	          result = $("#" + this.container_id + "_o_" + pos);
	          result.removeClass("result-selected").addClass("active-result").show();
	          this.result_clear_highlight();
	          this.winnow_results();
	          this.form_field_jq.trigger("change", {
	            deselected: this.form_field.options[result_data.options_index].value
	          });
	          this.search_field_scale();
	          return true;
	        } else {
	          return false;
	        }
	      };

	      Chosen.prototype.single_deselect_control_build = function() {
	        if (!this.allow_single_deselect) {
	          return;
	        }
	        if (!this.selected_item.find("abbr").length) {
	          this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
	        }
	        return this.selected_item.addClass("chzn-single-with-deselect");
	      };

	      Chosen.prototype.winnow_results = function() {
	        var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref1;

	        this.no_results_clear();
	        results = 0;
	        searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
	        regexAnchor = this.search_contains ? "" : "^";
	        regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
	        zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
	        _ref1 = this.results_data;
	        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	          option = _ref1[_i];
	          if (!option.empty) {
	            if (option.group) {
	              $('#' + option.dom_id).css('display', 'none');
	            } else {
	              found = false;
	              result_id = option.dom_id;
	              result = $("#" + result_id);
	              if (regex.test(option.html)) {
	                found = true;
	                results += 1;
	              } else if (this.enable_split_word_search && (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0)) {
	                parts = option.html.replace(/\[|\]/g, "").split(" ");
	                if (parts.length) {
	                  for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
	                    part = parts[_j];
	                    if (regex.test(part)) {
	                      found = true;
	                      results += 1;
	                    }
	                  }
	                }
	              }
	              if (found) {
	                if (searchText.length) {
	                  startpos = option.html.search(zregex);
	                  text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
	                  text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
	                } else {
	                  text = option.html;
	                }
	                result.html(text);
	                this.result_activate(result, option);
	                if (option.group_array_index != null) {
	                  $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
	                }
	              } else {
	                if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
	                  this.result_clear_highlight();
	                }
	                this.result_deactivate(result);
	              }
	            }
	          }
	        }
	        if (results < 1 && searchText.length) {
	          return this.no_results(searchText);
	        } else {
	          return this.winnow_results_set_highlight();
	        }
	      };

	      Chosen.prototype.winnow_results_set_highlight = function() {
	        var do_high, selected_results;

	        if (!this.result_highlight) {
	          selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
	          do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
	          if (do_high != null) {
	            return this.result_do_highlight(do_high);
	          }
	        }
	      };

	      Chosen.prototype.no_results = function(terms) {
	        var no_results_html;

	        no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
	        no_results_html.find("span").first().html(terms);
	        return this.search_results.append(no_results_html);
	      };

	      Chosen.prototype.no_results_clear = function() {
	        return this.search_results.find(".no-results").remove();
	      };

	      Chosen.prototype.keydown_arrow = function() {
	        var next_sib;

	        if (this.results_showing && this.result_highlight) {
	          next_sib = this.result_highlight.nextAll("li.active-result").first();
	          if (next_sib) {
	            return this.result_do_highlight(next_sib);
	          }
	        } else {
	          return this.results_show();
	        }
	      };

	      Chosen.prototype.keyup_arrow = function() {
	        var prev_sibs;

	        if (!this.results_showing && !this.is_multiple) {
	          return this.results_show();
	        } else if (this.result_highlight) {
	          prev_sibs = this.result_highlight.prevAll("li.active-result");
	          if (prev_sibs.length) {
	            return this.result_do_highlight(prev_sibs.first());
	          } else {
	            if (this.choices_count() > 0) {
	              this.results_hide();
	            }
	            return this.result_clear_highlight();
	          }
	        }
	      };

	      Chosen.prototype.keydown_backstroke = function() {
	        var next_available_destroy;

	        if (this.pending_backstroke) {
	          this.choice_destroy(this.pending_backstroke.find("a").first());
	          return this.clear_backstroke();
	        } else {
	          next_available_destroy = this.search_container.siblings("li.search-choice").last();
	          if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
	            this.pending_backstroke = next_available_destroy;
	            if (this.single_backstroke_delete) {
	              return this.keydown_backstroke();
	            } else {
	              return this.pending_backstroke.addClass("search-choice-focus");
	            }
	          }
	        }
	      };

	      Chosen.prototype.clear_backstroke = function() {
	        if (this.pending_backstroke) {
	          this.pending_backstroke.removeClass("search-choice-focus");
	        }
	        return this.pending_backstroke = null;
	      };

	      Chosen.prototype.keydown_checker = function(evt) {
	        var stroke, _ref1;

	        stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
	        this.search_field_scale();
	        if (stroke !== 8 && this.pending_backstroke) {
	          this.clear_backstroke();
	        }
	        switch (stroke) {
	          case 8:
	            this.backstroke_length = this.search_field.val().length;
	            break;
	          case 9:
	            if (this.results_showing && !this.is_multiple) {
	              this.result_select(evt);
	            }
	            this.mouse_on_container = false;
	            break;
	          case 13:
	            evt.preventDefault();
	            break;
	          case 38:
	            evt.preventDefault();
	            this.keyup_arrow();
	            break;
	          case 40:
	            evt.preventDefault();
	            this.keydown_arrow();
	            break;
	        }
	      };

	      Chosen.prototype.search_field_scale = function() {
	        var div, h, style, style_block, styles, w, _i, _len;

	        if (this.is_multiple) {
	          h = 0;
	          w = 0;
	          style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
	          styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
	          for (_i = 0, _len = styles.length; _i < _len; _i++) {
	            style = styles[_i];
	            style_block += style + ":" + this.search_field.css(style) + ";";
	          }
	          div = $('<div />', {
	            'style': style_block
	          });
	          div.text(this.search_field.val());
	          $('body').append(div);
	          w = div.width() + 25;
	          div.remove();
	          if (!this.f_width) {
	            this.f_width = this.container.outerWidth();
	          }
	          if (w > this.f_width - 10) {
	            w = this.f_width - 10;
	          }
	          return this.search_field.css({
	            'width': w + 'px'
	          });
	        }
	      };

	      Chosen.prototype.generate_random_id = function() {
	        var string;

	        string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
	        while ($("#" + string).length > 0) {
	          string += this.generate_random_char();
	        }
	        return string;
	      };

	      return Chosen;

	    })(AbstractChosen);

	    root.Chosen = Chosen;

	  }).call(this);

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(64),
	  __webpack_require__(49),
	  __webpack_require__(63),
	  __webpack_require__(70)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, Keys, TemplateUtil, BaseInput) {

	  var template = TemplateUtil.tpl('\
	      <input type="radio" name="{{name}}" data-se-name="{{realName}}" value="{{value}}" id="{{id}}">\
	      <label for="{{id}}" data-se-for-name="{{realName}}">\
	        {{label}}\
	        {{#if explain}}\
	        <p class="o-form-explain">{{explain}}</p>\
	        {{/if}}\
	      </label>\
	  ');

	  return BaseInput.extend({

	    /**
	    * @Override
	    */
	    events: {
	      'change :radio': 'update',
	      'keyup': function (e) {
	        if (Keys.isSpaceBar(e)) {
	          $(e.target).click();
	        }
	        else if (Keys.isEnter(e)) {
	          this.model.trigger('form:save');
	        }
	      }
	    },

	    /**
	    * @Override
	    */
	    editMode: function () {
	      this.$el.empty();

	      _.each(this.options.options, function (value, key) {
	        var options = {
	          id: _.uniqueId('option'),
	          name: this.options.inputId,
	          realName: this.options.name,
	          value: key
	        };

	        if (!_.isObject(value)) {
	          value = { label: value };
	        }
	        _.extend(options, value);

	        this.$el.append(template(options));
	      }, this);

	      var value = this.getModelValue();
	      if (value) {
	        this.$(':radio[value=' + value + ']').prop('checked', true);
	      }

	      this.$('input').customInput();
	      this.model.trigger('form:resize');

	      if (!_.isUndefined(this.options.params) && this.options.params.inline === true) {
	        this.$('div.custom-radio').addClass('inline');
	      }

	      return this;
	    },

	    /**
	    * @Override
	    */
	    readMode: function () {
	      this.editMode();
	      this.$(':radio').prop('disabled', true);
	      return this;
	    },

	    /**
	    * @Override
	    */
	    val: function () {
	      return this.$(':radio:checked').val();
	    },

	    /**
	    * @Override
	    */
	    focus: function () {
	      return this.$('label:eq(0)').focus();
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * There are following local modifications:
	 * - Author: Uzi Kilon ukilon@okta.com
	 *   Bug: OKTA-20830 - solves the conflict when there are multiple labels
	 */
	/**
	 * --------------------------------------------------------------------
	 * jQuery customInput plugin
	 * Author: Maggie Costello Wachs maggie@filamentgroup.com, Scott Jehl, scott@filamentgroup.com
	 * Copyright (c) 2009 Filament Group
	 * licensed under MIT (filamentgroup.com/examples/mit-license.txt)
	 * --------------------------------------------------------------------
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (jQuery) {
	  var $ = jQuery;
	  jQuery.fn.customInput = function(){
	    return $(this).each(function(){
	      if($(this).is('[type=checkbox],[type=radio]')){
	        var input = $(this);

	        // get the associated label using the input's id
	        var label = input.siblings('label[for="'+input.attr('id')+'"]:first');
	        if (!label.length) {
	          label = input.closest('label[for="'+input.attr('id')+'"]:first');
	        }
	        // wrap the input + label in a div
	        input.add(label).wrapAll('<div class="custom-'+ input.attr('type') +'"></div>');

	        // necessary for browsers that don't support the :hover pseudo class on labels
	        label.hover(
	          function(){ $(this).addClass('hover'); },
	          function(){ $(this).removeClass('hover'); }
	        );

	        //bind custom event, trigger it, bind click,focus,blur events
	        input.bind('updateState', function(){
	          input.is(':checked') ? label.addClass('checked') : label.removeClass('checked checkedHover checkedFocus');
	        })
	        .trigger('updateState')
	        .click(function(){
	          $('input[name="'+ $(this).attr('name') +'"]').trigger('updateState');
	        })
	        .focus(function(){
	          label.addClass('focus');
	          if(input.is(':checked')){  $(this).addClass('checkedFocus'); }
	        })
	        .blur(function(){ label.removeClass('focus checkedFocus'); });
	      }
	    });
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(64),
	  __webpack_require__(49),
	  __webpack_require__(63),
	  __webpack_require__(70)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Keys, TemplateUtil, BaseInput) {

	  var template = TemplateUtil.tpl('\
	    <input type="checkbox" name="{{name}}" id="{{inputId}}"/>\
	    <label for="{{inputId}}" data-se-for-name="{{name}}">{{placeholder}}</label>\
	  ');

	  return BaseInput.extend({
	    template: template,
	    /**
	    * @Override
	    */
	    events: {
	      'change :checkbox': 'update',
	      'keyup': function (e) {
	        if (Keys.isSpaceBar(e)) {
	          this.$(':checkbox').click();
	        }
	        else if (Keys.isEnter(e)) {
	          this.model.trigger('form:save');
	        }
	      }
	    },

	    /**
	    * @Override
	    */
	    editMode: function () {
	      var placeholder = _.resultCtx(this.options, 'placeholder', this);
	      if (placeholder === '') {
	        placeholder = _.resultCtx(this.options, 'label', this);
	      } else if (placeholder === false) {
	        placeholder = '';
	      }

	      this.$el.html(this.template(_.extend(_.omit(this.options, 'placeholder'), { placeholder: placeholder })));
	      var $input = this.$(':checkbox');
	      $input.prop('checked', this.getModelValue() || false);

	      this.$('input').customInput();
	      this.model.trigger('form:resize');

	      return this;
	    },

	    /**
	     * @Override
	    */
	    readMode: function () {
	      this.editMode();
	      this.$(':checkbox').prop('disabled', true);
	      return this;
	    },

	    /**
	    * @Override
	    */
	    val: function () {
	      return this.$(':checkbox').prop('checked');
	    },

	    /**
	    * @Override
	    */
	    focus: function () {
	      return this.$(':checkbox').focus();
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 72 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 73 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 74 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 75 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 76 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 77 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 78 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 79 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 80 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 81 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(63),
	  __webpack_require__(48),
	  __webpack_require__(83)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseInput, BaseView, ButtonFactory) {


	  function countInputs(inputs) {
	    return _.filter(inputs || [], function (input) {
	      return !_.contains(['label', 'button', 'select'], input.type);
	    }).length;
	  }

	  var LabelInput = BaseInput.extend({
	    tagName: 'span',
	    initialize: function () {
	      this.$el.text(this.getModelValue());
	    },
	    editMode: function () {
	      this.toggle(true);
	    },
	    readMode: function () {
	      this.toggle(false);
	    },
	    getModelValue: function () {
	      return this.options.label;
	    },
	    toggle: function (isEditMode) {
	      this.$el.toggleClass('o-form-label-inline', isEditMode);
	      this.$el.toggleClass('o-form-control', !isEditMode);
	    },
	    focus: _.noop
	  });

	  function createButtonInput(options) {
	    return ButtonFactory.create(_.defaults({
	      getReadModeString: _.constant(' '),
	      focus: _.noop
	    }, _.pick(options, 'click', 'title', 'href')));
	  }

	  var InputGroupView = BaseView.extend({

	    className: function () {
	      var className;
	      if (this.options.params && this.options.params.display === 'text') {
	        className = 'o-form-input-group-subtle';
	      } else {
	        className = 'o-form-input-group';
	      }
	      if (countInputs(this.options.params && this.options.params.inputs) > 1) {
	        className += ' o-form-input-group-2';
	      }
	      return className;
	    },

	    initialize: function () {
	      _.each(this.options.params && this.options.params.inputs, function (input) {
	        switch (input.type) {
	        case 'label':
	          this.add(LabelInput, {options: input});
	          break;
	        case 'button':
	          this.add(createButtonInput(input));
	          break;
	        default:
	          input = _.defaults({
	            model: this.model,
	            params: _.extend({
	              autoWidth: true
	            }, input.params || {})
	          }, input);
	          this.add(this.options.params.create(input));
	        }
	      }, this);
	    },

	    focus: function () {
	      this.first().focus();
	    }
	  });


	  return BaseInput.extend({

	    constructor: function (options) {
	      this.inputGroupView = new InputGroupView(options);
	      BaseInput.apply(this, arguments);
	    },

	    editMode: function () {
	      this.inputGroupView.remove();
	      this.inputGroupView = new InputGroupView(this.options);
	      this.$el.html(this.inputGroupView.render().el);
	    },

	    toStringValue: function () {
	      var strings = this.inputGroupView.map(function (input) {
	        return input.getReadModeString();
	      });
	      return strings.length && _.every(strings) ? strings.join(' ') : ' ';
	    },

	    focus: function () {
	      this.inputGroupView.focus();
	    }

	  },
	    {  // test hooks
	      LabelInput: LabelInput,
	      InputGroupView: InputGroupView
	    });


	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(84)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseButtonLink) {
	  /**
	   * @class ButtonFactory
	   * @private
	   *
	   * A factory method wrapper for {@link BaseButtonLink} creation
	   */

	  function normalizeEvents(options) {
	    var events = _.extend(options.click ? {click: options.click} : {}, options.events || {}),
	        target = {};
	    _.each(events, function (fn, eventName) {
	      target[eventName] = function (e) {
	        if (!options.href) {
	          e.preventDefault();
	          e.stopPropagation();
	        }
	        fn.apply(this, arguments);
	      };
	    });
	    return target;
	  }

	  return {
	    /**
	     * Creates a BaseButtonLink
	     * @param  {Object} options Options hash
	     * @param  {String} [options.title] The button text
	     * @param  {String} [options.icon]
	     * CSS class for the icon to display. See [Style guide](http://rain.okta1.com:1802/su/dev/style-guide#icons)
	     * @param {String} [options.href] The button link
	     * @param {Function} [options.click] On click callback
	     * @param {Object} [options.events] a [Backbone events](http://backbonejs.org/#View-delegateEvents) hash
	     * @return {BaseButtonLink} BaseButtonLink prototype ("class")
	     */
	    create: function (options) {
	      options = _.clone(options);
	      return BaseButtonLink.extend(_.extend(options, {
	        events: normalizeEvents(options)
	      }));
	    }
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(48), __webpack_require__(85)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView, ViewUtil) {

	  var disabledEvents = {
	    click: function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  };

	  return BaseView.extend({

	    /**
	     * @class BaseButtonLink
	     * @extends Okta.View
	     * @private
	     * A configurable button.
	     *
	     * ```javascript
	     * var View = BaseButtonLink.extend({
	     *   title: 'Click Me',
	     *   icon: 'help-text'
	     * })
	     * ```
	     */

	    /**
	     * @property {String | Function} [title] The main text for the button
	     */

	    /**
	     * @property {String | Function} [href] The link for the button
	     */

	    /**
	     * @property {String | Function } [icon]
	     * CSS class for the icon to display. See [Style guide](http://rain.okta1.com:1802/su/dev/style-guide#icons)
	     */

	    /**
	     * @property {Object} [events] a [Backbone events](http://backbonejs.org/#View-delegateEvents) hash
	     */

	    /*
	     * @property {Boolean | Function} [visible] visible=true make this button visible, default to true.
	     */

	    /*
	     * @property {Boolean | Function} [enabled] enabled=true make this button enabled, default to true.
	     */

	    /*
	     * @property {Object | Function} [enableWhen] The setting to determine when the button is enabled,
	         default to {} and enabled takes a higher priority.
	     */

	    /*
	     * @property {Object | Function} [showWhen] The setting to determine when the button is visible,
	         default to {} and visible takes a higher priority.
	     */


	    tagName: 'a',

	    template: '{{#if icon}}<span class="icon {{icon}}"></span>{{/if}}{{#if title}}{{title}}{{/if}}',

	    visible: true,

	    enabled: true,

	    enableWhen: {},

	    showWhen: {},

	    constructor: function (options) {
	      this.options = options || {};
	      var data = this.getTemplateData();

	      this.disabled = false;

	      BaseView.apply(this, arguments);

	      this.$el.addClass('link-button');
	      if (data.icon) {
	        this.$el.addClass('link-button-icon');
	        if (!data.title) {
	          this.$el.addClass('icon-only');
	        }
	      }
	    },

	    getTemplateData: function () {
	      return {
	        href: this.__getAttribute('href'),
	        title: this.__getAttribute('title'),
	        icon: this.__getAttribute('icon')
	      };
	    },

	    initialize: function () {
	      ViewUtil.applyDoWhen(this, _.resultCtx(this, 'enableWhen', this), this.toggle);
	      ViewUtil.applyDoWhen(this, _.resultCtx(this, 'showWhen', this), this.toggleVisible);
	    },

	    render: function () {

	      BaseView.prototype.render.apply(this, arguments);

	      if (!_.result(this, 'enabled')) {
	        this.toggle(false);
	      }

	      if (!_.result(this, 'visible')) {
	        this.toggleVisible(false);
	      }
	      
	      var data = this.getTemplateData();
	      this.$el.attr('href', data.href || '#');

	      return this;
	    },

	    __getAttribute: function (name, defaultValue) {
	      var value = _.resultCtx(this.options, name, this);
	      if (_.isUndefined(value)) {
	        value = _.result(this, name);
	      }
	      return !_.isUndefined(value) ? value : defaultValue;
	    },

	    enable: function () {
	      this.toggle(true);
	    },

	    disable: function () {
	      this.toggle(false);
	    },

	    show: function () {
	      this.toggleVisible(true);
	    },

	    hide: function () {
	      this.toggleVisible(false);
	    },

	    toggle: function (enable) {
	      //this is to toggle the enability
	      var bool = !!enable && _.result(this, 'enabled');
	      this.disabled = !bool;
	      this.$el.toggleClass('link-button-disabled btn-disabled disabled', this.disabled);

	      // delegateEvents asynchronously in case the button is not yet added to the DOM
	      // in these cases the alternate events won't work
	      _.defer(_.bind(function () {
	        this.delegateEvents(this.disabled ? disabledEvents : null);
	      }, this));
	    },

	    toggleVisible: function (visible) {
	      var hidden = !visible || !_.result(this, 'visible');
	      this.$el.toggleClass('hide', hidden);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {

	  function changeEventString(doWhen) {
	    return 'change:' + _.keys(doWhen).join(' change:');
	  }

	  function calcDoWhen(value, key) {
	    var modelValue = this.model.get(key);
	    if (_.isFunction(value)) {
	      return value.call(this, modelValue);
	    }
	    else {
	      return value == modelValue;
	    }
	  }

	  function _doWhen(view, doWhen, fn) {
	    var toggle = _.bind(fn, view, view, doWhen);

	    view.render = _.wrap(view.render, function (render) {
	      var val = render.call(view);
	      toggle({animate: false});
	      return val;
	    });

	    view.listenTo(view.model, changeEventString(doWhen), function () {
	      toggle({animate: true});
	    });
	  }

	  return {
	    applyDoWhen: function (view, doWhen, fn) {
	      if (!(view.model && _.isObject(doWhen) && _.size(doWhen) && _.isFunction(fn))) {
	        return;
	      }
	      _doWhen(view, doWhen, function (view, doWhen, options) {
	        var result = _.every(_.map(doWhen, calcDoWhen, view));
	        fn.call(view, result, options);
	      });
	    }
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 86 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(88)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseFileUploader) {

	  return BaseFileUploader.extend({

	    className: 'image-file-upload',

	    parse: function (src) {
	      var target = _.clone(src || {});
	      if (target.size) {
	        target.fileSizeKB = Math.round(target.size / 1000);
	      }
	      return target;
	    },

	    previewTemplate: '\
	      <div class="image-file-thumbnail float-l">\
	        <img src="{{imageUrl}}" >\
	      </div>\
	      <div class="image-file-info float-l">\
	        <ul>\
	          {{#if name}}<li>{{name}}</li>{{/if}}\
	          {{#if fileSizeKB}}<li>{{fileSizeKB}}(KB)</li>{{/if}}\
	        </ul>\
	      </div>',

	    fileTypes: ['.png', '.gif', '.jpeg', '.jpg']

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: [2, 11] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(63),
	  __webpack_require__(42),
	  __webpack_require__(46),
	  __webpack_require__(89),
	  __webpack_require__(7),
	  __webpack_require__(49),
	  __webpack_require__(90),
	  __webpack_require__(91)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, BaseInput, Model, BaseCollection, ErrorParser, StringUtil, TemplateUtil, FileUploadInput,
	             PreviewListView) {

	  function parseJSON(source) {
	    if (!_.isString(source)) {
	      return _.clone(source);
	    }
	    try {
	      return JSON.parse(source);
	    }
	    catch (e) {
	      return ;
	    }
	  }

	  return BaseInput.extend({

	    idAttribute: 'id',

	    /**
	     * @property {String} template for rendering preview content.
	     * @abstract
	     */
	    previewTemplate: null,

	    /**
	     * @property {Array|Function} to suggest only to select particular file types otherwise any type of files.
	     * @link https://www.w3.org/TR/html-markup/input.file.html
	     *
	     * @example
	     * ['.png','.jpg']
	     * ['.csv']
	     * ['.crt', '.pem']
	     *
	     */
	    fileTypes: null,

	    /**
	     * Transform/normalise the response before rendering if necessary. default is _.identity.
	     * @type {Function}
	     */
	    parse: _.identity,

	    /**
	     * @property {String|Function} form field for file submit request.
	     */
	    fileFieldName: 'file',

	    fileUploadInputEvents: {
	      clear: 'clearError',
	      success: 'addFileData',
	      error: 'showError'
	    },

	    constructor: function (options) {
	      /* eslint max-statements: [2, 18] */

	      var opts = _.extend({
	        fileTypes: _.result(this, 'fileTypes'),
	        fileFieldName: _.result(options.params, 'fileFieldName') || _.result(this, 'fileFieldName'),
	        endpoint: _.result(this, 'endpoint')
	      }, options, this.getParams(options));
	      this.fileUploadInput = new FileUploadInput(opts);

	      BaseInput.apply(this, arguments);

	      var Collection = BaseCollection.extend({
	        model: Model.extend({
	          extraProperties: true,
	          idAttribute: this.getParamOrAttribute('idAttribute')
	        })
	      });

	      this.collection = new Collection();

	      this.previewListView = new PreviewListView({
	        collection: this.collection,
	        params: options.params,
	        parse: this.parse,
	        previewTemplate: this.previewTemplate
	      });

	      this.fileUploadInput.setCollection(this.collection);

	      this.listenTo(this.collection, 'update', this.update);
	      this.listenTo(this.collection, 'update', this.resize);

	      this.$el.append(this.fileUploadInput.render().el);
	      this.$el.append(this.previewListView.render().el);

	      this.$el.addClass('o-form-control file-upload clearfix');
	    },

	    previewFromModel: function () {
	      this.collection.reset();

	      var id = this.getModelValue(),
	          previewData = this.getParam('previewData'),
	          previewEndpoint = this.options.params && this.options.params.previewEndpoint,
	          collection = this.collection;

	      if (id) {
	        if (previewData) {
	          collection.set(previewData);
	        }
	        else if (previewEndpoint) {
	          var url = _.isString(previewEndpoint) ? TemplateUtil.tpl(previewEndpoint) : previewEndpoint;

	          var promisses = _.map(_.isArray(id) ? id : [id], function (id) {
	            return $.get(url({id: id}));
	          });

	          $.when.apply($, promisses).then(function () {
	            var data = promisses.length == 1 ? arguments[0] : _.pluck(arguments, 0);
	            collection.set(data);
	          });

	        }
	      }
	    },

	    clearError: function () {
	      this.model.trigger('form:clear-error:' + this.options.name);
	    },

	    addFileData: function (resp) {
	      var model = parseJSON(resp);
	      if (model) {
	        this.collection.add(model);
	      }
	    },


	    showError: function (resp) {
	      this.clearError();

	      if (resp && resp.status === 0 && resp.statusText == 'abort') {
	        return ;
	      }

	      var errorSummary;
	      if (_.isString(resp)) {
	        errorSummary = resp;
	      }
	      else {
	        var data = ErrorParser.getResponseJSON(resp);
	        errorSummary = data && data.errorSummary || StringUtil.localize('oform.file.upload.error');
	      }

	      var validationError = {};
	      validationError[this.options.name] = errorSummary;
	      this.model.trigger('invalid', this.model, validationError, false);
	    },

	    /**
	     * BASE INPUT OVERRIDES
	     */

	    editMode: function () {
	      this.previewFromModel();
	      this.fileUploadInput.toggle(true);
	    },

	    readMode: function () {
	      return this.editMode();
	    },

	    val: function () {
	      var data = this.collection.pluck(this.getParamOrAttribute('idAttribute'));
	      return this.getParam('multi') ? data : data[0];
	    },

	    focus: function () {
	      this.fileUploadInput.focus();
	    },

	    // skip inline validation
	    validate: _.noop,

	    /**
	     * HELPER FUNCTIONS
	     */

	    getParamOrAttribute: function (name) {
	      return this.getParam(name) || _.result(this, name);
	    },

	    getParams: function (options) {
	      var opts = options || this.options;
	      return _.clone(opts && opts.params || {});
	    },

	    getParam: function (key, defaultValue) {
	      var params = this.getParams();
	      var res = _.resultCtx(params, key, this);
	      return !_.isUndefined(res) ? res : defaultValue;
	    }

	  }, {
	    // test hooks
	    parseJSON: parseJSON
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {

	  return {

	    /**
	     * Helper function that returns the json output of an xhr objext
	     * @param  {jqXhr} xhr
	     * @return {Object}
	     */
	    getResponseJSON: function (xhr) {
	      try {
	        return xhr.responseJSON || JSON.parse(xhr.responseText);
	      }
	      catch (e) {
	        return;
	      }
	    },

	    /**
	     * Parses an error summary to extract a field name and an error message
	     * @param  {String} errorSummary The raw error summary
	     * @return {String[]} An array with two members: [field name, error message]
	     */
	    parseErrorSummary: function (errorSummary) {
	      // error format is: `fieldName: The field cannot be left blank`
	      var matches = errorSummary.match(/^([^\:]+)\: (.+)$/);
	      if (matches) {
	        return [matches[1], matches[2]];
	      }
	    },

	    /**
	     * Parses the response for errors
	     * Returns a map of field names > array or error messages
	     * Example:
	     * ```javascript
	     * {
	     *   url: ['The field cannot be left blank', 'The field has to be a valid URI'],
	     *   name: ['The field cannot be left blank']
	     * }
	     * ```
	     * @param  {Object} resp
	     * @return {Object}
	     */
	    parseFieldErrors: function (resp) {
	      var responseJSON = this.getResponseJSON(resp),
	          errors = {};

	      // xhr error object
	      if (responseJSON) {
	        _.each(responseJSON.errorCauses || [], function (cause) {
	          var res = this.parseErrorSummary(cause && cause.errorSummary || '');
	          if (res) {
	            var fieldName = res[0], message = res[1];
	            errors[fieldName] || (errors[fieldName] = []);
	            errors[fieldName].push(message);
	          }
	        }, this);
	      }
	      // validation key/value object
	      else if (_.isObject(resp) && _.size(resp)) {
	        _.each(resp, function (msg, field) {
	          errors[field] = [msg];
	        });
	      }
	      return _.size(errors) ? errors : undefined;
	    }
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(48),
	  __webpack_require__(13),
	  __webpack_require__(7)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, BaseView, Logger, StringUtil) {


	  function createAcceptFileTypes(fileTypes) {
	    return (fileTypes || []).join(',');
	  }

	  return BaseView.extend({

	    className: 'file-upload-wrap',

	    template: '\
	      <span class="file-upload-progress-indicator-wrap input-fix o-form-control hide">\
	        <span class="file-upload-progress-indicator"></span>\
	        <div class="file-upload-cancel file-upload-uploading"></div>\
	      </span>\
	      <div class="facade">\
	        <input type="text" class="file-name-text-field" placeholder="{{placeholder}}" \
	               title="{{browseFilesTitle}}" readonly>\
	        <a title="{{browseFilesTitle}}" class="browse-file-button link-button" href="#">{{browseFilesTitle}}</a>\
	      </div>\
	      <div class="o-form-explain hide"></div>\
	      <input type="file" class="m-file hide"{{#if accept}} accept="{{accept}}"{{/if}}\
	             {{#if multiple}} multiple="multiple"{{/if}}>\
	    ',

	    events: {
	      'click .file-upload-cancel': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        this.abortRequest();
	        this.render();
	      },
	      'click .facade': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        this.browseFiles();
	      },
	      'change .m-file': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        this.makeRequest(e.target.files);
	      }
	    },

	    initialize: function () {
	      _.bindAll(this, 'onProgress', 'onProgressComplete');
	      this.onSuccess = _.debounce(this.onSuccess, 1000);

	      this.listenTo(this.model, 'change:__edit__', this.render);
	    },

	    getTemplateData: function () {
	      return {
	        browseFilesTitle: StringUtil.localize('oform.browse.files'),
	        accept: createAcceptFileTypes(this.options.fileTypes),
	        multiple: this.options.multi,
	        placeholder: this.options.placeholder
	      };
	    },

	    postRender: function () {
	      this.delegateEvents();
	    },

	    browseFiles: function () {
	      this.$('.m-file').val('').click();

	      // delay hiding errors, so it does it after the file browser dialog is open (on the "background")
	      _.delay(function () {
	        this.trigger('clear');
	      }.bind(this), 2000);
	    },

	    setCollection: function (collection) {
	      this.collection = this.options.collection = collection;
	      this.listenTo(collection, 'update', function () {
	        this.toggle(collection.length === 0);
	      });
	    },

	    setFileName: function (displayName) {
	      this.$('.file-name-text-field').val(displayName || '');
	      this.$('.file-upload-progress-indicator').html(displayName || '');
	    },

	    startUploading: function (displayName) {
	      this.$('.file-upload-progress-indicator-wrap').removeClass('hide');
	      this.$('.file-upload-progress-indicator').css('width', '0px');
	      this.$('.facade').hide();
	      this.$('.file-upload-cancel').show();
	      this.setFileName(displayName);
	    },

	    /**
	     * As long as user chooses an file, upload to server and then display meta data.
	     * It will do nothing if File API is not supported or no file selected.
	     */
	    makeRequest: function (files) {
	      if (files.length === 0) {
	        Logger.warn('No files have been selected.');
	        return;
	      }

	      var displayFileName = _.pluck(files, 'name').join(', '),
	          maxItems = this.getMaxItems();

	      if (files.length + this.collection.length > maxItems) {
	        this.trigger(
	          'error',
	          StringUtil.localize('oform.file.upload.too.many.files', 'messages', [maxItems])
	        );
	        return;
	      }

	      this.trigger('clear');

	      this.startUploading(displayFileName);

	      this.sendUploadRequest(files)
	        .done(_.bind(this.onSuccess, this))
	        .fail(_.bind(this.onFailure, this));
	    },

	    sendUploadRequest: function (files) {
	      var self = this,
	          formData = new FormData(),
	          fileFieldName = this.options.fileFieldName;

	      _.each(files, function (file) {
	        formData.append(fileFieldName, file);
	      });

	      formData.append('_xsrfToken', $('#_xsrfToken').text());

	      var options = {
	        url: this.options.endpoint,
	        method: 'POST',
	        data: formData,
	        xhr: function () {
	          var xhr = $.ajaxSettings.xhr() ;
	          xhr.upload.addEventListener('progress', self.onProgress, false);
	          xhr.upload.addEventListener('load', self.onProgressComplete, false);
	          return xhr ;
	        },
	        // do not convert data to string
	        processData: false,
	        // to avoid override header content type. particularly for boundary
	        contentType: false
	      };
	      this._xhr = $.ajax(options);
	      return this._xhr;
	    },

	    abortRequest: function () {
	      Logger.warn('Upload aborted...');
	      if (this._xhr) {
	        this._xhr.abort();
	      }
	    },

	    onProgress: function (e) {
	      if (e.lengthComputable) {
	        var percentage = Math.round((e.loaded * 100) / e.total);
	        Logger.info('Upload in progress...', percentage + '%');
	        this.$('.file-upload-progress-indicator').css('width', (percentage + '%'));
	        return percentage; // test hook
	      }
	    },

	    onProgressComplete: function () {
	      Logger.info('Upload complete, processing...');
	      this.$('.file-upload-cancel').fadeOut();
	    },

	    onSuccess: function (resp) {
	      Logger.info('Upload processing complete...');
	      this.$('.file-upload-progress-indicator-wrap').addClass('hide');
	      this.toggle(false);
	      this.trigger('success', resp);
	    },

	    onFailure: function (xhr) {
	      Logger.warn('Upload failed...');
	      this.setFileName();
	      this.$('.file-upload-progress-indicator-wrap').addClass('hide');
	      this.$('.facade').show();
	      this.toggle(true);
	      this.trigger('error', xhr);
	    },

	    toggle: function (bool) {
	      this.$el.addClass('hide');

	      var doShow = bool;
	      if (this.options.multi) {
	        doShow = this.collection.length < this.getMaxItems();
	      }
	      else if (this.collection.length > 0) {
	        doShow = false;
	      }

	      if (doShow) {
	        this.render().$el.removeClass('hide');
	      }
	      return doShow; // test hook
	    },

	    focus: function () {
	      this.$('.facade').focus();
	    },

	    getMaxItems: function () {
	      var schema = this.model.getPropertySchema(this.options.name) || {};
	      return schema.maxItems || Infinity;
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(48),
	  __webpack_require__(51)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView, ListView) {

	  function createItem(options) {

	    function parse(src) {
	      var data = (options.params && options.params.parse || _.identity).call(null, src);
	      // run the per-uploder parse later, after the data is normalized by the per-intance parser
	      return (options.parse || _.identity).call(null, data);
	    }

	    return BaseView.extend({

	      className: 'file-upload-preview',

	      events: {
	        'click .file-upload-cancel': function (e) {
	          e.preventDefault();
	          e.stopPropagation();
	          this.collection.remove(this.model);
	        },
	      },

	      getTemplateData: function () {
	        var item = parse(this.model.toJSON()),
	            items = [_.omit(item, 'chain')].concat((item.chain || []).map(parse));

	        return _.extend({}, item, {
	          certNames: _.pluck(items, 'certName').join(' > '),
	          multiItems: items.length > 1,
	          items: items.map(function (val) {
	            return _.extend({}, val, {
	              multiItems: items.length > 1
	            });
	          })
	        });

	      },

	      template: options.previewTemplate,

	      postRender: function () {
	        this.$el.prepend('<div class="file-upload-cancel"></div>');
	        this.delegateEvents();
	      }
	    });
	  }

	  return ListView.extend({
	    className: 'file-upload-preview-wrap',
	    constructor: function (options) {
	      this.item = createItem(options);
	      ListView.apply(this, arguments);
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(2),
	  __webpack_require__(16),
	  __webpack_require__(7),
	  __webpack_require__(88)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, moment, StringUtil, BaseFileUploader) {

	  return BaseFileUploader.extend({

	    className: 'cert-file-upload',

	    events: {
	      'click .cert-expand-details': function (e) {
	        e && e.preventDefault();
	        var self = this,
	            $certDetails = $(e.target).siblings('.cert-details'),
	            duration = $certDetails.length * 75,
	            resize = function () {
	              self.model.trigger('form:resize');
	            };

	        if ($certDetails.is(':hidden') || $certDetails.hasClass('hide')) {
	          $certDetails.removeClass('hide').hide().slideDown(duration, resize);
	          $(e.target).text(StringUtil.localize('oform.certificate.hide.chain'));
	        }
	        else {
	          $certDetails.slideUp(duration, resize);
	          $(e.target).text(StringUtil.localize('oform.certificate.view.chain'));
	        }
	      }
	    },

	    parse: function (src) {
	      var target = _.clone(src || {});
	      if (target.notAfter) {
	        var diff = moment.utc(target.notAfter).diff(moment.utc(), 'days');
	        if (diff > 0) {
	          _.extend(target, {
	            expiresInDays: diff
	          });
	        }
	        if (diff < 14) {
	          target.expireClass = 'cert-expired';
	        }
	      }
	      return target;
	    },

	    previewTemplate: '\
	      <div class="cert-thumbnail"><span class="icon icon-32 icon-only file-cert-32"></span></div>\
	      <ul class="cert-details-header">\
	        {{#if certNames}}<li class="cert-names">{{certNames}}</li>{{/if}}\
	        {{#if uploadedBy}}{{#if uploadedOn}}\
	        <li class="cert-upload-info">\
	          {{i18n code="oform.certificate.uploaded" bundle="messages" arguments="uploadedBy;uploadedOn"}} \
	        </li>\
	        {{/if}}{{/if}}\
	      </ul>\
	      {{#each items}}\
	        <ul class="cert-details{{#if multiItems}} hide{{/if}}">\
	          {{#if multiItems}}{{#if certName}}\
	            <li class="cert-name">{{certName}}</li>\
	          {{/if}}{{/if}}\
	          {{#if issuer}}<li class="cert-issuer">{{issuer}}</li>{{/if}}\
	          {{#if notBefore}}{{#if notAfter}}\
	            <li class="cert-valid-date">\
	              {{i18n code="oform.certificate.valid" bundle="messages" arguments="notBefore;notAfter"}}\
	            </li>\
	          {{/if}}{{/if}}\
	          <li class="cert-expiration {{expireClass}}">\
	            {{#if expiresInDays}}\
	            {{i18n code="oform.certificate.expires" bundle="messages" arguments="expiresInDays"}}\
	            {{else}}\
	            {{i18n code="oform.certificate.expired" bundle="messages"}}\
	            {{/if}}\
	          </li>\
	        </ul>\
	      {{/each}}\
	      {{#if multiItems}}\
	        <a href="#" class="cert-expand-details">{{i18n code="oform.certificate.view.chain"}}</a>\
	      {{/if}}\
	      ',

	    fileTypes: ['.crt', '.pem']

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(49),
	  __webpack_require__(48),
	  __webpack_require__(94)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, TemplateUtil, BaseView) {

	  /**
	   * @class InputLabel
	   * @extends {Okta.View}
	   * @private
	   * The input's label.
	   */
	  return BaseView.extend({

	    className: 'okta-form-label o-form-label',

	    attributes: {
	      'data-se': 'o-form-label'
	    },

	    /**
	     * @constructor
	     * @param  {Object} options options hash
	     * @param  {String} [options.type] Input type
	     * @param  {String|Function} [options.label] Label text
	     * @param  {String|Function} [options.sublabel] Sub label text
	     * @param  {String|Function} [options.tooltip] Tooltip text
	     * @param  {String|Function} [options.inputId] Id of the inputs
	     * @param  {String|Function} [options.id] Id of the inputs
	     */
	    constructor: function (options) {
	      /* eslint max-statements: [2, 16] complexity: [2, 7]*/
	      _.defaults(options, {inputId: options.id});
	      delete options.id;

	      BaseView.apply(this, arguments);

	      var template;
	      if (this._isLabelView(options.label)) {
	        template = '<label for="{{inputId}}"></label>';
	      } else if (_.contains(['radio', 'checkbox'], options.type) || !options.label) {
	        template = '{{label}}';
	      } else {
	        //space added in the end of the label to avoid selecting label text with double click in read mode
	        template = '<label for="{{inputId}}">{{label}}&nbsp;</label>';
	      }
	      if (options.sublabel) {
	        template += '<span class="o-form-explain">{{sublabel}}</span>';
	      }
	      if (options.tooltip) {
	        if (_.isString(options.tooltip)) {
	          options.tooltip = {
	            text: options.tooltip
	          };
	        }
	        template += '<span class="o-form-tooltip icon-16 icon-only form-help-16" title="{{tooltip.text}}"></span>';
	      }
	      this.template = TemplateUtil.tpl(template);

	    },

	    getTemplateData: function () {
	      var options = {label: ''};
	      _.each(['inputId', 'label', 'sublabel', 'tooltip'], function (option) {
	        options[option] = _.resultCtx(this.options, option, this);
	      }, this);

	      return options;
	    },

	    _isLabelView: function (label) {
	      return !_.isUndefined(label) && label instanceof BaseView;
	    },

	    postRender: function () {
	      var options = this.getTemplateData();
	      if (this._isLabelView(options.label)) {
	        this.removeChildren();
	        this.add(options.label, 'label');
	      }

	      if (options.tooltip) {
	        this.$('.o-form-tooltip').qtip(_.extend({
	          style: {classes: 'qtip-custom qtip-shadow'},
	          position: {
	            my: 'bottom left',
	            at: 'top center'
	          },
	          hide: {fixed: true},
	          show: {delay: 0}
	        }, options.tooltip.options));
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * qTip2 - Pretty powerful tooltips - v3.0.3
	 * http://qtip2.com
	 *
	 * Copyright (c) 2016 
	 * Released under the MIT licenses
	 * http://jquery.org/license
	 *
	 * Date: Wed May 11 2016 10:31 GMT+0100+0100
	 * Plugins: tips modal viewport svg imagemap ie6
	 * Styles: core basic css3
	 */
	/*global window: false, jQuery: false, console: false, define: false */

	/* Cache window, document, undefined */
	(function( window, document, undefined ) {

	// Uses AMD or browser globals to create a jQuery plugin.
	(function( factory ) {
		"use strict";
		if(true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if(jQuery && !jQuery.fn.qtip) {
			factory(jQuery);
		}
	}
	(function($) {
		"use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/
	;// Munge the primitives - Paul Irish tip
	var TRUE = true,
	FALSE = false,
	NULL = null,

	// Common variables
	X = 'x', Y = 'y',
	WIDTH = 'width',
	HEIGHT = 'height',

	// Positioning sides
	TOP = 'top',
	LEFT = 'left',
	BOTTOM = 'bottom',
	RIGHT = 'right',
	CENTER = 'center',

	// Position adjustment types
	FLIP = 'flip',
	FLIPINVERT = 'flipinvert',
	SHIFT = 'shift',

	// Shortcut vars
	QTIP, PROTOTYPE, CORNER, CHECKS,
	PLUGINS = {},
	NAMESPACE = 'qtip',
	ATTR_HAS = 'data-hasqtip',
	ATTR_ID = 'data-qtip-id',
	WIDGET = ['ui-widget', 'ui-tooltip'],
	SELECTOR = '.'+NAMESPACE,
	INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

	CLASS_FIXED = NAMESPACE+'-fixed',
	CLASS_DEFAULT = NAMESPACE + '-default',
	CLASS_FOCUS = NAMESPACE + '-focus',
	CLASS_HOVER = NAMESPACE + '-hover',
	CLASS_DISABLED = NAMESPACE+'-disabled',

	replaceSuffix = '_replacedByqTip',
	oldtitle = 'oldtitle',
	trackingBound,

	// Browser detection
	BROWSER = {
		/*
		 * IE version detection
		 *
		 * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
		 * Credit to James Padolsey for the original implemntation!
		 */
		ie: (function() {
			/* eslint-disable no-empty */
			var v, i;
			for (
				v = 4, i = document.createElement('div');
				(i.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->') && i.getElementsByTagName('i')[0];
				v+=1
			) {}
			return v > 4 ? v : NaN;
			/* eslint-enable no-empty */
		})(),

		/*
		 * iOS version detection
		 */
		iOS: parseFloat(
			('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
			.replace('undefined', '3_2').replace('_', '.').replace('_', '')
		) || FALSE
	};
	;function QTip(target, options, id, attr) {
		// Elements and ID
		this.id = id;
		this.target = target;
		this.tooltip = NULL;
		this.elements = { target: target };

		// Internal constructs
		this._id = NAMESPACE + '-' + id;
		this.timers = { img: {} };
		this.options = options;
		this.plugins = {};

		// Cache object
		this.cache = {
			event: {},
			target: $(),
			disabled: FALSE,
			attr: attr,
			onTooltip: FALSE,
			lastClass: ''
		};

		// Set the initial flags
		this.rendered = this.destroyed = this.disabled = this.waiting =
			this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
	}
	PROTOTYPE = QTip.prototype;

	PROTOTYPE._when = function(deferreds) {
		return $.when.apply($, deferreds);
	};

	PROTOTYPE.render = function(show) {
		if(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

		var self = this,
			options = this.options,
			cache = this.cache,
			elements = this.elements,
			text = options.content.text,
			title = options.content.title,
			button = options.content.button,
			posOptions = options.position,
			deferreds = [];

		// Add ARIA attributes to target
		$.attr(this.target[0], 'aria-describedby', this._id);

		// Create public position object that tracks current position corners
		cache.posClass = this._createPosClass(
			(this.position = { my: posOptions.my, at: posOptions.at }).my
		);

		// Create tooltip element
		this.tooltip = elements.tooltip = $('<div/>', {
			'id': this._id,
			'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass ].join(' '),
			'width': options.style.width || '',
			'height': options.style.height || '',
			'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

			/* ARIA specific attributes */
			'role': 'alert',
			'aria-live': 'polite',
			'aria-atomic': FALSE,
			'aria-describedby': this._id + '-content',
			'aria-hidden': TRUE
		})
		.toggleClass(CLASS_DISABLED, this.disabled)
		.attr(ATTR_ID, this.id)
		.data(NAMESPACE, this)
		.appendTo(posOptions.container)
		.append(
			// Create content element
			elements.content = $('<div />', {
				'class': NAMESPACE + '-content',
				'id': this._id + '-content',
				'aria-atomic': TRUE
			})
		);

		// Set rendered flag and prevent redundant reposition calls for now
		this.rendered = -1;
		this.positioning = TRUE;

		// Create title...
		if(title) {
			this._createTitle();

			// Update title only if its not a callback (called in toggle if so)
			if(!$.isFunction(title)) {
				deferreds.push( this._updateTitle(title, FALSE) );
			}
		}

		// Create button
		if(button) { this._createButton(); }

		// Set proper rendered flag and update content if not a callback function (called in toggle)
		if(!$.isFunction(text)) {
			deferreds.push( this._updateContent(text, FALSE) );
		}
		this.rendered = TRUE;

		// Setup widget classes
		this._setWidget();

		// Initialize 'render' plugins
		$.each(PLUGINS, function(name) {
			var instance;
			if(this.initialize === 'render' && (instance = this(self))) {
				self.plugins[name] = instance;
			}
		});

		// Unassign initial events and assign proper events
		this._unassignEvents();
		this._assignEvents();

		// When deferreds have completed
		this._when(deferreds).then(function() {
			// tooltiprender event
			self._trigger('render');

			// Reset flags
			self.positioning = FALSE;

			// Show tooltip if not hidden during wait period
			if(!self.hiddenDuringWait && (options.show.ready || show)) {
				self.toggle(TRUE, cache.event, FALSE);
			}
			self.hiddenDuringWait = FALSE;
		});

		// Expose API
		QTIP.api[this.id] = this;

		return this;
	};

	PROTOTYPE.destroy = function(immediate) {
		// Set flag the signify destroy is taking place to plugins
		// and ensure it only gets destroyed once!
		if(this.destroyed) { return this.target; }

		function process() {
			if(this.destroyed) { return; }
			this.destroyed = TRUE;

			var target = this.target,
				title = target.attr(oldtitle),
				timer;

			// Destroy tooltip if rendered
			if(this.rendered) {
				this.tooltip.stop(1,0).find('*').remove().end().remove();
			}

			// Destroy all plugins
			$.each(this.plugins, function() {
				this.destroy && this.destroy();
			});

			// Clear timers
			for (timer in this.timers) {
				if (this.timers.hasOwnProperty(timer)) {
					clearTimeout(this.timers[timer]);
				}
			}

			// Remove api object and ARIA attributes
			target.removeData(NAMESPACE)
				.removeAttr(ATTR_ID)
				.removeAttr(ATTR_HAS)
				.removeAttr('aria-describedby');

			// Reset old title attribute if removed
			if(this.options.suppress && title) {
				target.attr('title', title).removeAttr(oldtitle);
			}

			// Remove qTip events associated with this API
			this._unassignEvents();

			// Remove ID from used id objects, and delete object references
			// for better garbage collection and leak protection
			this.options = this.elements = this.cache = this.timers =
				this.plugins = this.mouse = NULL;

			// Delete epoxsed API object
			delete QTIP.api[this.id];
		}

		// If an immediate destroy is needed
		if((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
			this.tooltip.one('tooltiphidden', $.proxy(process, this));
			!this.triggering && this.hide();
		}

		// If we're not in the process of hiding... process
		else { process.call(this); }

		return this.target;
	};
	;function invalidOpt(a) {
		return a === NULL || $.type(a) !== 'object';
	}

	function invalidContent(c) {
		return !($.isFunction(c) || 
	            c && c.attr || 
	            c.length || 
	            $.type(c) === 'object' && (c.jquery || c.then));
	}

	// Option object sanitizer
	function sanitizeOptions(opts) {
		var content, text, ajax, once;

		if(invalidOpt(opts)) { return FALSE; }

		if(invalidOpt(opts.metadata)) {
			opts.metadata = { type: opts.metadata };
		}

		if('content' in opts) {
			content = opts.content;

			if(invalidOpt(content) || content.jquery || content.done) {
				text = invalidContent(content) ? FALSE : content;
				content = opts.content = {
					text: text
				};
			}
			else { text = content.text; }

			// DEPRECATED - Old content.ajax plugin functionality
			// Converts it into the proper Deferred syntax
			if('ajax' in content) {
				ajax = content.ajax;
				once = ajax && ajax.once !== FALSE;
				delete content.ajax;

				content.text = function(event, api) {
					var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

					deferred = $.ajax(
						$.extend({}, ajax, { context: api })
					)
					.then(ajax.success, NULL, ajax.error)
					.then(function(newContent) {
						if(newContent && once) { api.set('content.text', newContent); }
						return newContent;
					},
					function(xhr, status, error) {
						if(api.destroyed || xhr.status === 0) { return; }
						api.set('content.text', status + ': ' + error);
					});

					return !once ? (api.set('content.text', loading), deferred) : loading;
				};
			}

			if('title' in content) {
				if($.isPlainObject(content.title)) {
					content.button = content.title.button;
					content.title = content.title.text;
				}

				if(invalidContent(content.title || FALSE)) {
					content.title = FALSE;
				}
			}
		}

		if('position' in opts && invalidOpt(opts.position)) {
			opts.position = { my: opts.position, at: opts.position };
		}

		if('show' in opts && invalidOpt(opts.show)) {
			opts.show = opts.show.jquery ? { target: opts.show } :
				opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
		}

		if('hide' in opts && invalidOpt(opts.hide)) {
			opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
		}

		if('style' in opts && invalidOpt(opts.style)) {
			opts.style = { classes: opts.style };
		}

		// Sanitize plugin options
		$.each(PLUGINS, function() {
			this.sanitize && this.sanitize(opts);
		});

		return opts;
	}

	// Setup builtin .set() option checks
	CHECKS = PROTOTYPE.checks = {
		builtin: {
			// Core checks
			'^id$': function(obj, o, v, prev) {
				var id = v === TRUE ? QTIP.nextid : v,
					newId = NAMESPACE + '-' + id;

				if(id !== FALSE && id.length > 0 && !$('#'+newId).length) {
					this._id = newId;

					if(this.rendered) {
						this.tooltip[0].id = this._id;
						this.elements.content[0].id = this._id + '-content';
						this.elements.title[0].id = this._id + '-title';
					}
				}
				else { obj[o] = prev; }
			},
			'^prerender': function(obj, o, v) {
				v && !this.rendered && this.render(this.options.show.ready);
			},

			// Content checks
			'^content.text$': function(obj, o, v) {
				this._updateContent(v);
			},
			'^content.attr$': function(obj, o, v, prev) {
				if(this.options.content.text === this.target.attr(prev)) {
					this._updateContent( this.target.attr(v) );
				}
			},
			'^content.title$': function(obj, o, v) {
				// Remove title if content is null
				if(!v) { return this._removeTitle(); }

				// If title isn't already created, create it now and update
				v && !this.elements.title && this._createTitle();
				this._updateTitle(v);
			},
			'^content.button$': function(obj, o, v) {
				this._updateButton(v);
			},
			'^content.title.(text|button)$': function(obj, o, v) {
				this.set('content.'+o, v); // Backwards title.text/button compat
			},

			// Position checks
			'^position.(my|at)$': function(obj, o, v){
				if('string' === typeof v) {
					this.position[o] = obj[o] = new CORNER(v, o === 'at');
				}
			},
			'^position.container$': function(obj, o, v){
				this.rendered && this.tooltip.appendTo(v);
			},

			// Show checks
			'^show.ready$': function(obj, o, v) {
				v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
			},

			// Style checks
			'^style.classes$': function(obj, o, v, p) {
				this.rendered && this.tooltip.removeClass(p).addClass(v);
			},
			'^style.(width|height)': function(obj, o, v) {
				this.rendered && this.tooltip.css(o, v);
			},
			'^style.widget|content.title': function() {
				this.rendered && this._setWidget();
			},
			'^style.def': function(obj, o, v) {
				this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
			},

			// Events check
			'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
				this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
			},

			// Properties which require event reassignment
			'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
				if(!this.rendered) { return; }

				// Set tracking flag
				var posOptions = this.options.position;
				this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

				// Reassign events
				this._unassignEvents();
				this._assignEvents();
			}
		}
	};

	// Dot notation converter
	function convertNotation(options, notation) {
		var i = 0, obj, option = options,

		// Split notation into array
		levels = notation.split('.');

		// Loop through
		while(option = option[ levels[i++] ]) {
			if(i < levels.length) { obj = option; }
		}

		return [obj || options, levels.pop()];
	}

	PROTOTYPE.get = function(notation) {
		if(this.destroyed) { return this; }

		var o = convertNotation(this.options, notation.toLowerCase()),
			result = o[0][ o[1] ];

		return result.precedance ? result.string() : result;
	};

	function setCallback(notation, args) {
		var category, rule, match;

		for(category in this.checks) {
			if (!this.checks.hasOwnProperty(category)) { continue; }

			for(rule in this.checks[category]) {
				if (!this.checks[category].hasOwnProperty(rule)) { continue; }

				if(match = (new RegExp(rule, 'i')).exec(notation)) {
					args.push(match);

					if(category === 'builtin' || this.plugins[category]) {
						this.checks[category][rule].apply(
							this.plugins[category] || this, args
						);
					}
				}
			}
		}
	}

	var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
		rrender = /^prerender|show\.ready/i;

	PROTOTYPE.set = function(option, value) {
		if(this.destroyed) { return this; }

		var rendered = this.rendered,
			reposition = FALSE,
			options = this.options,
			name;

		// Convert singular option/value pair into object form
		if('string' === typeof option) {
			name = option; option = {}; option[name] = value;
		}
		else { option = $.extend({}, option); }

		// Set all of the defined options to their new values
		$.each(option, function(notation, val) {
			if(rendered && rrender.test(notation)) {
				delete option[notation]; return;
			}

			// Set new obj value
			var obj = convertNotation(options, notation.toLowerCase()), previous;
			previous = obj[0][ obj[1] ];
			obj[0][ obj[1] ] = val && val.nodeType ? $(val) : val;

			// Also check if we need to reposition
			reposition = rmove.test(notation) || reposition;

			// Set the new params for the callback
			option[notation] = [obj[0], obj[1], val, previous];
		});

		// Re-sanitize options
		sanitizeOptions(options);

		/*
		 * Execute any valid callbacks for the set options
		 * Also set positioning flag so we don't get loads of redundant repositioning calls.
		 */
		this.positioning = TRUE;
		$.each(option, $.proxy(setCallback, this));
		this.positioning = FALSE;

		// Update position if needed
		if(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
			this.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );
		}

		return this;
	};
	;PROTOTYPE._update = function(content, element) {
		var self = this,
			cache = this.cache;

		// Make sure tooltip is rendered and content is defined. If not return
		if(!this.rendered || !content) { return FALSE; }

		// Use function to parse content
		if($.isFunction(content)) {
			content = content.call(this.elements.target, cache.event, this) || '';
		}

		// Handle deferred content
		if($.isFunction(content.then)) {
			cache.waiting = TRUE;
			return content.then(function(c) {
				cache.waiting = FALSE;
				return self._update(c, element);
			}, NULL, function(e) {
				return self._update(e, element);
			});
		}

		// If content is null... return false
		if(content === FALSE || !content && content !== '') { return FALSE; }

		// Append new content if its a DOM array and show it if hidden
		if(content.jquery && content.length > 0) {
			element.empty().append(
				content.css({ display: 'block', visibility: 'visible' })
			);
		}

		// Content is a regular string, insert the new content
		else { element.html(content); }

		// Wait for content to be loaded, and reposition
		return this._waitForContent(element).then(function(images) {
			if(self.rendered && self.tooltip[0].offsetWidth > 0) {
				self.reposition(cache.event, !images.length);
			}
		});
	};

	PROTOTYPE._waitForContent = function(element) {
		var cache = this.cache;

		// Set flag
		cache.waiting = TRUE;

		// If imagesLoaded is included, ensure images have loaded and return promise
		return ( $.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([]) )
			.done(function() { cache.waiting = FALSE; })
			.promise();
	};

	PROTOTYPE._updateContent = function(content, reposition) {
		this._update(content, this.elements.content, reposition);
	};

	PROTOTYPE._updateTitle = function(content, reposition) {
		if(this._update(content, this.elements.title, reposition) === FALSE) {
			this._removeTitle(FALSE);
		}
	};

	PROTOTYPE._createTitle = function()
	{
		var elements = this.elements,
			id = this._id+'-title';

		// Destroy previous title element, if present
		if(elements.titlebar) { this._removeTitle(); }

		// Create title bar and title elements
		elements.titlebar = $('<div />', {
			'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
		})
		.append(
			elements.title = $('<div />', {
				'id': id,
				'class': NAMESPACE + '-title',
				'aria-atomic': TRUE
			})
		)
		.insertBefore(elements.content)

		// Button-specific events
		.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {
			$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
		})
		.delegate('.qtip-close', 'mouseover mouseout', function(event){
			$(this).toggleClass('ui-state-hover', event.type === 'mouseover');
		});

		// Create button if enabled
		if(this.options.content.button) { this._createButton(); }
	};

	PROTOTYPE._removeTitle = function(reposition)
	{
		var elements = this.elements;

		if(elements.title) {
			elements.titlebar.remove();
			elements.titlebar = elements.title = elements.button = NULL;

			// Reposition if enabled
			if(reposition !== FALSE) { this.reposition(); }
		}
	};
	;PROTOTYPE._createPosClass = function(my) {
		return NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();
	};

	PROTOTYPE.reposition = function(event, effect) {
		if(!this.rendered || this.positioning || this.destroyed) { return this; }

		// Set positioning flag
		this.positioning = TRUE;

		var cache = this.cache,
			tooltip = this.tooltip,
			posOptions = this.options.position,
			target = posOptions.target,
			my = posOptions.my,
			at = posOptions.at,
			viewport = posOptions.viewport,
			container = posOptions.container,
			adjust = posOptions.adjust,
			method = adjust.method.split(' '),
			tooltipWidth = tooltip.outerWidth(FALSE),
			tooltipHeight = tooltip.outerHeight(FALSE),
			targetWidth = 0,
			targetHeight = 0,
			type = tooltip.css('position'),
			position = { left: 0, top: 0 },
			visible = tooltip[0].offsetWidth > 0,
			isScroll = event && event.type === 'scroll',
			win = $(window),
			doc = container[0].ownerDocument,
			mouse = this.mouse,
			pluginCalculations, offset, adjusted, newClass;

		// Check if absolute position was passed
		if($.isArray(target) && target.length === 2) {
			// Force left top and set position
			at = { x: LEFT, y: TOP };
			position = { left: target[0], top: target[1] };
		}

		// Check if mouse was the target
		else if(target === 'mouse') {
			// Force left top to allow flipping
			at = { x: LEFT, y: TOP };

			// Use the mouse origin that caused the show event, if distance hiding is enabled
			if((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {
				event =  cache.origin;
			}

			// Use cached event for resize/scroll events
			else if(!event || event && (event.type === 'resize' || event.type === 'scroll')) {
				event = cache.event;
			}

			// Otherwise, use the cached mouse coordinates if available
			else if(mouse && mouse.pageX) {
				event = mouse;
			}

			// Calculate body and container offset and take them into account below
			if(type !== 'static') { position = container.offset(); }
			if(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
				offset = $(document.body).offset();
			}

			// Use event coordinates for position
			position = {
				left: event.pageX - position.left + (offset && offset.left || 0),
				top: event.pageY - position.top + (offset && offset.top || 0)
			};

			// Scroll events are a pain, some browsers
			if(adjust.mouse && isScroll && mouse) {
				position.left -= (mouse.scrollX || 0) - win.scrollLeft();
				position.top -= (mouse.scrollY || 0) - win.scrollTop();
			}
		}

		// Target wasn't mouse or absolute...
		else {
			// Check if event targetting is being used
			if(target === 'event') {
				if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
					cache.target = $(event.target);
				}
				else if(!event.target) {
					cache.target = this.elements.target;
				}
			}
			else if(target !== 'event'){
				cache.target = $(target.jquery ? target : this.elements.target);
			}
			target = cache.target;

			// Parse the target into a jQuery object and make sure there's an element present
			target = $(target).eq(0);
			if(target.length === 0) { return this; }

			// Check if window or document is the target
			else if(target[0] === document || target[0] === window) {
				targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
				targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

				if(target[0] === window) {
					position = {
						top: (viewport || target).scrollTop(),
						left: (viewport || target).scrollLeft()
					};
				}
			}

			// Check if the target is an <AREA> element
			else if(PLUGINS.imagemap && target.is('area')) {
				pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
			}

			// Check if the target is an SVG element
			else if(PLUGINS.svg && target && target[0].ownerSVGElement) {
				pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
			}

			// Otherwise use regular jQuery methods
			else {
				targetWidth = target.outerWidth(FALSE);
				targetHeight = target.outerHeight(FALSE);
				position = target.offset();
			}

			// Parse returned plugin values into proper variables
			if(pluginCalculations) {
				targetWidth = pluginCalculations.width;
				targetHeight = pluginCalculations.height;
				offset = pluginCalculations.offset;
				position = pluginCalculations.position;
			}

			// Adjust position to take into account offset parents
			position = this.reposition.offset(target, position, container);

			// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
			if(BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 ||
				BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 ||
				!BROWSER.iOS && type === 'fixed'
			){
				position.left -= win.scrollLeft();
				position.top -= win.scrollTop();
			}

			// Adjust position relative to target
			if(!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {
				position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
				position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
			}
		}

		// Adjust position relative to tooltip
		position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
		position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

		// Use viewport adjustment plugin if enabled
		if(PLUGINS.viewport) {
			adjusted = position.adjusted = PLUGINS.viewport(
				this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
			);

			// Apply offsets supplied by positioning plugin (if used)
			if(offset && adjusted.left) { position.left += offset.left; }
			if(offset && adjusted.top) {  position.top += offset.top; }

			// Apply any new 'my' position
			if(adjusted.my) { this.position.my = adjusted.my; }
		}

		// Viewport adjustment is disabled, set values to zero
		else { position.adjusted = { left: 0, top: 0 }; }

		// Set tooltip position class if it's changed
		if(cache.posClass !== (newClass = this._createPosClass(this.position.my))) {
			cache.posClass = newClass;
			tooltip.removeClass(cache.posClass).addClass(newClass);
		}

		// tooltipmove event
		if(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
		delete position.adjusted;

		// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
		if(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
			tooltip.css(position);
		}

		// Use custom function if provided
		else if($.isFunction(posOptions.effect)) {
			posOptions.effect.call(tooltip, this, $.extend({}, position));
			tooltip.queue(function(next) {
				// Reset attributes to avoid cross-browser rendering bugs
				$(this).css({ opacity: '', height: '' });
				if(BROWSER.ie) { this.style.removeAttribute('filter'); }

				next();
			});
		}

		// Set positioning flag
		this.positioning = FALSE;

		return this;
	};

	// Custom (more correct for qTip!) offset calculator
	PROTOTYPE.reposition.offset = function(elem, pos, container) {
		if(!container[0]) { return pos; }

		var ownerDocument = $(elem[0].ownerDocument),
			quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
			parent = container[0],
			scrolled, position, parentOffset, overflow;

		function scroll(e, i) {
			pos.left += i * e.scrollLeft();
			pos.top += i * e.scrollTop();
		}

		// Compensate for non-static containers offset
		do {
			if((position = $.css(parent, 'position')) !== 'static') {
				if(position === 'fixed') {
					parentOffset = parent.getBoundingClientRect();
					scroll(ownerDocument, -1);
				}
				else {
					parentOffset = $(parent).position();
					parentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;
					parentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;
				}

				pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
				pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

				// If this is the first parent element with an overflow of "scroll" or "auto", store it
				if(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
			}
		}
		while(parent = parent.offsetParent);

		// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
		if(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
			scroll(scrolled, 1);
		}

		return pos;
	};

	// Corner class
	var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
		corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
		this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
		this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
		this.forceY = !!forceY;

		var f = corner.charAt(0);
		this.precedance = f === 't' || f === 'b' ? Y : X;
	}).prototype;

	C.invert = function(z, center) {
		this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
	};

	C.string = function(join) {
		var x = this.x, y = this.y;

		var result = x !== y ?
			x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? 
				[y,x] : 
				[x,y] :
			[x];

		return join !== false ? result.join(' ') : result;
	};

	C.abbrev = function() {
		var result = this.string(false);
		return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
	};

	C.clone = function() {
		return new CORNER( this.string(), this.forceY );
	};

	;
	PROTOTYPE.toggle = function(state, event) {
		var cache = this.cache,
			options = this.options,
			tooltip = this.tooltip;

		// Try to prevent flickering when tooltip overlaps show element
		if(event) {
			if((/over|enter/).test(event.type) && cache.event && (/out|leave/).test(cache.event.type) &&
				options.show.target.add(event.target).length === options.show.target.length &&
				tooltip.has(event.relatedTarget).length) {
				return this;
			}

			// Cache event
			cache.event = $.event.fix(event);
		}

		// If we're currently waiting and we've just hidden... stop it
		this.waiting && !state && (this.hiddenDuringWait = TRUE);

		// Render the tooltip if showing and it isn't already
		if(!this.rendered) { return state ? this.render(1) : this; }
		else if(this.destroyed || this.disabled) { return this; }

		var type = state ? 'show' : 'hide',
			opts = this.options[type],
			posOptions = this.options.position,
			contentOptions = this.options.content,
			width = this.tooltip.css('width'),
			visible = this.tooltip.is(':visible'),
			animate = state || opts.target.length === 1,
			sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
			identicalState, allow, after;

		// Detect state if valid one isn't provided
		if((typeof state).search('boolean|number')) { state = !visible; }

		// Check if the tooltip is in an identical state to the new would-be state
		identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

		// Fire tooltip(show/hide) event and check if destroyed
		allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

		// Check to make sure the tooltip wasn't destroyed in the callback
		if(this.destroyed) { return this; }

		// If the user didn't stop the method prematurely and we're showing the tooltip, focus it
		if(allow !== FALSE && state) { this.focus(event); }

		// If the state hasn't changed or the user stopped it, return early
		if(!allow || identicalState) { return this; }

		// Set ARIA hidden attribute
		$.attr(tooltip[0], 'aria-hidden', !!!state);

		// Execute state specific properties
		if(state) {
			// Store show origin coordinates
			this.mouse && (cache.origin = $.event.fix(this.mouse));

			// Update tooltip content & title if it's a dynamic function
			if($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
			if($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

			// Cache mousemove events for positioning purposes (if not already tracking)
			if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
				$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);
				trackingBound = TRUE;
			}

			// Update the tooltip position (set width first to prevent viewport/max-width issues)
			if(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
			this.reposition(event, arguments[2]);
			if(!width) { tooltip.css('width', ''); }

			// Hide other tooltips if tooltip is solo
			if(!!opts.solo) {
				(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
					.not(tooltip).not(opts.target).qtip('hide', new $.Event('tooltipsolo'));
			}
		}
		else {
			// Clear show timer if we're hiding
			clearTimeout(this.timers.show);

			// Remove cached origin on hide
			delete cache.origin;

			// Remove mouse tracking event if not needed (all tracking qTips are hidden)
			if(trackingBound && !$(SELECTOR+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
				$(document).unbind('mousemove.'+NAMESPACE);
				trackingBound = FALSE;
			}

			// Blur the tooltip
			this.blur(event);
		}

		// Define post-animation, state specific properties
		after = $.proxy(function() {
			if(state) {
				// Prevent antialias from disappearing in IE by removing filter
				if(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

				// Remove overflow setting to prevent tip bugs
				tooltip.css('overflow', '');

				// Autofocus elements if enabled
				if('string' === typeof opts.autofocus) {
					$(this.options.show.autofocus, tooltip).focus();
				}

				// If set, hide tooltip when inactive for delay period
				this.options.show.target.trigger('qtip-'+this.id+'-inactive');
			}
			else {
				// Reset CSS states
				tooltip.css({
					display: '',
					visibility: '',
					opacity: '',
					left: '',
					top: ''
				});
			}

			// tooltipvisible/tooltiphidden events
			this._trigger(state ? 'visible' : 'hidden');
		}, this);

		// If no effect type is supplied, use a simple toggle
		if(opts.effect === FALSE || animate === FALSE) {
			tooltip[ type ]();
			after();
		}

		// Use custom function if provided
		else if($.isFunction(opts.effect)) {
			tooltip.stop(1, 1);
			opts.effect.call(tooltip, this);
			tooltip.queue('fx', function(n) {
				after(); n();
			});
		}

		// Use basic fade function by default
		else { tooltip.fadeTo(90, state ? 1 : 0, after); }

		// If inactive hide method is set, active it
		if(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }

		return this;
	};

	PROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };

	PROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };
	;PROTOTYPE.focus = function(event) {
		if(!this.rendered || this.destroyed) { return this; }

		var qtips = $(SELECTOR),
			tooltip = this.tooltip,
			curIndex = parseInt(tooltip[0].style.zIndex, 10),
			newIndex = QTIP.zindex + qtips.length;

		// Only update the z-index if it has changed and tooltip is not already focused
		if(!tooltip.hasClass(CLASS_FOCUS)) {
			// tooltipfocus event
			if(this._trigger('focus', [newIndex], event)) {
				// Only update z-index's if they've changed
				if(curIndex !== newIndex) {
					// Reduce our z-index's and keep them properly ordered
					qtips.each(function() {
						if(this.style.zIndex > curIndex) {
							this.style.zIndex = this.style.zIndex - 1;
						}
					});

					// Fire blur event for focused tooltip
					qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
				}

				// Set the new z-index
				tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
			}
		}

		return this;
	};

	PROTOTYPE.blur = function(event) {
		if(!this.rendered || this.destroyed) { return this; }

		// Set focused status to FALSE
		this.tooltip.removeClass(CLASS_FOCUS);

		// tooltipblur event
		this._trigger('blur', [ this.tooltip.css('zIndex') ], event);

		return this;
	};
	;PROTOTYPE.disable = function(state) {
		if(this.destroyed) { return this; }

		// If 'toggle' is passed, toggle the current state
		if(state === 'toggle') {
			state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
		}

		// Disable if no state passed
		else if('boolean' !== typeof state) {
			state = TRUE;
		}

		if(this.rendered) {
			this.tooltip.toggleClass(CLASS_DISABLED, state)
				.attr('aria-disabled', state);
		}

		this.disabled = !!state;

		return this;
	};

	PROTOTYPE.enable = function() { return this.disable(FALSE); };
	;PROTOTYPE._createButton = function()
	{
		var self = this,
			elements = this.elements,
			tooltip = elements.tooltip,
			button = this.options.content.button,
			isString = typeof button === 'string',
			close = isString ? button : 'Close tooltip';

		if(elements.button) { elements.button.remove(); }

		// Use custom button if one was supplied by user, else use default
		if(button.jquery) {
			elements.button = button;
		}
		else {
			elements.button = $('<a />', {
				'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),
				'title': close,
				'aria-label': close
			})
			.prepend(
				$('<span />', {
					'class': 'ui-icon ui-icon-close',
					'html': '&times;'
				})
			);
		}

		// Create button and setup attributes
		elements.button.appendTo(elements.titlebar || tooltip)
			.attr('role', 'button')
			.click(function(event) {
				if(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
				return FALSE;
			});
	};

	PROTOTYPE._updateButton = function(button)
	{
		// Make sure tooltip is rendered and if not, return
		if(!this.rendered) { return FALSE; }

		var elem = this.elements.button;
		if(button) { this._createButton(); }
		else { elem.remove(); }
	};
	;// Widget class creator
	function createWidgetClass(cls) {
		return WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');
	}

	// Widget class setter method
	PROTOTYPE._setWidget = function()
	{
		var on = this.options.style.widget,
			elements = this.elements,
			tooltip = elements.tooltip,
			disabled = tooltip.hasClass(CLASS_DISABLED);

		tooltip.removeClass(CLASS_DISABLED);
		CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
		tooltip.toggleClass(CLASS_DISABLED, disabled);

		tooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);

		if(elements.content) {
			elements.content.toggleClass( createWidgetClass('content'), on);
		}
		if(elements.titlebar) {
			elements.titlebar.toggleClass( createWidgetClass('header'), on);
		}
		if(elements.button) {
			elements.button.toggleClass(NAMESPACE+'-icon', !on);
		}
	};
	;function delay(callback, duration) {
		// If tooltip has displayed, start hide timer
		if(duration > 0) {
			return setTimeout(
				$.proxy(callback, this), duration
			);
		}
		else{ callback.call(this); }
	}

	function showMethod(event) {
		if(this.tooltip.hasClass(CLASS_DISABLED)) { return; }

		// Clear hide timers
		clearTimeout(this.timers.show);
		clearTimeout(this.timers.hide);

		// Start show timer
		this.timers.show = delay.call(this,
			function() { this.toggle(TRUE, event); },
			this.options.show.delay
		);
	}

	function hideMethod(event) {
		if(this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) { return; }

		// Check if new target was actually the tooltip element
		var relatedTarget = $(event.relatedTarget),
			ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
			ontoTarget = relatedTarget[0] === this.options.show.target[0];

		// Clear timers and stop animation queue
		clearTimeout(this.timers.show);
		clearTimeout(this.timers.hide);

		// Prevent hiding if tooltip is fixed and event target is the tooltip.
		// Or if mouse positioning is enabled and cursor momentarily overlaps
		if(this !== relatedTarget[0] &&
			(this.options.position.target === 'mouse' && ontoTooltip) ||
			this.options.hide.fixed && (
				(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
			)
		{
			/* eslint-disable no-empty */
			try {
				event.preventDefault();
				event.stopImmediatePropagation();
			} catch(e) {}
			/* eslint-enable no-empty */

			return;
		}

		// If tooltip has displayed, start hide timer
		this.timers.hide = delay.call(this,
			function() { this.toggle(FALSE, event); },
			this.options.hide.delay,
			this
		);
	}

	function inactiveMethod(event) {
		if(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return; }

		// Clear timer
		clearTimeout(this.timers.inactive);

		this.timers.inactive = delay.call(this,
			function(){ this.hide(event); },
			this.options.hide.inactive
		);
	}

	function repositionMethod(event) {
		if(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
	}

	// Store mouse coordinates
	PROTOTYPE._storeMouse = function(event) {
		(this.mouse = $.event.fix(event)).type = 'mousemove';
		return this;
	};

	// Bind events
	PROTOTYPE._bind = function(targets, events, method, suffix, context) {
		if(!targets || !method || !events.length) { return; }
		var ns = '.' + this._id + (suffix ? '-'+suffix : '');
		$(targets).bind(
			(events.split ? events : events.join(ns + ' ')) + ns,
			$.proxy(method, context || this)
		);
		return this;
	};
	PROTOTYPE._unbind = function(targets, suffix) {
		targets && $(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));
		return this;
	};

	// Global delegation helper
	function delegate(selector, events, method) {
		$(document.body).delegate(selector,
			(events.split ? events : events.join('.'+NAMESPACE + ' ')) + '.'+NAMESPACE,
			function() {
				var api = QTIP.api[ $.attr(this, ATTR_ID) ];
				api && !api.disabled && method.apply(api, arguments);
			}
		);
	}
	// Event trigger
	PROTOTYPE._trigger = function(type, args, event) {
		var callback = new $.Event('tooltip'+type);
		callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;

		this.triggering = type;
		this.tooltip.trigger(callback, [this].concat(args || []));
		this.triggering = FALSE;

		return !callback.isDefaultPrevented();
	};

	PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {
		// Get tasrgets that lye within both
		var similarTargets = showTargets.filter( hideTargets ).add( hideTargets.filter(showTargets) ),
			toggleEvents = [];

		// If hide and show targets are the same...
		if(similarTargets.length) {

			// Filter identical show/hide events
			$.each(hideEvents, function(i, type) {
				var showIndex = $.inArray(type, showEvents);

				// Both events are identical, remove from both hide and show events
				// and append to toggleEvents
				showIndex > -1 && toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );
			});

			// Toggle events are special case of identical show/hide events, which happen in sequence
			if(toggleEvents.length) {
				// Bind toggle events to the similar targets
				this._bind(similarTargets, toggleEvents, function(event) {
					var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
					(state ? hideCallback : showCallback).call(this, event);
				});

				// Remove the similar targets from the regular show/hide bindings
				showTargets = showTargets.not(similarTargets);
				hideTargets = hideTargets.not(similarTargets);
			}
		}

		// Apply show/hide/toggle events
		this._bind(showTargets, showEvents, showCallback);
		this._bind(hideTargets, hideEvents, hideCallback);
	};

	PROTOTYPE._assignInitialEvents = function(event) {
		var options = this.options,
			showTarget = options.show.target,
			hideTarget = options.hide.target,
			showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
			hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

		// Catch remove/removeqtip events on target element to destroy redundant tooltips
		this._bind(this.elements.target, ['remove', 'removeqtip'], function() {
			this.destroy(true);
		}, 'destroy');

		/*
		 * Make sure hoverIntent functions properly by using mouseleave as a hide event if
		 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
		 */
		if(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
			hideEvents.push('mouseleave');
		}

		/*
		 * Also make sure initial mouse targetting works correctly by caching mousemove coords
		 * on show targets before the tooltip has rendered. Also set onTarget when triggered to
		 * keep mouse tracking working.
		 */
		this._bind(showTarget, 'mousemove', function(moveEvent) {
			this._storeMouse(moveEvent);
			this.cache.onTarget = TRUE;
		});

		// Define hoverIntent function
		function hoverIntent(hoverEvent) {
			// Only continue if tooltip isn't disabled
			if(this.disabled || this.destroyed) { return FALSE; }

			// Cache the event data
			this.cache.event = hoverEvent && $.event.fix(hoverEvent);
			this.cache.target = hoverEvent && $(hoverEvent.target);

			// Start the event sequence
			clearTimeout(this.timers.show);
			this.timers.show = delay.call(this,
				function() { this.render(typeof hoverEvent === 'object' || options.show.ready); },
				options.prerender ? 0 : options.show.delay
			);
		}

		// Filter and bind events
		this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
			if(!this.timers) { return FALSE; }
			clearTimeout(this.timers.show);
		});

		// Prerendering is enabled, create tooltip now
		if(options.show.ready || options.prerender) { hoverIntent.call(this, event); }
	};

	// Event assignment method
	PROTOTYPE._assignEvents = function() {
		var self = this,
			options = this.options,
			posOptions = options.position,

			tooltip = this.tooltip,
			showTarget = options.show.target,
			hideTarget = options.hide.target,
			containerTarget = posOptions.container,
			viewportTarget = posOptions.viewport,
			documentTarget = $(document),
			windowTarget = $(window),

			showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
			hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


		// Assign passed event callbacks
		$.each(options.events, function(name, callback) {
			self._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);
		});

		// Hide tooltips when leaving current window/frame (but not select/option elements)
		if(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
			this._bind(documentTarget, ['mouseout', 'blur'], function(event) {
				if(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
					this.hide(event);
				}
			});
		}

		// Enable hide.fixed by adding appropriate class
		if(options.hide.fixed) {
			hideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );
		}

		/*
		 * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
		 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
		 */
		else if(/mouse(over|enter)/i.test(options.show.event)) {
			this._bind(hideTarget, 'mouseleave', function() {
				clearTimeout(this.timers.show);
			});
		}

		// Hide tooltip on document mousedown if unfocus events are enabled
		if(('' + options.hide.event).indexOf('unfocus') > -1) {
			this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {
				var elem = $(event.target),
					enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
					isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

				if(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
					!this.target.has(elem[0]).length && enabled
				) {
					this.hide(event);
				}
			});
		}

		// Check if the tooltip hides when inactive
		if('number' === typeof options.hide.inactive) {
			// Bind inactive method to show target(s) as a custom event
			this._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod, 'inactive');

			// Define events which reset the 'inactive' event handler
			this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);
		}

		// Filter and bind events
		this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

		// Mouse movement bindings
		this._bind(showTarget.add(tooltip), 'mousemove', function(event) {
			// Check if the tooltip hides when mouse is moved a certain distance
			if('number' === typeof options.hide.distance) {
				var origin = this.cache.origin || {},
					limit = this.options.hide.distance,
					abs = Math.abs;

				// Check if the movement has gone beyond the limit, and hide it if so
				if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
					this.hide(event);
				}
			}

			// Cache mousemove coords on show targets
			this._storeMouse(event);
		});

		// Mouse positioning events
		if(posOptions.target === 'mouse') {
			// If mouse adjustment is on...
			if(posOptions.adjust.mouse) {
				// Apply a mouseleave event so we don't get problems with overlapping
				if(options.hide.event) {
					// Track if we're on the target or not
					this._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {
						if(!this.cache) {return FALSE; }
						this.cache.onTarget = event.type === 'mouseenter';
					});
				}

				// Update tooltip position on mousemove
				this._bind(documentTarget, 'mousemove', function(event) {
					// Update the tooltip position only if the tooltip is visible and adjustment is enabled
					if(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
						this.reposition(event);
					}
				});
			}
		}

		// Adjust positions of the tooltip on window resize if enabled
		if(posOptions.adjust.resize || viewportTarget.length) {
			this._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );
		}

		// Adjust tooltip position on scroll of the window or viewport element if present
		if(posOptions.adjust.scroll) {
			this._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );
		}
	};

	// Un-assignment method
	PROTOTYPE._unassignEvents = function() {
		var options = this.options,
			showTargets = options.show.target,
			hideTargets = options.hide.target,
			targets = $.grep([
				this.elements.target[0],
				this.rendered && this.tooltip[0],
				options.position.container[0],
				options.position.viewport[0],
				options.position.container.closest('html')[0], // unfocus
				window,
				document
			], function(i) {
				return typeof i === 'object';
			});

		// Add show and hide targets if they're valid
		if(showTargets && showTargets.toArray) {
			targets = targets.concat(showTargets.toArray());
		}
		if(hideTargets && hideTargets.toArray) {
			targets = targets.concat(hideTargets.toArray());
		}

		// Unbind the events
		this._unbind(targets)
			._unbind(targets, 'destroy')
			._unbind(targets, 'inactive');
	};

	// Apply common event handlers using delegate (avoids excessive .bind calls!)
	$(function() {
		delegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {
			var state = event.type === 'mouseenter',
				tooltip = $(event.currentTarget),
				target = $(event.relatedTarget || event.target),
				options = this.options;

			// On mouseenter...
			if(state) {
				// Focus the tooltip on mouseenter (z-index stacking)
				this.focus(event);

				// Clear hide timer on tooltip hover to prevent it from closing
				tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
			}

			// On mouseleave...
			else {
				// When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)
				if(options.position.target === 'mouse' && options.position.adjust.mouse &&
					options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {
					this.hide(event);
				}
			}

			// Add hover class
			tooltip.toggleClass(CLASS_HOVER, state);
		});

		// Define events which reset the 'inactive' event handler
		delegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);
	});
	;// Initialization method
	function init(elem, id, opts) {
		var obj, posOptions, attr, config, title,

		// Setup element references
		docBody = $(document.body),

		// Use document body instead of document element if needed
		newTarget = elem[0] === document ? docBody : elem,

		// Grab metadata from element if plugin is present
		metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,

		// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
		metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

		// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
		html5 = elem.data(opts.metadata.name || 'qtipopts');

		// If we don't get an object returned attempt to parse it manualyl without parseJSON
		/* eslint-disable no-empty */
		try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; }
		catch(e) {}
		/* eslint-enable no-empty */

		// Merge in and sanitize metadata
		config = $.extend(TRUE, {}, QTIP.defaults, opts,
			typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
			sanitizeOptions(metadata5 || metadata));

		// Re-grab our positioning options now we've merged our metadata and set id to passed value
		posOptions = config.position;
		config.id = id;

		// Setup missing content if none is detected
		if('boolean' === typeof config.content.text) {
			attr = elem.attr(config.content.attr);

			// Grab from supplied attribute if available
			if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

			// No valid content was found, abort render
			else { return FALSE; }
		}

		// Setup target options
		if(!posOptions.container.length) { posOptions.container = docBody; }
		if(posOptions.target === FALSE) { posOptions.target = newTarget; }
		if(config.show.target === FALSE) { config.show.target = newTarget; }
		if(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
		if(config.hide.target === FALSE) { config.hide.target = newTarget; }
		if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

		// Ensure we only use a single container
		posOptions.container = posOptions.container.eq(0);

		// Convert position corner values into x and y strings
		posOptions.at = new CORNER(posOptions.at, TRUE);
		posOptions.my = new CORNER(posOptions.my);

		// Destroy previous tooltip if overwrite is enabled, or skip element if not
		if(elem.data(NAMESPACE)) {
			if(config.overwrite) {
				elem.qtip('destroy', true);
			}
			else if(config.overwrite === FALSE) {
				return FALSE;
			}
		}

		// Add has-qtip attribute
		elem.attr(ATTR_HAS, id);

		// Remove title attribute and store it if present
		if(config.suppress && (title = elem.attr('title'))) {
			// Final attr call fixes event delegatiom and IE default tooltip showing problem
			elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
		}

		// Initialize the tooltip and add API reference
		obj = new QTip(elem, config, id, !!attr);
		elem.data(NAMESPACE, obj);

		return obj;
	}

	// jQuery $.fn extension method
	QTIP = $.fn.qtip = function(options, notation, newValue)
	{
		var command = ('' + options).toLowerCase(), // Parse command
			returned = NULL,
			args = $.makeArray(arguments).slice(1),
			event = args[args.length - 1],
			opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

		// Check for API request
		if(!arguments.length && opts || command === 'api') {
			return opts;
		}

		// Execute API command if present
		else if('string' === typeof options) {
			this.each(function() {
				var api = $.data(this, NAMESPACE);
				if(!api) { return TRUE; }

				// Cache the event if possible
				if(event && event.timeStamp) { api.cache.event = event; }

				// Check for specific API commands
				if(notation && (command === 'option' || command === 'options')) {
					if(newValue !== undefined || $.isPlainObject(notation)) {
						api.set(notation, newValue);
					}
					else {
						returned = api.get(notation);
						return FALSE;
					}
				}

				// Execute API command
				else if(api[command]) {
					api[command].apply(api, args);
				}
			});

			return returned !== NULL ? returned : this;
		}

		// No API commands. validate provided options and setup qTips
		else if('object' === typeof options || !arguments.length) {
			// Sanitize options first
			opts = sanitizeOptions($.extend(TRUE, {}, options));

			return this.each(function(i) {
				var api, id;

				// Find next available ID, or use custom ID if provided
				id = $.isArray(opts.id) ? opts.id[i] : opts.id;
				id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

				// Initialize the qTip and re-grab newly sanitized options
				api = init($(this), id, opts);
				if(api === FALSE) { return TRUE; }
				else { QTIP.api[id] = api; }

				// Initialize plugins
				$.each(PLUGINS, function() {
					if(this.initialize === 'initialize') { this(api); }
				});

				// Assign initial pre-render events
				api._assignInitialEvents(event);
			});
		}
	};

	// Expose class
	$.qtip = QTip;

	// Populated in render method
	QTIP.api = {};
	;$.each({
		/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
		attr: function(attr, val) {
			if(this.length) {
				var self = this[0],
					title = 'title',
					api = $.data(self, 'qtip');

				if(attr === title && api && api.options && 'object' === typeof api && 'object' === typeof api.options && api.options.suppress) {
					if(arguments.length < 2) {
						return $.attr(self, oldtitle);
					}

					// If qTip is rendered and title was originally used as content, update it
					if(api && api.options.content.attr === title && api.cache.attr) {
						api.set('content.text', val);
					}

					// Use the regular attr method to set, then cache the result
					return this.attr(oldtitle, val);
				}
			}

			return $.fn['attr'+replaceSuffix].apply(this, arguments);
		},

		/* Allow clone to correctly retrieve cached title attributes */
		clone: function(keepData) {
			// Clone our element using the real clone method
			var elems = $.fn['clone'+replaceSuffix].apply(this, arguments);

			// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
			if(!keepData) {
				elems.filter('['+oldtitle+']').attr('title', function() {
					return $.attr(this, oldtitle);
				})
				.removeAttr(oldtitle);
			}

			return elems;
		}
	}, function(name, func) {
		if(!func || $.fn[name+replaceSuffix]) { return TRUE; }

		var old = $.fn[name+replaceSuffix] = $.fn[name];
		$.fn[name] = function() {
			return func.apply(this, arguments) || old.apply(this, arguments);
		};
	});

	/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
	 * This snippet is taken directly from jQuery UI source code found here:
	 *     http://code.jquery.com/ui/jquery-ui-git.js
	 */
	if(!$.ui) {
		$['cleanData'+replaceSuffix] = $.cleanData;
		$.cleanData = function( elems ) {
			for(var i = 0, elem; (elem = $( elems[i] )).length; i++) {
				if(elem.attr(ATTR_HAS)) {
					/* eslint-disable no-empty */
					try { elem.triggerHandler('removeqtip'); }
					catch( e ) {}
					/* eslint-enable no-empty */
				}
			}
			$['cleanData'+replaceSuffix].apply(this, arguments);
		};
	}
	;// qTip version
	QTIP.version = '3.0.3';

	// Base ID for all qTips
	QTIP.nextid = 0;

	// Inactive events array
	QTIP.inactiveEvents = INACTIVE_EVENTS;

	// Base z-index for all qTips
	QTIP.zindex = 15000;

	// Define configuration defaults
	QTIP.defaults = {
		prerender: FALSE,
		id: FALSE,
		overwrite: TRUE,
		suppress: TRUE,
		content: {
			text: TRUE,
			attr: 'title',
			title: FALSE,
			button: FALSE
		},
		position: {
			my: 'top left',
			at: 'bottom right',
			target: FALSE,
			container: FALSE,
			viewport: FALSE,
			adjust: {
				x: 0, y: 0,
				mouse: TRUE,
				scroll: TRUE,
				resize: TRUE,
				method: 'flipinvert flipinvert'
			},
			effect: function(api, pos) {
				$(this).animate(pos, {
					duration: 200,
					queue: FALSE
				});
			}
		},
		show: {
			target: FALSE,
			event: 'mouseenter',
			effect: TRUE,
			delay: 90,
			solo: FALSE,
			ready: FALSE,
			autofocus: FALSE
		},
		hide: {
			target: FALSE,
			event: 'mouseleave',
			effect: TRUE,
			delay: 0,
			fixed: FALSE,
			inactive: FALSE,
			leave: 'window',
			distance: FALSE
		},
		style: {
			classes: '',
			widget: FALSE,
			width: FALSE,
			height: FALSE,
			def: TRUE
		},
		events: {
			render: NULL,
			move: NULL,
			show: NULL,
			hide: NULL,
			toggle: NULL,
			visible: NULL,
			hidden: NULL,
			focus: NULL,
			blur: NULL
		}
	};
	;var TIP,
	createVML,
	SCALE,
	PIXEL_RATIO,
	BACKING_STORE_RATIO,

	// Common CSS strings
	MARGIN = 'margin',
	BORDER = 'border',
	COLOR = 'color',
	BG_COLOR = 'background-color',
	TRANSPARENT = 'transparent',
	IMPORTANT = ' !important',

	// Check if the browser supports <canvas/> elements
	HASCANVAS = !!document.createElement('canvas').getContext,

	// Invalid colour values used in parseColours()
	INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;

	// Camel-case method, taken from jQuery source
	// http://code.jquery.com/jquery-1.8.0.js
	function camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

	/*
	 * Modified from Modernizr's testPropsAll()
	 * http://modernizr.com/downloads/modernizr-latest.js
	 */
	var cssProps = {}, cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
	function vendorCss(elem, prop) {
		var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
			props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),
			cur, val, i = 0;

		// If the property has already been mapped...
		if(cssProps[prop]) { return elem.css(cssProps[prop]); }

		while(cur = props[i++]) {
			if((val = elem.css(cur)) !== undefined) {
				cssProps[prop] = cur;
				return val;
			}
		}
	}

	// Parse a given elements CSS property into an int
	function intCss(elem, prop) {
		return Math.ceil(parseFloat(vendorCss(elem, prop)));
	}


	// VML creation (for IE only)
	if(!HASCANVAS) {
		createVML = function(tag, props, style) {
			return '<qtipvml:'+tag+' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" '+(props||'')+
				' style="behavior: url(#default#VML); '+(style||'')+ '" />';
		};
	}

	// Canvas only definitions
	else {
		PIXEL_RATIO = window.devicePixelRatio || 1;
		BACKING_STORE_RATIO = (function() {
			var context = document.createElement('canvas').getContext('2d');
			return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||
					context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
		})();
		SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
	}


	function Tip(qtip, options) {
		this._ns = 'tip';
		this.options = options;
		this.offset = options.offset;
		this.size = [ options.width, options.height ];

		// Initialize
		this.qtip = qtip;
		this.init(qtip);
	}

	$.extend(Tip.prototype, {
		init: function(qtip) {
			var context, tip;

			// Create tip element and prepend to the tooltip
			tip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);

			// Create tip drawing element(s)
			if(HASCANVAS) {
				// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
				context = $('<canvas />').appendTo(this.element)[0].getContext('2d');

				// Setup constant parameters
				context.lineJoin = 'miter';
				context.miterLimit = 100000;
				context.save();
			}
			else {
				context = createVML('shape', 'coordorigin="0,0"', 'position:absolute;');
				this.element.html(context + context);

				// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML
				qtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);
			}

			// Bind update events
			qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);

			// Create it
			this.create();
		},

		_swapDimensions: function() {
			this.size[0] = this.options.height;
			this.size[1] = this.options.width;
		},
		_resetDimensions: function() {
			this.size[0] = this.options.width;
			this.size[1] = this.options.height;
		},

		_useTitle: function(corner) {
			var titlebar = this.qtip.elements.titlebar;
			return titlebar && (
				corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE)
			);
		},

		_parseCorner: function(corner) {
			var my = this.qtip.options.position.my;

			// Detect corner and mimic properties
			if(corner === FALSE || my === FALSE) {
				corner = FALSE;
			}
			else if(corner === TRUE) {
				corner = new CORNER( my.string() );
			}
			else if(!corner.string) {
				corner = new CORNER(corner);
				corner.fixed = TRUE;
			}

			return corner;
		},

		_parseWidth: function(corner, side, use) {
			var elements = this.qtip.elements,
				prop = BORDER + camel(side) + 'Width';

			return (use ? intCss(use, prop) : 
				intCss(elements.content, prop) ||
				intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
				intCss(elements.tooltip, prop)
			) || 0;
		},

		_parseRadius: function(corner) {
			var elements = this.qtip.elements,
				prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';

			return BROWSER.ie < 9 ? 0 :
				intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
				intCss(elements.tooltip, prop) || 0;
		},

		_invalidColour: function(elem, prop, compare) {
			var val = elem.css(prop);
			return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;
		},

		_parseColours: function(corner) {
			var elements = this.qtip.elements,
				tip = this.element.css('cssText', ''),
				borderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),
				colorElem = this._useTitle(corner) && elements.titlebar || elements.content,
				css = this._invalidColour, color = [];

			// Attempt to detect the background colour from various elements, left-to-right precedance
			color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) ||
				css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);

			// Attempt to detect the correct border side colour from various elements, left-to-right precedance
			color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) ||
				css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);

			// Reset background and border colours
			$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');

			return color;
		},

		_calculateSize: function(corner) {
			var y = corner.precedance === Y,
				width = this.options.width,
				height = this.options.height,
				isCenter = corner.abbrev() === 'c',
				base = (y ? width: height) * (isCenter ? 0.5 : 1),
				pow = Math.pow,
				round = Math.round,
				bigHyp, ratio, result,

			smallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),
			hyp = [
				this.border / base * smallHyp,
				this.border / height * smallHyp
			];

			hyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );
			hyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );

			bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
			ratio = bigHyp / smallHyp;

			result = [ round(ratio * width), round(ratio * height) ];
			return y ? result : result.reverse();
		},

		// Tip coordinates calculator
		_calculateTip: function(corner, size, scale) {
			scale = scale || 1;
			size = size || this.size;

			var width = size[0] * scale,
				height = size[1] * scale,
				width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

			// Define tip coordinates in terms of height and width values
			tips = {
				br:	[0,0,		width,height,	width,0],
				bl:	[0,0,		width,0,		0,height],
				tr:	[0,height,	width,0,		width,height],
				tl:	[0,0,		0,height,		width,height],
				tc:	[0,height,	width2,0,		width,height],
				bc:	[0,0,		width,0,		width2,height],
				rc:	[0,0,		width,height2,	0,height],
				lc:	[width,0,	width,height,	0,height2]
			};

			// Set common side shapes
			tips.lt = tips.br; tips.rt = tips.bl;
			tips.lb = tips.tr; tips.rb = tips.tl;

			return tips[ corner.abbrev() ];
		},

		// Tip coordinates drawer (canvas)
		_drawCoords: function(context, coords) {
			context.beginPath();
			context.moveTo(coords[0], coords[1]);
			context.lineTo(coords[2], coords[3]);
			context.lineTo(coords[4], coords[5]);
			context.closePath();
		},

		create: function() {
			// Determine tip corner
			var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);

			// If we have a tip corner...
			this.enabled = !!this.corner && this.corner.abbrev() !== 'c';
			if(this.enabled) {
				// Cache it
				this.qtip.cache.corner = c.clone();

				// Create it
				this.update();
			}

			// Toggle tip element
			this.element.toggle(this.enabled);

			return this.corner;
		},

		update: function(corner, position) {
			if(!this.enabled) { return this; }

			var elements = this.qtip.elements,
				tip = this.element,
				inner = tip.children(),
				options = this.options,
				curSize = this.size,
				mimic = options.mimic,
				round = Math.round,
				color, precedance, context,
				coords, bigCoords, translate, newSize, border;

			// Re-determine tip if not already set
			if(!corner) { corner = this.qtip.cache.corner || this.corner; }

			// Use corner property if we detect an invalid mimic value
			if(mimic === FALSE) { mimic = corner; }

			// Otherwise inherit mimic properties from the corner object as necessary
			else {
				mimic = new CORNER(mimic);
				mimic.precedance = corner.precedance;

				if(mimic.x === 'inherit') { mimic.x = corner.x; }
				else if(mimic.y === 'inherit') { mimic.y = corner.y; }
				else if(mimic.x === mimic.y) {
					mimic[ corner.precedance ] = corner[ corner.precedance ];
				}
			}
			precedance = mimic.precedance;

			// Ensure the tip width.height are relative to the tip position
			if(corner.precedance === X) { this._swapDimensions(); }
			else { this._resetDimensions(); }

			// Update our colours
			color = this.color = this._parseColours(corner);

			// Detect border width, taking into account colours
			if(color[1] !== TRANSPARENT) {
				// Grab border width
				border = this.border = this._parseWidth(corner, corner[corner.precedance]);

				// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)
				if(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }

				// Set border width (use detected border width if options.border is true)
				this.border = border = options.border !== TRUE ? options.border : border;
			}

			// Border colour was invalid, set border to zero
			else { this.border = border = 0; }

			// Determine tip size
			newSize = this.size = this._calculateSize(corner);
			tip.css({
				width: newSize[0],
				height: newSize[1],
				lineHeight: newSize[1]+'px'
			});

			// Calculate tip translation
			if(corner.precedance === Y) {
				translate = [
					round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),
					round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)
				];
			}
			else {
				translate = [
					round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),
					round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)
				];
			}

			// Canvas drawing implementation
			if(HASCANVAS) {
				// Grab canvas context and clear/save it
				context = inner[0].getContext('2d');
				context.restore(); context.save();
				context.clearRect(0,0,6000,6000);

				// Calculate coordinates
				coords = this._calculateTip(mimic, curSize, SCALE);
				bigCoords = this._calculateTip(mimic, this.size, SCALE);

				// Set the canvas size using calculated size
				inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
				inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);

				// Draw the outer-stroke tip
				this._drawCoords(context, bigCoords);
				context.fillStyle = color[1];
				context.fill();

				// Draw the actual tip
				context.translate(translate[0] * SCALE, translate[1] * SCALE);
				this._drawCoords(context, coords);
				context.fillStyle = color[0];
				context.fill();
			}

			// VML (IE Proprietary implementation)
			else {
				// Calculate coordinates
				coords = this._calculateTip(mimic);

				// Setup coordinates string
				coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +
					',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';

				// Setup VML-specific offset for pixel-perfection
				translate[2] = border && /^(r|b)/i.test(corner.string()) ?
					BROWSER.ie === 8 ? 2 : 1 : 0;

				// Set initial CSS
				inner.css({
					coordsize: newSize[0]+border + ' ' + newSize[1]+border,
					antialias: ''+(mimic.string().indexOf(CENTER) > -1),
					left: translate[0] - translate[2] * Number(precedance === X),
					top: translate[1] - translate[2] * Number(precedance === Y),
					width: newSize[0] + border,
					height: newSize[1] + border
				})
				.each(function(i) {
					var $this = $(this);

					// Set shape specific attributes
					$this[ $this.prop ? 'prop' : 'attr' ]({
						coordsize: newSize[0]+border + ' ' + newSize[1]+border,
						path: coords,
						fillcolor: color[0],
						filled: !!i,
						stroked: !i
					})
					.toggle(!!(border || i));

					// Check if border is enabled and add stroke element
					!i && $this.html( createVML(
						'stroke', 'weight="'+border*2+'px" color="'+color[1]+'" miterlimit="1000" joinstyle="miter"'
					) );
				});
			}

			// Opera bug #357 - Incorrect tip position
			// https://github.com/Craga89/qTip2/issues/367
			window.opera && setTimeout(function() {
				elements.tip.css({
					display: 'inline-block',
					visibility: 'visible'
				});
			}, 1);

			// Position if needed
			if(position !== FALSE) { this.calculate(corner, newSize); }
		},

		calculate: function(corner, size) {
			if(!this.enabled) { return FALSE; }

			var self = this,
				elements = this.qtip.elements,
				tip = this.element,
				userOffset = this.options.offset,
				position = {},
				precedance, corners;

			// Inherit corner if not provided
			corner = corner || this.corner;
			precedance = corner.precedance;

			// Determine which tip dimension to use for adjustment
			size = size || this._calculateSize(corner);

			// Setup corners and offset array
			corners = [ corner.x, corner.y ];
			if(precedance === X) { corners.reverse(); }

			// Calculate tip position
			$.each(corners, function(i, side) {
				var b, bc, br;

				if(side === CENTER) {
					b = precedance === Y ? LEFT : TOP;
					position[ b ] = '50%';
					position[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;
				}
				else {
					b = self._parseWidth(corner, side, elements.tooltip);
					bc = self._parseWidth(corner, side, elements.content);
					br = self._parseRadius(corner);

					position[ side ] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));
				}
			});

			// Adjust for tip size
			position[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];

			// Set and return new position
			tip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);
			return position;
		},

		reposition: function(event, api, pos) {
			if(!this.enabled) { return; }

			var cache = api.cache,
				newCorner = this.corner.clone(),
				adjust = pos.adjusted,
				method = api.options.position.adjust.method.split(' '),
				horizontal = method[0],
				vertical = method[1] || method[0],
				shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
				offset, css = {}, props;

			function shiftflip(direction, precedance, popposite, side, opposite) {
				// Horizontal - Shift or flip method
				if(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
					newCorner.precedance = newCorner.precedance === X ? Y : X;
				}
				else if(direction !== SHIFT && adjust[side]){
					newCorner[precedance] = newCorner[precedance] === CENTER ?
						adjust[side] > 0 ? side : opposite :
						newCorner[precedance] === side ? opposite : side;
				}
			}

			function shiftonly(xy, side, opposite) {
				if(newCorner[xy] === CENTER) {
					css[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];
				}
				else {
					props = offset[opposite] !== undefined ?
						[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];

					if( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {
						pos[side] -= adjust[side];
						shift[side] = FALSE;
					}

					css[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];
				}
			}

			// If our tip position isn't fixed e.g. doesn't adjust with viewport...
			if(this.corner.fixed !== TRUE) {
				// Perform shift/flip adjustments
				shiftflip(horizontal, X, Y, LEFT, RIGHT);
				shiftflip(vertical, Y, X, TOP, BOTTOM);

				// Update and redraw the tip if needed (check cached details of last drawn tip)
				if(newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {
					this.update(newCorner, FALSE);
				}
			}

			// Setup tip offset properties
			offset = this.calculate(newCorner);

			// Readjust offset object to make it left/top
			if(offset.right !== undefined) { offset.left = -offset.right; }
			if(offset.bottom !== undefined) { offset.top = -offset.bottom; }
			offset.user = this.offset;

			// Perform shift adjustments
			shift.left = horizontal === SHIFT && !!adjust.left;
			if(shift.left) {
				shiftonly(X, LEFT, RIGHT);
			}
			shift.top = vertical === SHIFT && !!adjust.top;
			if(shift.top) {
				shiftonly(Y, TOP, BOTTOM);
			}

			/*
			* If the tip is adjusted in both dimensions, or in a
			* direction that would cause it to be anywhere but the
			* outer border, hide it!
			*/
			this.element.css(css).toggle(
				!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)
			);

			// Adjust position to accomodate tip dimensions
			pos.left -= offset.left.charAt ? offset.user :
				horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
			pos.top -= offset.top.charAt ? offset.user :
				vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;

			// Cache details
			cache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;
			cache.corner = newCorner.clone();
		},

		destroy: function() {
			// Unbind events
			this.qtip._unbind(this.qtip.tooltip, this._ns);

			// Remove the tip element(s)
			if(this.qtip.elements.tip) {
				this.qtip.elements.tip.find('*')
					.remove().end().remove();
			}
		}
	});

	TIP = PLUGINS.tip = function(api) {
		return new Tip(api, api.options.style.tip);
	};

	// Initialize tip on render
	TIP.initialize = 'render';

	// Setup plugin sanitization options
	TIP.sanitize = function(options) {
		if(options.style && 'tip' in options.style) {
			var opts = options.style.tip;
			if(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }
			if(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
		}
	};

	// Add new option checks for the plugin
	CHECKS.tip = {
		'^position.my|style.tip.(corner|mimic|border)$': function() {
			// Make sure a tip can be drawn
			this.create();

			// Reposition the tooltip
			this.qtip.reposition();
		},
		'^style.tip.(height|width)$': function(obj) {
			// Re-set dimensions and redraw the tip
			this.size = [ obj.width, obj.height ];
			this.update();

			// Reposition the tooltip
			this.qtip.reposition();
		},
		'^content.title|style.(classes|widget)$': function() {
			this.update();
		}
	};

	// Extend original qTip defaults
	$.extend(TRUE, QTIP.defaults, {
		style: {
			tip: {
				corner: TRUE,
				mimic: FALSE,
				width: 6,
				height: 6,
				border: TRUE,
				offset: 0
			}
		}
	});
	;var MODAL, OVERLAY,
		MODALCLASS = 'qtip-modal',
		MODALSELECTOR = '.'+MODALCLASS;

	OVERLAY = function()
	{
		var self = this,
			focusableElems = {},
			current,
			prevState,
			elem;

		// Modified code from jQuery UI 1.10.0 source
		// http://code.jquery.com/ui/1.10.0/jquery-ui.js
		function focusable(element) {
			// Use the defined focusable checker when possible
			if($.expr[':'].focusable) { return $.expr[':'].focusable; }

			var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),
				nodeName = element.nodeName && element.nodeName.toLowerCase(),
				map, mapName, img;

			if('area' === nodeName) {
				map = element.parentNode;
				mapName = map.name;
				if(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
					return false;
				}
				img = $('img[usemap=#' + mapName + ']')[0];
				return !!img && img.is(':visible');
			}

			return /input|select|textarea|button|object/.test( nodeName ) ?
				!element.disabled :
				'a' === nodeName ?
					element.href || isTabIndexNotNaN :
					isTabIndexNotNaN
			;
		}

		// Focus inputs using cached focusable elements (see update())
		function focusInputs(blurElems) {
			// Blurring body element in IE causes window.open windows to unfocus!
			if(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }

			// Focus the inputs
			else { focusableElems.first().focus(); }
		}

		// Steal focus from elements outside tooltip
		function stealFocus(event) {
			if(!elem.is(':visible')) { return; }

			var target = $(event.target),
				tooltip = current.tooltip,
				container = target.closest(SELECTOR),
				targetOnTop;

			// Determine if input container target is above this
			targetOnTop = container.length < 1 ? FALSE :
				parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);

			// If we're showing a modal, but focus has landed on an input below
			// this modal, divert focus to the first visible input in this modal
			// or if we can't find one... the tooltip itself
			if(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {
				focusInputs(target);
			}
		}

		$.extend(self, {
			init: function() {
				// Create document overlay
				elem = self.elem = $('<div />', {
					id: 'qtip-overlay',
					html: '<div></div>',
					mousedown: function() { return FALSE; }
				})
				.hide();

				// Make sure we can't focus anything outside the tooltip
				$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);

				// Apply keyboard "Escape key" close handler
				$(document).bind('keydown'+MODALSELECTOR, function(event) {
					if(current && current.options.show.modal.escape && event.keyCode === 27) {
						current.hide(event);
					}
				});

				// Apply click handler for blur option
				elem.bind('click'+MODALSELECTOR, function(event) {
					if(current && current.options.show.modal.blur) {
						current.hide(event);
					}
				});

				return self;
			},

			update: function(api) {
				// Update current API reference
				current = api;

				// Update focusable elements if enabled
				if(api.options.show.modal.stealfocus !== FALSE) {
					focusableElems = api.tooltip.find('*').filter(function() {
						return focusable(this);
					});
				}
				else { focusableElems = []; }
			},

			toggle: function(api, state, duration) {
				var tooltip = api.tooltip,
					options = api.options.show.modal,
					effect = options.effect,
					type = state ? 'show': 'hide',
					visible = elem.is(':visible'),
					visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip);

				// Set active tooltip API reference
				self.update(api);

				// If the modal can steal the focus...
				// Blur the current item and focus anything in the modal we an
				if(state && options.stealfocus !== FALSE) {
					focusInputs( $(':focus') );
				}

				// Toggle backdrop cursor style on show
				elem.toggleClass('blurs', options.blur);

				// Append to body on show
				if(state) {
					elem.appendTo(document.body);
				}

				// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible
				if(elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {
					return self;
				}

				// Stop all animations
				elem.stop(TRUE, FALSE);

				// Use custom function if provided
				if($.isFunction(effect)) {
					effect.call(elem, state);
				}

				// If no effect type is supplied, use a simple toggle
				else if(effect === FALSE) {
					elem[ type ]();
				}

				// Use basic fade function
				else {
					elem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {
						if(!state) { elem.hide(); }
					});
				}

				// Reset position and detach from body on hide
				if(!state) {
					elem.queue(function(next) {
						elem.css({ left: '', top: '' });
						if(!$(MODALSELECTOR).length) { elem.detach(); }
						next();
					});
				}

				// Cache the state
				prevState = state;

				// If the tooltip is destroyed, set reference to null
				if(current.destroyed) { current = NULL; }

				return self;
			}
		});

		self.init();
	};
	OVERLAY = new OVERLAY();

	function Modal(api, options) {
		this.options = options;
		this._ns = '-modal';

		this.qtip = api;
		this.init(api);
	}

	$.extend(Modal.prototype, {
		init: function(qtip) {
			var tooltip = qtip.tooltip;

			// If modal is disabled... return
			if(!this.options.on) { return this; }

			// Set overlay reference
			qtip.elements.overlay = OVERLAY.elem;

			// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index
			tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);

			// Apply our show/hide/focus modal events
			qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {
				var oEvent = event.originalEvent;

				// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop
				if(event.target === tooltip[0]) {
					if(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {
						/* eslint-disable no-empty */
						try { event.preventDefault(); }
						catch(e) {}
						/* eslint-enable no-empty */
					}
					else if(!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {
						this.toggle(event, event.type === 'tooltipshow', duration);
					}
				}
			}, this._ns, this);

			// Adjust modal z-index on tooltip focus
			qtip._bind(tooltip, 'tooltipfocus', function(event, api) {
				// If focus was cancelled before it reached us, don't do anything
				if(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }

				var qtips = $(MODALSELECTOR),

				// Keep the modal's lower than other, regular qtips
				newIndex = QTIP.modal_zindex + qtips.length,
				curIndex = parseInt(tooltip[0].style.zIndex, 10);

				// Set overlay z-index
				OVERLAY.elem[0].style.zIndex = newIndex - 1;

				// Reduce modal z-index's and keep them properly ordered
				qtips.each(function() {
					if(this.style.zIndex > curIndex) {
						this.style.zIndex -= 1;
					}
				});

				// Fire blur event for focused tooltip
				qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);

				// Set the new z-index
				tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;

				// Set current
				OVERLAY.update(api);

				// Prevent default handling
				/* eslint-disable no-empty */
				try { event.preventDefault(); }
				catch(e) {}
				/* eslint-enable no-empty */
			}, this._ns, this);

			// Focus any other visible modals when this one hides
			qtip._bind(tooltip, 'tooltiphide', function(event) {
				if(event.target === tooltip[0]) {
					$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);
				}
			}, this._ns, this);
		},

		toggle: function(event, state, duration) {
			// Make sure default event hasn't been prevented
			if(event && event.isDefaultPrevented()) { return this; }

			// Toggle it
			OVERLAY.toggle(this.qtip, !!state, duration);
		},

		destroy: function() {
			// Remove modal class
			this.qtip.tooltip.removeClass(MODALCLASS);

			// Remove bound events
			this.qtip._unbind(this.qtip.tooltip, this._ns);

			// Delete element reference
			OVERLAY.toggle(this.qtip, FALSE);
			delete this.qtip.elements.overlay;
		}
	});


	MODAL = PLUGINS.modal = function(api) {
		return new Modal(api, api.options.show.modal);
	};

	// Setup sanitiztion rules
	MODAL.sanitize = function(opts) {
		if(opts.show) {
			if(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }
			else if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }
		}
	};

	// Base z-index for all modal tooltips (use qTip core z-index as a base)
	/* eslint-disable camelcase */
	QTIP.modal_zindex = QTIP.zindex - 200;
	/* eslint-enable camelcase */

	// Plugin needs to be initialized on render
	MODAL.initialize = 'render';

	// Setup option set checks
	CHECKS.modal = {
		'^show.modal.(on|blur)$': function() {
			// Initialise
			this.destroy();
			this.init();

			// Show the modal if not visible already and tooltip is visible
			this.qtip.elems.overlay.toggle(
				this.qtip.tooltip[0].offsetWidth > 0
			);
		}
	};

	// Extend original api defaults
	$.extend(TRUE, QTIP.defaults, {
		show: {
			modal: {
				on: FALSE,
				effect: TRUE,
				blur: TRUE,
				stealfocus: TRUE,
				escape: TRUE
			}
		}
	});
	;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)
	{
		var target = posOptions.target,
			tooltip = api.elements.tooltip,
			my = posOptions.my,
			at = posOptions.at,
			adjust = posOptions.adjust,
			method = adjust.method.split(' '),
			methodX = method[0],
			methodY = method[1] || method[0],
			viewport = posOptions.viewport,
			container = posOptions.container,
			adjusted = { left: 0, top: 0 },
			fixed, newMy, containerOffset, containerStatic,
			viewportWidth, viewportHeight, viewportScroll, viewportOffset;

		// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return
		if(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {
			return adjusted;
		}

		// Cach container details
		containerOffset = container.offset() || adjusted;
		containerStatic = container.css('position') === 'static';

		// Cache our viewport details
		fixed = tooltip.css('position') === 'fixed';
		viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);
		viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);
		viewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };
		viewportOffset = viewport.offset() || adjusted;

		// Generic calculation method
		function calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength, elemLength) {
			var initialPos = position[side1],
				mySide = my[side],
				atSide = at[side],
				isShift = type === SHIFT,
				myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,
				atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,
				sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),
				overflow1 = sideOffset - initialPos,
				overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,
				offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);

			// shift
			if(isShift) {
				offset = (mySide === side1 ? 1 : -1) * myLength;

				// Adjust position but keep it within viewport dimensions
				position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
				position[side1] = Math.max(
					-containerOffset[side1] + viewportOffset[side1],
					initialPos - offset,
					Math.min(
						Math.max(
							-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),
							initialPos + offset
						),
						position[side1],

						// Make sure we don't adjust complete off the element when using 'center'
						mySide === 'center' ? initialPos - myLength : 1E9
					)
				);

			}

			// flip/flipinvert
			else {
				// Update adjustment amount depending on if using flipinvert or flip
				adjustment *= type === FLIPINVERT ? 2 : 0;

				// Check for overflow on the left/top
				if(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
					position[side1] -= offset + adjustment;
					newMy.invert(side, side1);
				}

				// Check for overflow on the bottom/right
				else if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {
					position[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;
					newMy.invert(side, side2);
				}

				// Make sure we haven't made things worse with the adjustment and reset if so
				if(position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {
					position[side1] = initialPos; newMy = my.clone();
				}
			}

			return position[side1] - initialPos;
		}

		// Set newMy if using flip or flipinvert methods
		if(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }

		// Adjust position based onviewport and adjustment options
		adjusted = {
			left: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,
			top: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0,
			my: newMy
		};

		return adjusted;
	};
	;PLUGINS.polys = {
		// POLY area coordinate calculator
		//	Special thanks to Ed Cradock for helping out with this.
		//	Uses a binary search algorithm to find suitable coordinates.
		polygon: function(baseCoords, corner) {
			var result = {
				width: 0, height: 0,
				position: {
					top: 1e10, right: 0,
					bottom: 0, left: 1e10
				},
				adjustable: FALSE
			},
			i = 0, next,
			coords = [],
			compareX = 1, compareY = 1,
			realX = 0, realY = 0,
			newWidth, newHeight;

			// First pass, sanitize coords and determine outer edges
			i = baseCoords.length; 
			while(i--) {
				next = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];

				if(next[0] > result.position.right){ result.position.right = next[0]; }
				if(next[0] < result.position.left){ result.position.left = next[0]; }
				if(next[1] > result.position.bottom){ result.position.bottom = next[1]; }
				if(next[1] < result.position.top){ result.position.top = next[1]; }

				coords.push(next);
			}

			// Calculate height and width from outer edges
			newWidth = result.width = Math.abs(result.position.right - result.position.left);
			newHeight = result.height = Math.abs(result.position.bottom - result.position.top);

			// If it's the center corner...
			if(corner.abbrev() === 'c') {
				result.position = {
					left: result.position.left + result.width / 2,
					top: result.position.top + result.height / 2
				};
			}
			else {
				// Second pass, use a binary search algorithm to locate most suitable coordinate
				while(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)
				{
					newWidth = Math.floor(newWidth / 2);
					newHeight = Math.floor(newHeight / 2);

					if(corner.x === LEFT){ compareX = newWidth; }
					else if(corner.x === RIGHT){ compareX = result.width - newWidth; }
					else{ compareX += Math.floor(newWidth / 2); }

					if(corner.y === TOP){ compareY = newHeight; }
					else if(corner.y === BOTTOM){ compareY = result.height - newHeight; }
					else{ compareY += Math.floor(newHeight / 2); }

					i = coords.length;
					while(i--)
					{
						if(coords.length < 2){ break; }

						realX = coords[i][0] - result.position.left;
						realY = coords[i][1] - result.position.top;

						if(
							corner.x === LEFT && realX >= compareX ||
							corner.x === RIGHT && realX <= compareX ||
							corner.x === CENTER && (realX < compareX || realX > result.width - compareX) ||
							corner.y === TOP && realY >= compareY ||
							corner.y === BOTTOM && realY <= compareY ||
							corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {
							coords.splice(i, 1);
						}
					}
				}
				result.position = { left: coords[0][0], top: coords[0][1] };
			}

			return result;
		},

		rect: function(ax, ay, bx, by) {
			return {
				width: Math.abs(bx - ax),
				height: Math.abs(by - ay),
				position: {
					left: Math.min(ax, bx),
					top: Math.min(ay, by)
				}
			};
		},

		_angles: {
			tc: 3 / 2, tr: 7 / 4, tl: 5 / 4,
			bc: 1 / 2, br: 1 / 4, bl: 3 / 4,
			rc: 2, lc: 1, c: 0
		},
		ellipse: function(cx, cy, rx, ry, corner) {
			var c = PLUGINS.polys._angles[ corner.abbrev() ],
				rxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),
				rys = ry * Math.sin( c * Math.PI );

			return {
				width: rx * 2 - Math.abs(rxc),
				height: ry * 2 - Math.abs(rys),
				position: {
					left: cx + rxc,
					top: cy + rys
				},
				adjustable: FALSE
			};
		},
		circle: function(cx, cy, r, corner) {
			return PLUGINS.polys.ellipse(cx, cy, r, r, corner);
		}
	};
	;PLUGINS.svg = function(api, svg, corner)
	{
		var elem = svg[0],
			root = $(elem.ownerSVGElement),
			ownerDocument = elem.ownerDocument,
			strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,
			frameOffset, mtx, transformed,
			len, next, i, points,
			result, position;

		// Ascend the parentNode chain until we find an element with getBBox()
		while(!elem.getBBox) { elem = elem.parentNode; }
		if(!elem.getBBox || !elem.parentNode) { return FALSE; }

		// Determine which shape calculation to use
		switch(elem.nodeName) {
			case 'ellipse':
			case 'circle':
				result = PLUGINS.polys.ellipse(
					elem.cx.baseVal.value,
					elem.cy.baseVal.value,
					(elem.rx || elem.r).baseVal.value + strokeWidth2,
					(elem.ry || elem.r).baseVal.value + strokeWidth2,
					corner
				);
			break;

			case 'line':
			case 'polygon':
			case 'polyline':
				// Determine points object (line has none, so mimic using array)
				points = elem.points || [
					{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },
					{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }
				];

				for(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {
					next = points.getItem ? points.getItem(i) : points[i];
					result.push.apply(result, [next.x, next.y]);
				}

				result = PLUGINS.polys.polygon(result, corner);
			break;

			// Unknown shape or rectangle? Use bounding box
			default:
				result = elem.getBBox();
				result = {
					width: result.width,
					height: result.height,
					position: {
						left: result.x,
						top: result.y
					}
				};
			break;
		}

		// Shortcut assignments
		position = result.position;
		root = root[0];

		// Convert position into a pixel value
		if(root.createSVGPoint) {
			mtx = elem.getScreenCTM();
			points = root.createSVGPoint();

			points.x = position.left;
			points.y = position.top;
			transformed = points.matrixTransform( mtx );
			position.left = transformed.x;
			position.top = transformed.y;
		}

		// Check the element is not in a child document, and if so, adjust for frame elements offset
		if(ownerDocument !== document && api.position.target !== 'mouse') {
			frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();
			if(frameOffset) {
				position.left += frameOffset.left;
				position.top += frameOffset.top;
			}
		}

		// Adjust by scroll offset of owner document
		ownerDocument = $(ownerDocument);
		position.left += ownerDocument.scrollLeft();
		position.top += ownerDocument.scrollTop();

		return result;
	};
	;PLUGINS.imagemap = function(api, area, corner)
	{
		if(!area.jquery) { area = $(area); }

		var shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),
			image = $('img[usemap="#'+area.parent('map').attr('name')+'"]'),
			coordsString = $.trim(area.attr('coords')),
			coordsArray = coordsString.replace(/,$/, '').split(','),
			imageOffset, coords, i, result, len;

		// If we can't find the image using the map...
		if(!image.length) { return FALSE; }

		// Pass coordinates string if polygon
		if(shape === 'polygon') {
			result = PLUGINS.polys.polygon(coordsArray, corner);
		}

		// Otherwise parse the coordinates and pass them as arguments
		else if(PLUGINS.polys[shape]) {
			for(i = -1, len = coordsArray.length, coords = []; ++i < len;) {
				coords.push( parseInt(coordsArray[i], 10) );
			}

			result = PLUGINS.polys[shape].apply(
				this, coords.concat(corner)
			);
		}

		// If no shapre calculation method was found, return false
		else { return FALSE; }

		// Make sure we account for padding and borders on the image
		imageOffset = image.offset();
		imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);
		imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);

		// Add image position to offset coordinates
		result.position.left += imageOffset.left;
		result.position.top += imageOffset.top;

		return result;
	};
	;var IE6,

	/*
	 * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)
	 * Special thanks to Brandon Aaron
	 */
	BGIFRAME = '<iframe class="qtip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';" ' +
		' style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +
			'-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>';

	function Ie6(api) {
		this._ns = 'ie6';

		this.qtip = api;
		this.init(api);
	}

	$.extend(Ie6.prototype, {
		_scroll : function() {
			var overlay = this.qtip.elements.overlay;
			overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');
		},

		init: function(qtip) {
			var tooltip = qtip.tooltip;

			// Create the BGIFrame element if needed
			if($('select, object').length < 1) {
				this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);

				// Update BGIFrame on tooltip move
				qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);
			}

			// redraw() container for width/height calculations
			this.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })
				.appendTo(document.body);

			// Fixup modal plugin if present too
			if( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {
				qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);
				qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);
			}

			// Set dimensions
			this.redraw();
		},

		adjustBGIFrame: function() {
			var tooltip = this.qtip.tooltip,
				dimensions = {
					height: tooltip.outerHeight(FALSE),
					width: tooltip.outerWidth(FALSE)
				},
				plugin = this.qtip.plugins.tip,
				tip = this.qtip.elements.tip,
				tipAdjust, offset;

			// Adjust border offset
			offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;
			offset = { left: -offset, top: -offset };

			// Adjust for tips plugin
			if(plugin && tip) {
				tipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];
				offset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();
			}

			// Update bgiframe
			this.bgiframe.css(offset).css(dimensions);
		},

		// Max/min width simulator function
		redraw: function() {
			if(this.qtip.rendered < 1 || this.drawing) { return this; }

			var tooltip = this.qtip.tooltip,
				style = this.qtip.options.style,
				container = this.qtip.options.position.container,
				perc, width, max, min;

			// Set drawing flag
			this.qtip.drawing = 1;

			// If tooltip has a set height/width, just set it... like a boss!
			if(style.height) { tooltip.css(HEIGHT, style.height); }
			if(style.width) { tooltip.css(WIDTH, style.width); }

			// Simulate max/min width if not set width present...
			else {
				// Reset width and add fluid class
				tooltip.css(WIDTH, '').appendTo(this.redrawContainer);

				// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)
				width = tooltip.width();
				if(width % 2 < 1) { width += 1; }

				// Grab our max/min properties
				max = tooltip.css('maxWidth') || '';
				min = tooltip.css('minWidth') || '';

				// Parse into proper pixel values
				perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;
				max = (max.indexOf('%') > -1 ? perc : 1 * parseInt(max, 10)) || width;
				min = (min.indexOf('%') > -1 ? perc : 1 * parseInt(min, 10)) || 0;

				// Determine new dimension size based on max/min/current values
				width = max + min ? Math.min(Math.max(width, min), max) : width;

				// Set the newly calculated width and remvoe fluid class
				tooltip.css(WIDTH, Math.round(width)).appendTo(container);
			}

			// Set drawing flag
			this.drawing = 0;

			return this;
		},

		destroy: function() {
			// Remove iframe
			this.bgiframe && this.bgiframe.remove();

			// Remove bound events
			this.qtip._unbind([window, this.qtip.tooltip], this._ns);
		}
	});

	IE6 = PLUGINS.ie6 = function(api) {
		// Proceed only if the browser is IE6
		return BROWSER.ie === 6 ? new Ie6(api) : FALSE;
	};

	IE6.initialize = 'render';

	CHECKS.ie6 = {
		'^content|style$': function() {
			this.redraw();
		}
	};
	;}));
	}( window, document ));


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(48), __webpack_require__(96)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView, FormUtil) {

	  function runCallback(callback, field) {
	    callback.apply(this, _.map(field.split(/\s+/), function (field) {
	      return this.model.get(field);
	    }, this));
	  }

	  function runIf(fn, ctx) {
	    if (_.isFunction(fn)) {
	      fn.call(ctx);
	    }
	  }

	  /**
	   * @class InputWrapper
	   * @extends Okta.View
	   * @private
	   * The outer wrapper that warps the label and the input container
	   */
	  return BaseView.extend({

	    className: function () {
	      var className = 'o-form-fieldset';

	      if (this.options['label-top']) {
	        className += ' o-form-label-top';
	      }

	      if (this.options.readOnly) {
	        className += ' o-form-read-mode';
	      }

	      return className;
	    },

	    attributes: function () {
	      return {
	        'data-se': this.options['data-se'] || 'o-form-fieldset'
	      };
	    },

	    /**
	     * @constructor
	     * @param  {Object} options options hash
	     * @param  {Object} [options.events]
	     * @param  {Object} [options.bindings]
	     * @param  {Object} [options.showWhen]
	     * @param  {Function} [options.initialize] post initialize callback
	     * @param  {Function} [options.render] post render callback
	     */
	    constructor: function (options) {
	      if (options.className) {
	        this.inputWrapperClassName = this.className;
	        this.optionsClassName = options.className;
	        options.className = function () {
	          return _.result(this, 'inputWrapperClassName', '') + ' ' + _.result(this, 'optionsClassName');
	        };
	      }
	      BaseView.apply(this, arguments);
	      _.each(options.events || {}, function (callback, event) {
	        this.listenTo(this.model, event, callback);
	      }, this);

	      _.each(options.bindings || {}, function (callback, field) {
	        this.listenTo(this.model, FormUtil.changeEventString(field.split(/\s+/)),
	          _.bind(runCallback, this, callback, field));
	      }, this);

	      FormUtil.applyShowWhen(this, options.showWhen);
	      FormUtil.applyToggleWhen(this, options.toggleWhen);

	      runIf(options.initialize, this);
	    },

	    postRender: function () {
	      _.each(this.options.bindings || {}, runCallback, this);
	      runIf(this.options.render, this);
	    },

	    /**
	     * @return {InputLabel}
	     */
	    getLabel: function () {
	      return this.size() > 1 ? this.at(0) : null;
	    },
	    /**
	     * @deprecated ambiguous naming, use {@link #getInputContainer}
	     */
	    getInput: function () {
	      return this.getInputContainer();
	    },

	    /**
	     * @return {InputContainer}
	     */
	    getInputContainer: function () {
	      return this.at(this.size() > 1 ? 1 : 0);
	    },

	    /**
	     * @return {BaseInput[]}
	     */
	    getInputs: function () {
	      return this.getInputContainer().toArray();
	    },

	    focus: function () {
	      return this.getInput().focus();
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint max-params: [2, 6] */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(48),
	  __webpack_require__(64),
	  __webpack_require__(13),
	  __webpack_require__(85)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, StringUtil, BaseView, Keys, Logger, ViewUtil) {

	  var LABEL_OPTIONS = ['model', 'id', 'inputId', 'type', 'label', 'sublabel', 'tooltip', 'name'],

	      CONTAINER_OPTIONS = ['wide', 'multi', 'input', 'explain', 'customExplain', 'model', 'name', 'type', 'autoRender'],

	      WRAPPER_OPTIONS = ['model', 'name', 'label-top', 'readOnly', 'events', 'initialize', 'showWhen', 'bindings',
	        'render', 'className', 'data-se', 'toggleWhen'],

	      INPUT_OPTIONS = ['model', 'name', 'inputId', 'type', // base options
	        'input', // custom input
	        'placeholder', 'label', // labels
	        'readOnly', 'read', 'disabled', 'readModeString', // modes
	        'options', // select/radio
	        'from', 'to', // model transformers,
	        'autoRender', // model attributes change event to trigger rerendering of the input
	        'inlineValidation', // control inline validating against the model on focus lost
	        'params'], // widgets params - for input specific widgets

	      OTHER_OPTIONS = ['errorField'];


	  var ALL_OPTIONS = _.uniq(_.union(LABEL_OPTIONS, CONTAINER_OPTIONS, WRAPPER_OPTIONS, INPUT_OPTIONS, OTHER_OPTIONS));

	  var SAVE_BUTTON_PHASES = [
	    '•         ',
	    '•  •      ',
	    '•  •  •   ',
	    '•  •  •  •',
	    '   •  •  •',
	    '      •  •',
	    '         •',
	    '          ',
	    '          ',
	    '          '
	  ];

	  function decorateDoWhen(doWhen) {
	    if (doWhen && !doWhen['__edit__']) {
	      return _.extend({'__edit__': _.constant(true)}, doWhen);
	    }
	  }

	  function createButton(options) {

	    options = _.pick(options || {}, 'action', 'className', 'text', 'type');

	    var timeoutId, intervalId, phaseCount;

	    return BaseView.extend({
	      tagName: 'input',
	      className: 'button',
	      events: {
	        'click': function () {
	          if (options.action && !this.disabled()) {
	            options.action.call(this);
	          }
	        },
	        'keyup': function (e) {
	          if (Keys.isEnter(e) && options.action && !this.disabled()) {
	            options.action.call(this);
	          }
	        }
	      },

	      disabled: function () {
	        return this.$el.prop('disabled') === true;
	      },

	      disable: function () {
	        this.$el.prop('disabled', true);
	        this.$el.addClass('btn-disabled');
	      },

	      enable: function () {
	        this.$el.prop('disabled', false);
	        this.$el.removeClass('btn-disabled');
	      },

	      initialize: function () {
	        var self = this;

	        this.$el.attr('type', options.type == 'save' ? 'submit' : 'button');
	        this.$el.val(options.text);
	        if (options.className) {
	          this.$el.addClass(options.className);
	        }
	        if (options.type) {
	          this.$el.attr('data-type', options.type);
	        }

	        this.$el.mousedown(function () {
	          self.model.set('__pending__', true);
	        });

	        this.$el.mouseup(function () {
	          self.model.set('__pending__', false);
	        });

	        this.listenTo(this.model, 'form:set-saving-state', function () {
	          this.disable();
	          if (options.type == 'save') {
	            timeoutId = setTimeout(_.bind(this.__changeSaveText, this), 1000);
	          }
	        });
	        this.listenTo(this.model, 'form:clear-saving-state', function () {
	          this.enable();
	          if (options.type == 'save') {
	            clearTimeout(timeoutId);
	            clearInterval(intervalId);
	            this.$el.val(options.text);
	          }
	        });
	      },

	      __changeSaveText: function () {
	        phaseCount = 0;
	        intervalId = setInterval(_.bind(this.__showLoadingText, this), 200);
	      },

	      __showLoadingText: function () {
	        this.$el.val(SAVE_BUTTON_PHASES[phaseCount++ % SAVE_BUTTON_PHASES.length]);
	      }
	    });
	  }

	  function validateInput(options, model) {
	    /* eslint max-statements: 0, complexity: 0 */

	    options || (options = {});

	    if (options.type == 'label') {
	      if (!options.label) {
	        Logger.warn('A label input must have a "label" parameter', options);
	      }
	      return;
	    }

	    if (options.type == 'button') {
	      if (!options.title && !options.icon) {
	        Logger.warn('A button input must have a "title" and/or an "icon" parameter', options);
	      }
	      if (!options.click && !options.href) {
	        Logger.warn('A button input must have a "click" and/or an "href" parameter', options);
	      }
	      return;
	    }

	    if (!options.name && !options.input) {
	      Logger.warn('Missing "name" or "input" parameters', options);
	    }

	    if (_.isArray(options.name) && _.isArray(options.input)) {
	      throw new Error('Not allowed to have both "name" and "input" defined as array.');
	    }

	    if (options.type != 'list' && options.name && (model && model.allows)) {
	      var names = [];
	      if (_.isArray(options.name)) {
	        names = options.name;
	      } else {
	        names.push(options.name);
	      }
	      _.each(names, function (name) {
	        if (!model.allows(name)) {
	          throw new Error('field not allowed: ' + options.name);
	        }
	      });
	    }

	    if (_.isArray(options.input) && options.type != 'list') {
	      _.each(options.input, function (input) {
	        validateInput(input, model);
	      });
	    }

	    var keys = _.keys(options),
	        intersection = _.intersection(keys, ALL_OPTIONS);

	    if (_.size(intersection) != _.size(options)) {
	      var fields = _.clone(ALL_OPTIONS);
	      fields.unshift(keys);
	      Logger.warn('Invalid input parameters', _.without.apply(null, fields), options);
	    }
	  }

	  function generateInputOptions(options, form, createFn) {
	    options = _.clone(options);

	    if (_.contains(['list', 'group'], options.type)) {
	      options.params = _.defaults({
	        create: createFn,
	        inputs: _.map(_.isArray(options.input) ? options.input : [options.input], function (input) {
	          return _.first(generateInputOptions(input, form, createFn));
	        })
	      }, options.params || {});
	      delete options.input;
	    }

	    var inputs = _.isArray(options.input) ? _.clone(options.input) : [options];

	    return _.map(inputs, function (input) {
	      var target = _.defaults({model: form.model}, input, _.omit(options, 'input', 'inputs'), form.options, {
	        id: _.uniqueId('input'),
	        readOnly: form.isReadOnly(),
	        read: form.hasReadMode()
	      });
	      if (form.isReadOnly()) {
	        target.read = target.readOnly = true;
	      }
	      return target;
	    });

	  }

	  return {

	    LABEL_OPTIONS: LABEL_OPTIONS,
	    CONTAINER_OPTIONS: CONTAINER_OPTIONS,
	    WRAPPER_OPTIONS: WRAPPER_OPTIONS,
	    INPUT_OPTIONS: INPUT_OPTIONS,

	    generateInputOptions: generateInputOptions,

	    changeEventString: function (fieldNames) {
	      return 'change:' + fieldNames.join(' change:');
	    },

	    createReadFormButton: function (options) {

	      var action, text, ariaLabel;
	      if (options.type == 'cancel') {
	        text = ariaLabel = StringUtil.localize('oform.cancel');
	        action = function () {
	          this.model.trigger('form:cancel');
	        };
	      }
	      else {
	        text = StringUtil.localize('oform.edit');
	        ariaLabel = text + ' ' + options.formTitle;
	        action = function () {
	          this.model.set('__edit__', true);
	        };
	      }

	      return BaseView.extend({
	        tagName: 'a',
	        attributes: {
	          href: '#',
	          'aria-label': ariaLabel
	        },
	        template: function () {
	          return _.escape(text);
	        },
	        events: {
	          click: function (e) {
	            e.preventDefault();
	            action.call(this);
	          }
	        }
	      });

	    },

	    createButton: function (options) {
	      options = _.clone(options);
	      switch (options.type) {
	      case 'save':
	        _.defaults(options, {className: 'button-primary'});
	        break;
	      case 'cancel':
	        _.defaults(options, {
	          text: StringUtil.localize('oform.cancel'),
	          action: function () {
	            this.model.trigger('form:cancel');
	          }
	        });
	        break;
	      case 'previous':
	        _.defaults(options, {
	          text: StringUtil.localize('oform.previous'),
	          action: function () {
	            this.model.trigger('form:previous');
	          }
	        });
	        break;
	      }
	      return createButton(options);
	    },

	    validateInput: validateInput,

	    /**
	     * Applies a show-when logic on a view instance.
	     * The show-when is a map of a model field name -> a boolean or a function that returns a boolean.
	     * The view will toggle based on the field value.
	     *
	     * @param  {Okta.View} view a view instance that has a this.model attached to it
	     * @param  {Object} showWhen
	     */
	    applyShowWhen: function (view, showWhen) {
	      var toggleAndResize = function (bool) {
	        return function () {
	          // The `toggle` is here since an event may be triggered before the el is in the DOM
	          // and in that case slide events may not function as expected.
	          view.$el.toggle(bool);
	          view.model.trigger('form:resize');
	        };
	      };

	      ViewUtil.applyDoWhen(view, decorateDoWhen(showWhen), function (bool, options) {
	        if (!options.animate) {
	          view.$el.toggle(bool);
	        }
	        else {
	          view.$el['slide' + (bool ? 'Down' : 'Up')](200, toggleAndResize(bool));
	        }
	      });
	    },

	    applyToggleWhen: function (view, toggleWhen) {
	      ViewUtil.applyDoWhen(view, decorateDoWhen(toggleWhen), function (bool, options) {
	        view.$el.toggle(bool);
	        view.model.trigger('form:resize');
	        if (options.animate) {
	          view.render();
	        }
	      });
	    }
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(48)], __WEBPACK_AMD_DEFINE_RESULT__ = function (BaseView) {

	  var template = '\
	    <div class="okta-form-infobox-error infobox infobox-error" role="alert">\
	      <span class="icon error-16"></span>\
	      {{#if errorSummary}}\
	        <p>{{errorSummary}}</p>\
	      {{else}}\
	        <p>{{i18n code="oform.errorbanner.title"}}</p>\
	      {{/if}}\
	    </div>\
	  ';

	  return BaseView.extend({
	    template: template,
	    modelEvents: {
	      'form:clear-errors': 'remove'
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 98 */
/***/ function(module, exports) {

	// empty (null-loader)

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(48),
	  __webpack_require__(96)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView, FormUtil) {

	  return BaseView.extend({

	    className: 'o-form-button-bar',

	    initialize: function (options) {
	      this.addButton({
	        type: 'save',
	        text: _.resultCtx(options, 'save', this),
	        className: _.resultCtx(options, 'saveClassName', this)
	      });

	      if (!options.noCancelButton) {
	        this.addButton({type: 'cancel', text: _.resultCtx(options, 'cancel', this)});
	      }

	      if (options.hasPrevStep) {
	        this.addButton({type: 'previous'}, {prepend: true});
	      }
	    },

	    /**
	     * Adds a buttomn to the toolbar
	     * @param {Object} params button parameters
	     * @param {Object} options {@link Okta.View#add} options
	     */
	    addButton: function (params, options) {
	      return this.add(FormUtil.createButton(params), options);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(48),
	  __webpack_require__(101)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, BaseView, Time) {

	  function getOption(callout, option) {
	    return _.resultCtx(callout.options, option, callout) || _.result(callout, option);
	  }

	  function getTopClass(callout) {
	    var klass = 'infobox clearfix infobox-' + getOption(callout, 'type');
	    switch (getOption(callout, 'size')) {
	    case 'standard':
	      klass += '';
	      break;
	    case 'compact':
	      klass += ' infobox-compact';
	      break;
	    case 'large':
	      klass += ' infobox-md';
	      break;
	    }
	    if (getOption(callout, 'dismissible')) {
	      klass += ' infobox-dismiss';
	    }
	    return klass;
	  }

	  var events = {
	    'click .infobox-dismiss-link': function (e) {
	      e.preventDefault();
	      this.$el.fadeOut(Time.UNLOADING_FADE, _.bind(this.remove, this));
	    }
	  };

	  var template = '\
	    {{#if dismissible}}\
	      <a class="infobox-dismiss-link" title="Dismiss" href="#">\
	        <span class="dismiss-icon"></span>\
	      </a>\
	    {{/if}}\
	    <span class="icon {{icon}}"></span>\
	    {{#if title}}<h3>{{title}}</h3>{{/if}}\
	    {{#if subtitle}}<p>{{subtitle}}</p>{{/if}}\
	    {{#if bullets}}\
	      <ul class="bullets">\
	      {{#each bullets}}<li>{{this}}</li>{{/each}}\
	      </ul>\
	    {{/if}}\
	  ';

	  /**
	   * @class Callout
	   * @private
	   */

	  var Callout = BaseView.extend({

	    /**
	     * Custom HTML or view to inject to the callout
	     * @type {String|Okta.View}
	     */
	    content: null,

	    /**
	     * Size of icon. options are standard, large, compact
	     * @type {String}
	     */
	    size: 'standard',

	    /**
	     * Type of the callout. Valid values are: info, success, warning, error, tip
	     * @type {String}
	     */
	    type: 'info',

	    /**
	     * Can the callout be dismissed
	     * @type {Boolean}
	     */
	    dismissible: false,

	    /**
	     * Callout title
	     * @type {String}
	     */
	    title: null,

	    /**
	     * Callout subtitle
	     * @type {String}
	     */
	    subtitle: null,

	    /**
	     * Array of strings to render as bullet points
	     * @type {Array}
	     */
	    bullets: null,

	    constructor: function () {
	      this.events = _.defaults(this.events || {}, events);

	      BaseView.apply(this, arguments);

	      this.$el.addClass(getTopClass(this));

	      this.template = template;

	      var content = getOption(this, 'content');
	      if (content) {
	        this.add(content);
	      }
	    },

	    getTemplateData: function () {
	      var icon = getOption(this, 'type');
	      if (icon == 'tip') { // css is inconsistent
	        icon = 'light-bulb';
	      }
	      return {
	        icon: icon + '-' + (getOption(this, 'size') == 'large' ? '24' : '16'),
	        title: getOption(this, 'title'),
	        subtitle: getOption(this, 'subtitle'),
	        bullets: getOption(this, 'bullets'),
	        dismissible: getOption(this, 'dismissible')
	      };
	    }
	  });

	  return {
	    /**
	     * @static
	     * @param {Object} options
	     * @param {String|Function} [options.size] Size of icon. options are standard, large, compact
	     * @param {String|Okta.View} [options.content] Custom HTML or view to inject to the callout
	     * @param {String|Function} [options.title] Callout title
	     * @param {String|Function} [options.subtitle] Callout subtitle
	     * @param {Array|Function} [options.bullets] Array of strings to render as bullet points
	     * @param {Boolean|Function} [options.dismissible] Can the callout be dismissed
	     * @param {String|Function} [options.type] Callout type. Valid values are: info, success, warning, error, tip
	     *
	     * @return {Callout}
	     */
	    create: function (options) {
	      return new Callout(options);
	    }
	  };


	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	!(module.exports = {
	  DEBOUNCE_DELAY: 200,
	  LOADING_FADE: 400,
	  UNLOADING_FADE: 400,
	  ROW_EXPANDER_TRANSITION: 150,
	  HIDE_ADD_MAPPING_FORM: 300
	});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* jshint maxparams: 100 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(117),
	  __webpack_require__(169),
	  __webpack_require__(127),
	  __webpack_require__(130),
	  __webpack_require__(141),
	  __webpack_require__(145),
	  __webpack_require__(147),
	  __webpack_require__(150),
	  __webpack_require__(152),
	  __webpack_require__(153),
	  __webpack_require__(154),
	  __webpack_require__(158),
	  __webpack_require__(159),
	  __webpack_require__(160),
	  __webpack_require__(161),
	  __webpack_require__(164),
	  __webpack_require__(165),
	  __webpack_require__(166),
	  __webpack_require__(167),
	  __webpack_require__(103),
	  __webpack_require__(174),
	  __webpack_require__(176),
	  __webpack_require__(177),
	  __webpack_require__(178),
	  __webpack_require__(181),
	  __webpack_require__(182),
	  __webpack_require__(184),
	  __webpack_require__(185),
	  __webpack_require__(186),
	  __webpack_require__(187),
	  __webpack_require__(188),
	  __webpack_require__(189),
	  __webpack_require__(190),
	  __webpack_require__(191),
	  __webpack_require__(119),
	  __webpack_require__(192),
	  __webpack_require__(124),
	  __webpack_require__(193)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (BaseLoginRouter,
	          PrimaryAuthController,
	          VerifyDuoController,
	          MfaVerifyController,
	          VerifyWindowsHelloController,
	          VerifyU2FController,
	          EnrollChoicesController,
	          EnrollDuoController,
	          EnrollQuestionController,
	          EnrollWindowsHelloController,
	          EnrollCallAndSmsController,
	          EnrollOnPremController,
	          EnrollSymantecVipController,
	          EnrollYubikeyController,
	          EnrollTotpController,
	          EnrollU2FController,
	          BarcodeTotpController,
	          BarcodePushController,
	          ActivateTotpController,
	          ManualSetupTotpController,
	          ManualSetupPushController,
	          EnrollmentLinkSentController,
	          EnterPasscodePushFlowController,
	          PasswordExpiredController,
	          CustomPasswordExpiredController,
	          ForgotPasswordController,
	          RecoveryChallengeController,
	          PwdResetEmailSentController,
	          RecoveryQuestionController,
	          PasswordResetController,
	          RecoveryLoadingController,
	          UnlockAccountController,
	          AccountUnlockedController,
	          UnlockEmailSentController,
	          RefreshAuthStateController,
	          QRLoginController,
	          SecurityBeacon,
	          FactorBeacon) {
	  return BaseLoginRouter.extend({

	    routes: {
	      '': 'primaryAuth',
	      'signin': 'primaryAuth',
	      'signin/verify/duo/web': 'verifyDuo',
	      'signin/verify/fido/webauthn': 'verifyWindowsHello',
	      'signin/verify/fido/u2f': 'verifyU2F',
	      'signin/verify/:provider/:factorType': 'verify',
	      'signin/enroll': 'enrollChoices',
	      'signin/enroll/duo/web': 'enrollDuo',
	      'signin/enroll/okta/question': 'enrollQuestion',
	      'signin/enroll/okta/sms': 'enrollSms',
	      'signin/enroll/okta/call': 'enrollCall',
	      'signin/enroll-activate/okta/sms': 'enrollSms',
	      'signin/enroll/rsa/token': 'enrollRsa',
	      'signin/enroll/del_oath/token': 'enrollOnPrem',
	      'signin/enroll/symantec/token': 'enrollSymantecVip',
	      'signin/enroll/yubico/token:hardware': 'enrollYubikey',
	      'signin/enroll/fido/webauthn': 'enrollWindowsHello',
	      'signin/enroll/fido/u2f': 'enrollU2F',
	      'signin/enroll/:provider/:factorType': 'enrollTotpFactor',
	      'signin/enroll-activate/okta/push': 'scanBarcodePushFactor',
	      'signin/enroll-activate/okta/push/manual': 'manualSetupPushFactor',
	      'signin/enroll-activate/okta/push/sent': 'activationLinkSent',
	      'signin/enroll-activate/okta/token:software:totp/passcode': 'enterPasscodeInPushEnrollmentFlow',
	      'signin/enroll-activate/:provider/:factorType': 'scanBarcodeTotpFactor',
	      'signin/enroll-activate/:provider/:factorType/activate': 'activateTotpFactor',
	      'signin/enroll-activate/:provider/:factorType/manual': 'manualSetupTotpFactor',
	      'signin/password-expired': 'passwordExpired',
	      'signin/custom-password-expired': 'customPasswordExpired',
	      'signin/forgot-password': 'forgotPassword',
	      'signin/recovery-challenge': 'recoveryChallenge',
	      'signin/recovery-emailed': 'recoveryEmailSent',
	      'signin/recovery-question': 'recoveryQuestion',
	      'signin/password-reset': 'passwordReset',
	      'signin/reset-password/:token': 'recoveryLoading',
	      'signin/user-unlock/:token': 'recoveryLoading',
	      'signin/recovery/:token': 'recoveryLoading',
	      'signin/unlock-emailed': 'unlockEmailSent',
	      'signin/unlock': 'unlockAccount',
	      'signin/account-unlocked': 'accountUnlocked',
	      'signin/refresh-auth-state(/:token)': 'refreshAuthState',
	      'signin/qr-login': 'qrLogin',
	      '*wildcard': 'primaryAuth'
	    },

	    // Route handlers that do not require a stateToken. If the page is refreshed,
	    // these functions will not require a status call to refresh the stateToken.
	    stateLessRouteHandlers: [
	      'primaryAuth', 'forgotPassword', 'recoveryLoading', 'unlockAccount', 'refreshAuthState', 'qrLogin'
	    ],

	    primaryAuth: function () {
	      this.render(PrimaryAuthController, { Beacon: SecurityBeacon });
	    },

	    qrLogin: function () {
	      this.render(QRLoginController, {
	        
	      });
	    },

	    verifyDuo: function () {
	      this.render(VerifyDuoController, {
	        provider: 'DUO',
	        factorType: 'web',
	        Beacon: FactorBeacon
	      });
	    },

	    verifyWindowsHello: function () {
	      this.render(VerifyWindowsHelloController, {
	        provider: 'FIDO',
	        factorType: 'webauthn',
	        Beacon: FactorBeacon
	      });
	    },

	    verifyU2F: function () {
	      this.render(VerifyU2FController, {
	        provider: 'FIDO',
	        factorType: 'u2f',
	        Beacon: FactorBeacon
	      });
	    },

	    verify: function (provider, factorType) {
	      this.render(MfaVerifyController, {
	        provider: provider.toUpperCase(),
	        factorType: factorType,
	        Beacon: FactorBeacon
	      });
	    },

	    enrollChoices: function () {
	      this.render(EnrollChoicesController, { Beacon: SecurityBeacon });
	    },

	    enrollDuo: function () {
	      this.render(EnrollDuoController, {
	        provider: 'DUO',
	        factorType: 'web',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollQuestion: function () {
	      this.render(EnrollQuestionController, {
	        provider: 'OKTA',
	        factorType: 'question',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollSms: function () {
	      this.render(EnrollCallAndSmsController, {
	        provider: 'OKTA',
	        factorType: 'sms',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollCall: function () {
	      this.render(EnrollCallAndSmsController, {
	        provider: 'OKTA',
	        factorType: 'call',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollRsa: function () {
	      this.render(EnrollOnPremController, {
	        provider: 'RSA',
	        factorType: 'token',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollOnPrem: function () {
	      this.render(EnrollOnPremController, {
	        provider: 'DEL_OATH',
	        factorType: 'token',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollSymantecVip: function () {
	      this.render(EnrollSymantecVipController, {
	        provider: 'SYMANTEC',
	        factorType: 'token',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollYubikey: function () {
	      this.render(EnrollYubikeyController, {
	        provider: 'YUBICO',
	        factorType: 'token:hardware',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollTotpFactor: function (provider, factorType) {
	      this.render(EnrollTotpController, {
	        provider: provider.toUpperCase(),
	        factorType: factorType,
	        Beacon: FactorBeacon
	      });
	    },

	    enrollWindowsHello: function () {
	      this.render(EnrollWindowsHelloController, {
	        provider: 'FIDO',
	        factorType: 'webauthn',
	        Beacon: FactorBeacon
	      });
	    },

	    enrollU2F: function () {
	      this.render(EnrollU2FController, {
	        provider: 'FIDO',
	        factorType: 'u2f',
	        Beacon: FactorBeacon
	      });
	    },

	    scanBarcodeTotpFactor: function (provider, factorType) {
	      this.render(BarcodeTotpController, {
	        provider: provider.toUpperCase(),
	        factorType: factorType,
	        Beacon: FactorBeacon
	      });
	    },

	    scanBarcodePushFactor: function () {
	      this.render(BarcodePushController, {
	        provider: 'OKTA',
	        factorType: 'push',
	        Beacon: FactorBeacon
	      });
	    },

	    activateTotpFactor: function (provider, factorType) {
	      this.render(ActivateTotpController, {
	        provider: provider.toUpperCase(),
	        factorType: factorType,
	        Beacon: FactorBeacon
	      });
	    },

	    manualSetupTotpFactor: function (provider, factorType) {
	      this.render(ManualSetupTotpController, {
	        provider: provider.toUpperCase(),
	        factorType: factorType,
	        Beacon: FactorBeacon
	      });
	    },

	    manualSetupPushFactor: function () {
	      this.render(ManualSetupPushController, {
	        provider: 'OKTA',
	        factorType: 'push',
	        Beacon: FactorBeacon
	      });
	    },

	    activationLinkSent: function () {
	      this.render(EnrollmentLinkSentController, {
	        provider: 'OKTA',
	        factorType: 'push',
	        Beacon: FactorBeacon
	      });
	    },

	    enterPasscodeInPushEnrollmentFlow: function () {
	      this.render(EnterPasscodePushFlowController, {
	        provider: 'OKTA',
	        factorType: 'token:software:totp',
	        Beacon: FactorBeacon
	      });
	    },

	    passwordExpired: function () {
	      this.render(PasswordExpiredController, { Beacon: SecurityBeacon });
	    },

	    customPasswordExpired: function () {
	      this.render(CustomPasswordExpiredController, { Beacon: SecurityBeacon });
	    },

	    forgotPassword: function () {
	      this.render(ForgotPasswordController);
	    },

	    recoveryChallenge: function () {
	      this.render(RecoveryChallengeController, { Beacon: SecurityBeacon });
	    },

	    recoveryEmailSent: function () {
	      this.render(PwdResetEmailSentController, { Beacon: SecurityBeacon });
	    },

	    unlockEmailSent: function () {
	      this.render(UnlockEmailSentController, { Beacon: SecurityBeacon });
	    },

	    recoveryQuestion: function () {
	      this.render(RecoveryQuestionController, { Beacon: SecurityBeacon });
	    },

	    passwordReset: function () {
	      this.render(PasswordResetController, { Beacon: SecurityBeacon });
	    },

	    recoveryLoading: function (token) {
	      this.render(RecoveryLoadingController, {
	        token: token,
	        Beacon: SecurityBeacon
	      });
	    },

	    unlockAccount: function () {
	      this.render(UnlockAccountController);
	    },

	    accountUnlocked: function () {
	      this.render(AccountUnlockedController, { Beacon: SecurityBeacon });
	    },

	    refreshAuthState: function (token) {
	      this.render(RefreshAuthStateController, {
	        token: token,
	        Beacon: SecurityBeacon
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109),
	  __webpack_require__(115),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, FormController, FormType, RouterUtil, ManualSetupFooter, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-manual-totp',
	    Model: function () {
	      return {
	        local: {
	          'sharedSecret': ['string', false, this.options.appState.get('sharedSecret')],
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        }
	      };
	    },

	    Form: {
	      title: function () {
	        var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	        return Okta.loc('enroll.totp.title', 'login', [factorName]);
	      },
	      subtitle: _.partial(Okta.loc, 'enroll.totp.cannotScanBarcode', 'login'),
	      noButtonBar: true,
	      attributes: { 'data-se': 'step-manual-setup' },

	      formChildren: function () {
	        return [
	          FormType.View({View: '\
	            <p class="okta-form-subtitle o-form-explain text-align-c">\
	              {{i18n code="enroll.totp.manualSetupInstructions" bundle="login"}}\
	            </p>\
	          '}),

	          FormType.Input({
	            name: 'sharedSecret',
	            input: TextBox,
	            type: 'text',
	            disabled: true
	          }),

	          FormType.Toolbar({
	            noCancelButton: true,
	            save: Okta.loc('oform.next', 'login')
	          })
	        ];
	      }
	    },

	    Footer: ManualSetupFooter,

	    initialize: function () {
	      this.listenTo(this.form, 'save', function () {
	        var url = RouterUtil.createActivateFactorUrl(this.model.get('__provider__'),
	          this.model.get('__factorType__'), 'activate');
	        this.options.appState.trigger('navigate', url);
	      });
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  var _ = Okta._;

	  var fn = {};

	  var factorData = {
	    'OKTA_VERIFY': {
	      label: 'factor.totpSoft.oktaVerify',
	      description: 'factor.totpSoft.description',
	      iconClassName: 'mfa-okta-verify',
	      sortOrder: 1
	    },
	    'OKTA_VERIFY_PUSH': {
	      label: 'factor.oktaVerifyPush',
	      description: 'factor.push.description',
	      iconClassName: 'mfa-okta-verify',
	      sortOrder: 1
	    },
	    'SMS': {
	      label: 'factor.sms',
	      description: 'factor.sms.description',
	      iconClassName: 'mfa-okta-sms',
	      sortOrder: 2
	    },
	    'CALL': {
	      label: 'factor.call',
	      description: 'factor.call.description',
	      iconClassName: 'mfa-okta-call',
	      sortOrder: 3
	    },
	    'WINDOWS_HELLO': {
	      label: 'factor.windowsHello',
	      description: 'factor.windowsHello.signin.description',
	      iconClassName: 'mfa-windows-hello',
	      sortOrder: 4
	    },
	    'U2F': {
	      label: 'factor.u2f',
	      description: 'factor.u2f.description',
	      iconClassName: 'mfa-u2f',
	      sortOrder: 5
	    },
	    'YUBIKEY': {
	      label: 'factor.totpHard.yubikey',
	      description: 'factor.totpHard.yubikey.description',
	      iconClassName: 'mfa-yubikey',
	      sortOrder: 6
	    },
	    'DUO': {
	      label: 'factor.duo',
	      description: 'factor.duo.description',
	      iconClassName: 'mfa-duo',
	      sortOrder: 7
	    },
	    'GOOGLE_AUTH': {
	      label: 'factor.totpSoft.googleAuthenticator',
	      description: 'factor.totpSoft.description',
	      iconClassName: 'mfa-google-auth',
	      sortOrder: 8
	    },
	    'SYMANTEC_VIP': {
	      label: 'factor.totpHard.symantecVip',
	      description: 'factor.totpHard.description',
	      iconClassName: 'mfa-symantec',
	      sortOrder: 9
	    },
	    'RSA_SECURID': {
	      label: 'factor.totpHard.rsaSecurId',
	      description: 'factor.totpHard.description',
	      iconClassName: 'mfa-rsa',
	      sortOrder: 10
	    },
	    'ON_PREM': {
	      label: '',
	      description: 'factor.totpHard.description',
	      iconClassName: 'mfa-onprem',
	      sortOrder: 10
	    },
	    'QUESTION': {
	      label: 'factor.securityQuestion',
	      description: 'factor.securityQuestion.description',
	      iconClassName: 'mfa-okta-security-question',
	      sortOrder: 11
	    }
	  };

	  /* jshint maxstatements: 30, maxcomplexity: 15 */
	  fn.getFactorName = function (provider, factorType) {
	    if (provider === 'OKTA' && factorType === 'token:software:totp') {
	      return 'OKTA_VERIFY';
	    }
	    if (provider === 'OKTA' && factorType === 'push') {
	      return 'OKTA_VERIFY_PUSH';
	    }
	    if (provider === 'GOOGLE') {
	      return 'GOOGLE_AUTH';
	    }
	    if (provider === 'SYMANTEC' && factorType === 'token') {
	      return 'SYMANTEC_VIP';
	    }
	    if (provider === 'RSA' && factorType === 'token') {
	      return 'RSA_SECURID';
	    }
	    if (provider === 'DEL_OATH' && factorType === 'token') {
	      return 'ON_PREM';
	    }
	    if (provider === 'DUO' && factorType === 'web') {
	      return 'DUO';
	    }
	    if (provider === 'YUBICO' && factorType === 'token:hardware') {
	      return 'YUBIKEY';
	    }
	    if (provider === 'OKTA' && factorType === 'sms') {
	      return 'SMS';
	    }
	    if (provider === 'OKTA' && factorType === 'call') {
	      return 'CALL';
	    }
	    if (provider === 'OKTA' && factorType === 'question') {
	      return 'QUESTION';
	    }
	    if (provider === 'FIDO' && factorType === 'webauthn') {
	      return 'WINDOWS_HELLO';
	    }
	    if (provider === 'FIDO' && factorType === 'u2f') {
	      return 'U2F';
	    }
	  };

	  fn.isOktaVerify = function (provider, factorType) {
	    return provider === 'OKTA' && (factorType === 'token:software:totp' || factorType === 'push');
	  };

	  fn.getFactorLabel = function (provider, factorType) {
	    var key = factorData[fn.getFactorName(provider, factorType)].label;
	    return Okta.loc(key, 'login');
	  };

	  fn.getFactorDescription = function (provider, factorType) {
	    var key = factorData[fn.getFactorName(provider, factorType)].description;
	    return Okta.loc(key, 'login');
	  };

	  fn.getFactorIconClassName = function (provider, factorType) {
	    return factorData[fn.getFactorName(provider, factorType)].iconClassName;
	  };

	  fn.getFactorSortOrder = function (provider, factorType) {
	    return factorData[fn.getFactorName(provider, factorType)].sortOrder;
	  };

	  fn.getRememberDeviceValue = function (appState) {
	    return appState && appState.get('rememberDeviceByDefault');
	  };

	  fn.getSecurityQuestionLabel = function (questionObj) {
	    var localizedQuestion = Okta.loc('security.' + questionObj.question);
	    return localizedQuestion.indexOf('L10N_ERROR') < 0 ? localizedQuestion : questionObj.questionText;
	  };

	  fn.getPasswordComplexityDescription = function (policyComplexity) {
	    var fields = {
	      minLength: {i18n: 'password.complexity.length', args: true},
	      minLowerCase: {i18n: 'password.complexity.lowercase'},
	      minUpperCase: {i18n: 'password.complexity.uppercase'},
	      minNumber: {i18n: 'password.complexity.number'},
	      minSymbol: {i18n: 'password.complexity.symbol'},
	      excludeUsername: {i18n: 'password.complexity.no_username'}
	    };

	    var requirements = _.map(policyComplexity, function (complexityValue, complexityType) {
	      if(!complexityValue){
	        return;
	      }

	      var params = fields[complexityType];
	      return params.args ?
	        Okta.loc(params.i18n, 'login', [complexityValue]) : Okta.loc(params.i18n, 'login');
	    });

	    if (requirements.length) {
	      requirements = _.reduce(requirements, function (result, requirement) {
	        return result ?
	          (requirement ? (result + Okta.loc('password.complexity.list.element', 'login', [requirement])) : result) :
	          requirement;
	      });

	      return Okta.loc('password.complexity.description', 'login', [requirements]);
	    }
	  };


	  return fn;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(106),
	  __webpack_require__(99),
	  __webpack_require__(96),
	  __webpack_require__(107),
	  __webpack_require__(108)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormType, Toolbar, FormUtil, BaseLoginController, BaseLoginModel) {

	  var _ = Okta._;

	  var SimpleForm = Okta.Form.extend({
	    layout: 'o-form-theme',
	    noCancelButton: true,
	    constructor: function (options) {
	      Okta.Form.call(this, options);
	      _.each(_.result(this, 'formChildren') || [], function (child) {
	        switch (child.type) {
	        case FormType.INPUT:
	          this.addInput(_.extend({
	            label: false,
	            'label-top': true
	          }, child.viewOptions));
	          break;
	        case FormType.BUTTON:
	          this.add(Okta.createButton(_.extend({ model: this.model }, child.viewOptions)), child.addOptions);
	          FormUtil.applyShowWhen(this.last(), child.viewOptions && child.viewOptions.showWhen);
	          break;
	        case FormType.DIVIDER:
	          this.addDivider(child.viewOptions);
	          break;
	        case FormType.TOOLBAR:
	          this.add(Toolbar, { options: child.viewOptions });
	          FormUtil.applyShowWhen(this.last(), child.viewOptions && child.viewOptions.showWhen);
	          break;
	        case FormType.VIEW:
	          this.add(child.viewOptions.View, child.addOptions);
	          FormUtil.applyShowWhen(this.last(), child.viewOptions.showWhen);
	          break;
	        default:
	          throw new Error('Unrecognized child type: ' + child.type);
	        }
	      }, this);
	    }
	  });

	  return BaseLoginController.extend({

	    constructor: function () {
	      var initialize = this.initialize;
	      this.initialize = function () {};

	      BaseLoginController.apply(this, arguments);

	      if (this.Model && this.Form) {
	        var Model = BaseLoginModel.extend(_.extend({
	          parse: function (attributes) {
	            this.settings = attributes.settings;
	            this.appState = attributes.appState;
	            return _.omit(attributes, ['settings', 'appState']);
	          }
	        }, _.result(this, 'Model')));
	        this.model = new Model({
	          settings: this.settings,
	          appState: this.options.appState
	        }, { parse: true });
	        var Form = SimpleForm.extend(_.result(this, 'Form', this));
	        this.form = new Form(this.toJSON());
	        this.add(this.form);
	      }

	      if (this.Footer) {
	        this.footer = new this.Footer(this.toJSON());
	        this.add(this.footer);
	      }

	      this.addListeners();
	      initialize.apply(this, arguments);
	    },

	    toJSON: function () {
	      var data = BaseLoginController.prototype.toJSON.apply(this, arguments);
	      return _.extend(_.pick(this.options, 'appState'), data);
	    },

	    back: function () {
	      if (this.footer && this.footer.back) {
	        this.footer.back();
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

	  // Syntactic sugar to provide some structure to SimpleForm inputs - Just
	  // wraps options with { type: type, viewOptions: viewOptions, addOptions: addOptions }

	  var INPUT = 'INPUT';
	  var BUTTON = 'BUTTON';
	  var DIVIDER = 'DIVIDER';
	  var TOOLBAR = 'TOOLBAR';
	  var VIEW = 'VIEW';

	  function wrap(type) {
	    return function (viewOptions, addOptions) {
	      return { type: type, viewOptions: viewOptions, addOptions: addOptions };
	    };
	  }

	  return {
	    Input: wrap(INPUT),
	    Button: wrap(BUTTON),
	    Divider: wrap(DIVIDER),
	    Toolbar: wrap(TOOLBAR),
	    View: wrap(VIEW),

	    INPUT: INPUT,
	    BUTTON: BUTTON,
	    DIVIDER: DIVIDER,
	    TOOLBAR: TOOLBAR,
	    VIEW: VIEW
	  };

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint newcap:false */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q) {
	  var _ = Okta._;

	  function getForm(controller) {
	    return _.find(controller.getChildren(), function (item) {
	      return (item instanceof Okta.Form);
	    });
	  }

	  return Okta.Controller.extend({

	    // Ideally we should be attaching the listeners in the constructor, but because of the way
	    // we construct the FormController (this.model is generated after the BaseLoginController's
	    // constructor is called), this.model is undefined in when try to attach the events and
	    // therefore we don't listen to events for such forms. And changing the order in which we call
	    // the constructor doesn't help either (JS errors etc.). This at least guarantees that we
	    // are listening to the model events.
	    // Note - Figure out a way to call the constructor in the right order.
	    addListeners: function () {
	      // TOTP model is special, its model will not be attached to a controller, but will
	      // tag along with the push factor model. We need to listen to the transaction
	      // changes on this as well (in case of the push+totp form).
	      var totpModel = this.model.get('backupFactor');

	      // Events to enable/disable the primary button on the forms
	      this.listenTo(this.model, 'save', function () {
	        //disable the submit button on forms while making the request
	        //to prevent users from hitting rate limiting exceptions of
	        //1 per second on the auth api
	        var form = getForm(this);
	        var disableSubmitButton = form.disableSubmitButton;
	        if (disableSubmitButton && !form.disableSubmitButton()) {
	          return;
	        }
	        this.toggleButtonState(true);
	      });

	      this.listenTo(this.model, 'error', function () {
	        this.toggleButtonState(false);
	      });

	      var setTransactionHandler = _.bind(function (transaction) {
	        this.options.appState.set('transaction', transaction);
	      }, this);
	      var transactionErrorHandler = _.bind(function (err) {
	        this.options.appState.set('transactionError', err);
	      }, this);

	      // Events to set the transaction attributes on the app state.
	      this.listenTo(this.model, 'setTransaction', setTransactionHandler);
	      this.listenTo(this.model, 'setTransactionError', transactionErrorHandler);

	      // For TOTP factor model
	      if (totpModel) {
	        this.listenTo(totpModel, 'setTransaction', setTransactionHandler);
	        this.listenTo(totpModel, 'setTransactionError', transactionErrorHandler);
	      }
	    },

	    // Override this method to delay switching to this screen until return
	    // promise is resolved. This is useful for cases like enrolling a security
	    // question, which requires an additional request to fetch the question
	    // list.
	    fetchInitialData: function () {
	      return Q();
	    },

	    // Override this method to prevent route navigation. This is useful for
	    // intermediate status changes that do not trigger a full refresh of the
	    // page, like MFA_ENROLL_ACTIVATE and MFA_CHALLENGE.
	    trapAuthResponse: function () {
	      return false;
	    },

	    toJSON: function () {
	      var data = Okta.Controller.prototype.toJSON.apply(this, arguments);
	      return _.extend(_.pick(this.options, 'appState'), data);
	    },

	    toggleButtonState: function (state) {
	      var button = this.$el.find('.button');
	      button.toggleClass('link-button-disabled', state).prop('disabled', state);
	    },


	    postRenderAnimation: function() {
	      // Event triggered after a page is rendered along with the classname to identify the page
	      this.trigger('pageRendered', {page: this.className});
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q) {

	  var _ = Okta._;
	  var KNOWN_ERRORS = [
	    'OAuthError', 
	    'AuthSdkError', 
	    'AuthPollStopError', 
	    'AuthApiError'
	  ];

	  return Okta.Model.extend({
	    doTransaction: function (fn, rethrow) {
	      var self = this;
	      return fn.call(this, this.appState.get('transaction'))
	      .then(function(trans) {
	        self.trigger('setTransaction', trans);
	        return trans;
	      })
	      .fail(function(err) {
	        // Q may still consider AuthPollStopError to be unhandled
	        if (err.name === 'AuthPollStopError') {
	          return;
	        }
	        self.trigger('setTransactionError', err);
	        self.trigger('error', self, err.xhr);
	        if (rethrow || _.indexOf(KNOWN_ERRORS, err.name) === -1) {
	          throw err;
	        }
	      });
	    },

	    manageTransaction: function (fn) {
	      var self = this,
	          res = fn.call(this, this.appState.get('transaction'), _.bind(this.setTransaction, this));
	      
	      // If it's a promise, listen for failures
	      if (Q.isPromise(res)) {
	        res.fail(function(err) {
	          if (err.name === 'AuthPollStopError') {
	            return;
	          }
	          self.trigger('setTransactionError', err);
	          self.trigger('error', self, err.xhr);
	        });
	      }

	      return Q.resolve(res);
	    },

	    startTransaction: function (fn) {
	      var self = this,
	          res = fn.call(this, this.settings.getAuthClient());

	      // If it's a promise, then chain to it
	      if (Q.isPromise(res)) {
	        return res.then(function(trans) {
	          self.trigger('setTransaction', trans);
	          return trans;
	        })
	        .fail(function(err) {
	          self.trigger('setTransactionError', err);
	          self.trigger('error', self, err.xhr);
	          throw err;
	        });
	      }

	      return Q.resolve(res);
	    },

	    setTransaction: function (trans) {
	      this.appState.set('transaction', trans);
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint maxcomplexity:24,maxstatements:25 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(110),
	  __webpack_require__(111),
	  __webpack_require__(112),
	  __webpack_require__(14),
	  __webpack_require__(113),
	  __webpack_require__(114)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Util, OAuth2Util, Enums, BrowserFeatures, Errors, ErrorCodes) {

	  var fn = {};

	  var verifyUrlTpl = Okta.tpl('signin/verify/{{provider}}/{{factorType}}');
	  var enrollFactorUrlTpl = Okta.tpl('signin/enroll/{{provider}}/{{factorType}}');
	  var activateFactorUrlTpl = Okta.tpl(
	    'signin/enroll-activate/{{provider}}/{{factorType}}{{#if step}}/{{step}}{{/if}}'
	  );
	  var recoveryUrlTpl = Okta.tpl('signin/recovery/{{recoveryToken}}');
	  var refreshUrlTpl = Okta.tpl('signin/refresh-auth-state{{#if token}}/{{token}}{{/if}}');
	  var sessionCookieRedirectTpl = Okta.tpl(
	    '{{baseUrl}}/login/sessionCookieRedirect?checkAccountSetupComplete=true' +
	    '&token={{{token}}}&redirectUrl={{{redirectUrl}}}'
	  );

	  fn.createVerifyUrl = function (provider, factorType) {
	    return verifyUrlTpl({
	      provider: encodeURIComponent(provider.toLowerCase()),
	      factorType: encodeURIComponent(factorType)
	    });
	  };

	  fn.createEnrollFactorUrl = function (provider, factorType) {
	    return enrollFactorUrlTpl({
	      provider: encodeURIComponent(provider.toLowerCase()),
	      factorType: encodeURIComponent(factorType)
	    });
	  };

	  fn.createActivateFactorUrl = function (provider, factorType, step) {
	    return activateFactorUrlTpl({
	      provider: encodeURIComponent(provider.toLowerCase()),
	      factorType: encodeURIComponent(factorType),
	      step: step ? encodeURIComponent(step) : false
	    });
	  };

	  fn.createRecoveryUrl = function (recoveryToken) {
	    return recoveryUrlTpl({
	      recoveryToken: encodeURIComponent(recoveryToken)
	    });
	  };

	  fn.createRefreshUrl = function (stateToken) {
	    var token = stateToken ? encodeURIComponent(stateToken) : null;
	    return refreshUrlTpl({ token: token });
	  };

	  fn.routeAfterAuthStatusChange = function (router, err, res) {

	    // Global error handling for CORS enabled errors
	    if (err && err.xhr && BrowserFeatures.corsIsNotEnabled(err.xhr)) {
	      router.settings.callGlobalError(new Errors.UnsupportedBrowserError(
	        Okta.loc('error.enabled.cors')
	      ));
	      return;
	    }

	    // Token has expired - no longer valid. Navigate back to primary auth.
	    if (err && err.errorCode === ErrorCodes.INVALID_TOKEN_EXCEPTION) {
	      router.appState.set('flashError', Okta.loc('error.expired.session'));
	      router.controller.state.set('navigateDir', Enums.DIRECTION_BACK);
	      router.navigate('', { trigger: true });
	      return;
	    }

	    // Other errors are handled by the function making the authClient request
	    if (err || !res || !res.status) {
	      return;
	    }

	    router.appState.setAuthResponse(res);

	    if (router.controller && router.controller.trapAuthResponse(res)) {
	      return;
	    }

	    switch (res.status) {
	    case 'SUCCESS':
	      // If the desired end result object needs to have idToken (and not sessionToken),
	      // get the id token from session token before calling the global success function.
	      if (router.settings.get('oauth2Enabled')) {
	        OAuth2Util.getTokens(router.settings, {sessionToken: res.sessionToken}, router.controller);
	        return;
	      }

	      if(res.recoveryType === Enums.RECOVERY_TYPE_UNLOCK) {
	        router.navigate('signin/account-unlocked', {trigger: true});
	        return;
	      }

	      router.settings.callGlobalSuccess(Enums.SUCCESS, {
	        user: res._embedded.user,
	        session: {
	          token: res.sessionToken,
	          setCookieAndRedirect: function (redirectUrl) {
	            Util.redirect(sessionCookieRedirectTpl({
	              baseUrl: router.settings.get('baseUrl'),
	              token: encodeURIComponent(res.sessionToken),
	              redirectUrl: encodeURIComponent(redirectUrl)
	            }));
	          }
	        }
	      });
	      return;
	    case 'MFA_REQUIRED':
	      var factor = router.appState.get('factors').getDefaultFactor();
	      var url = fn.createVerifyUrl(factor.get('provider'), factor.get('factorType'));
	      router.navigate(url, { trigger: true });
	      return;
	    case 'MFA_CHALLENGE':
	      // Since we normally trap MFA_CHALLENGE, this will only get called on a
	      // page refresh. We need to return to MFA_REQUIRED to initialize the
	      // page correctly (i.e. factors dropdown, etc)
	      router.appState.get('transaction').prev()
	      .then(function(trans) {
	        router.appState.set('transaction', trans);
	      }).done();
	      return;
	    case 'MFA_ENROLL':
	      router.navigate('signin/enroll', { trigger: true });
	      return;
	    case 'MFA_ENROLL_ACTIVATE':
	      var activateUrl = fn.createActivateFactorUrl(router.appState.get('activatedFactorProvider'),
	        router.appState.get('activatedFactorType'));
	      router.navigate(activateUrl, { trigger: true });
	      return;
	    case 'PASSWORD_WARN':
	    case 'PASSWORD_EXPIRED':
	      if (router.settings.get('features.customExpiredPassword') && !router.appState.get('isPwdManagedByOkta')) {
	        router.navigate('signin/custom-password-expired', { trigger: true });
	      } else {
	        router.navigate('signin/password-expired', { trigger: true });
	      }
	      return;
	    case 'RECOVERY_CHALLENGE':
	      // Will use this workaround (lowercasing response) until OKTA-69083 is resolved
	      var fromEmail = res.factorType.toLowerCase() === Enums.RECOVERY_FACTOR_TYPE_EMAIL.toLowerCase(),
	          isForgotPassword = res.recoveryType === Enums.RECOVERY_TYPE_PASSWORD,
	          isUnlock = res.recoveryType === Enums.RECOVERY_TYPE_UNLOCK;
	      if (isForgotPassword && fromEmail) {
	        router.navigate('signin/recovery-emailed', { trigger: true });
	      }
	      else if (isUnlock && fromEmail) {
	        router.navigate('signin/unlock-emailed', { trigger: true });
	      }
	      else {
	        router.navigate('signin/recovery-challenge', { trigger: true });
	      }
	      return;
	    case 'RECOVERY':
	      router.navigate('signin/recovery-question', { trigger: true });
	      return;
	    case 'PASSWORD_RESET':
	      router.navigate('signin/password-reset', { trigger: true });
	      return;
	    case 'LOCKED_OUT':
	      if (router.settings.get('features.selfServiceUnlock')) {
	        router.navigate('signin/unlock', { trigger: true });
	      } else {
	        router.controller.model.trigger('error', router.controller.model, {
	          responseJSON: {
	            errorCauses: [],
	            errorSummary: Okta.loc('error.auth.lockedOut', 'login')
	          }
	        });
	      }
	      return;
	    default:
	      throw new Error('Unknown status: ' + res.status);
	    }
	  };

	  return fn;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {

	  return {
	    redirect: function (url) {
	      window.location = url;
	    },

	    constantError: function (errorMessage) {
	      return function () {
	        throw new Error(errorMessage);
	      };
	    },

	    /**
	     * Simply convert an URL query key value pair object into an URL query string.
	     * Remember NOT to escape the query string when using this util.
	     * example:
	     * input: {userId: 123, instanceId: undefined, expand: 'schema,app'}
	     * output: '?userId=123&expand=schema,app'
	     */
	    getUrlQueryString: function (queries) {
	      _.isObject(queries) || (queries = {});
	      var queriesString = _.without(_.map(queries, function (value, key) {
	        if (value !== undefined && value !== null) {
	          return key + '=' + encodeURIComponent(value);
	        }
	      }), undefined).join('&');
	      return _.isEmpty(queriesString) ? '' : '?' + queriesString;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(112), __webpack_require__(113)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums, Errors) {

	  var util = {};
	  var _ = Okta._;

	  function hasResponseType(params, type) {
	    if (_.isArray(params.responseType)) {
	      return _.contains(params.responseType, type);
	    }
	    else {
	      return type === params.responseType;
	    }
	  }

	  /**
	   * Get the tokens in the OIDC/OAUTH flows
	   *
	   * @param settings - settings model object
	   * @param params - {idp: 'xxx'} for social auth
	   *                 {sessionToken: 'xxx'} for okta idp
	   */
	  util.getTokens = function (settings, params, controller) {

	    function success(result) {
	      settings.callGlobalSuccess(Enums.SUCCESS, result);
	    }

	    function error(error) {
	      // OKTA-104330- Handle error case where user is not assigned to OIDC client
	      if (error.errorCode === 'access_denied') {
	        controller.model.trigger('error', controller.model, {'responseJSON': error});
	        controller.model.appState.trigger('removeLoading');
	      } else {
	        settings.callGlobalError(new Errors.OAuthError(error.message));
	      }
	    }

	    var authClient = settings.getAuthClient(),
	        options = settings.toJSON({ verbose: true }),
	        oauthParams = {},
	        extraOptions = {};

	    _.extend(
	      oauthParams,
	      _.pick(options, 'clientId', 'redirectUri'),
	      _.pick(options.authParams, 'responseType', 'responseMode', 'display', 'scopes', 'state', 'nonce'),
	      params
	    );

	    // Extra Options for Social Idp popup window title and id_token response timeout
	    extraOptions.popupTitle = Okta.loc('socialauth.popup.title', 'login');
	    extraOptions.timeout = options.oAuthTimeout;

	    _.extend(
	      extraOptions,
	      _.pick(options.authParams, 'issuer', 'authorizeUrl')
	    );

	    // Redirect flow - this can be used when logging into an external IDP, or
	    // converting the Okta sessionToken to an access_token, id_token, and/or
	    // authorization code. Note: The authorization code flow will always redirect.
	    if (oauthParams.display === 'page' || hasResponseType(oauthParams, 'code')) {
	      authClient.token.getWithRedirect(oauthParams, extraOptions);
	    }

	    // Default flow if logging in with Okta as the IDP - convert sessionToken to
	    // tokens in a hidden iframe. Used in Single Page Apps where the app does
	    // not want to redirect away from the page to convert the token.
	    else if (oauthParams.sessionToken) {
	      authClient.token.getWithoutPrompt(oauthParams, extraOptions)
	      .then(success)
	      .fail(error)
	      .done();
	    }

	    // Default flow if logging in with an external IDP - opens a popup and
	    // gets the token from a postMessage response.
	    else {
	      authClient.token.getWithPopup(oauthParams, extraOptions)
	      .then(success)
	      .fail(error)
	      .done();
	    }
	  };

	  return util;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(module.exports = {

	  DIRECTION_BACK: 'DIRECTION_BACK',

	  RECOVERY_TYPE_PASSWORD: 'PASSWORD',
	  RECOVERY_TYPE_UNLOCK: 'UNLOCK',
	  RECOVERY_FACTOR_TYPE_SMS: 'SMS',
	  RECOVERY_FACTOR_TYPE_EMAIL: 'EMAIL',
	  RECOVERY_FACTOR_TYPE_CALL: 'CALL',

	  // Global success messages
	  SUCCESS: 'SUCCESS',
	  FORGOT_PASSWORD_EMAIL_SENT: 'FORGOT_PASSWORD_EMAIL_SENT',
	  UNLOCK_ACCOUNT_EMAIL_SENT: 'UNLOCK_ACCOUNT_EMAIL_SENT',

	  // Global error messages
	  CONFIG_ERROR: 'CONFIG_ERROR',
	  UNSUPPORTED_BROWSER_ERROR: 'UNSUPPORTED_BROWSER_ERROR',
	  OAUTH_ERROR: 'OAUTH_ERROR',

	  // Enroll choice page types
	  ALL_OPTIONAL_NONE_ENROLLED: 'ALL_OPTIONAL_NONE_ENROLLED',
	  ALL_OPTIONAL_SOME_ENROLLED: 'ALL_OPTIONAL_SOME_ENROLLED',
	  HAS_REQUIRED_NONE_ENROLLED: 'HAS_REQUIRED_NONE_ENROLLED',
	  HAS_REQUIRED_SOME_REQUIRED_ENROLLED: 'HAS_REQUIRED_SOME_REQUIRED_ENROLLED',
	  HAS_REQUIRED_ALL_REQUIRED_ENROLLED: 'HAS_REQUIRED_ALL_REQUIRED_ENROLLED',

	  // Operations
	  PRIMARY_AUTH: 'PRIMARY_AUTH',
	  FORGOT_PASSWORD: 'FORGOT_PASSWORD',
	  UNLOCK_ACCOUNT: 'UNLOCK_ACCOUNT'

	});


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums) {

	  function ConfigError(message) {
	    this.name = Enums.CONFIG_ERROR;
	    this.message = message || Okta.loc('error.config');
	  }
	  ConfigError.prototype = new Error();

	  function UnsupportedBrowserError(message) {
	    this.name = Enums.UNSUPPORTED_BROWSER_ERROR;
	    this.message = message || Okta.loc('error.unsupported.browser');
	  }
	  UnsupportedBrowserError.prototype = new Error();

	  function OAuthError(message) {
	    this.name = Enums.OAUTH_ERROR;
	    this.message = message;
	  }
	  OAuthError.prototype = new Error();

	  return {
	    ConfigError: ConfigError,
	    UnsupportedBrowserError: UnsupportedBrowserError,
	    OAuthError: OAuthError
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(module.exports = {
	  INVALID_TOKEN_EXCEPTION: 'E0000011'
	});


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(109),
	  __webpack_require__(112)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, RouterUtil, Enums) {

	  return Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="mfa.backToFactors" bundle="login"}}\
	      </a>\
	      <a href="#" class="link help goto js-goto" data-se="goto-link">\
	        {{i18n code="mfa.scanBarcode" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      },
	      'click .js-goto' : function (e) {
	        e.preventDefault();
	        // go to a different screen with current auth status:
	        // refresh the latest response
	        this.model.startTransaction(function (authClient) {
	          return authClient.tx.resume();
	        });
	      }
	    },
	    back: function () {
	      this.state.set('navigateDir', Enums.DIRECTION_BACK);
	      if (this.options.appState.get('prevLink')) {
	        // Once we are in the MFA_ENROLL_ACTIVATE, we need to reset to the
	        // correct state. Fortunately, this means that the router will
	        // handle navigation once the request is finished.
	        this.model.doTransaction(function (transaction) {
	          return transaction.prev();
	        });
	      }
	      else {
	        this.options.appState.trigger('navigate', 'signin/enroll');
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	//note: not including Okta here and explicitly including jquery and Handlebars
	//because we want to be explicit about which TextBox we are extending here
	//and want to avoid the cirucular dependency that occurs if we
	//include Okta
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(6),
	  __webpack_require__(5),
	  __webpack_require__(14),
	  __webpack_require__(62),
	  __webpack_require__(94)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, Handlebars, BrowserFeatures, TextBox) {

	  function hasTitleAndText(options) {
	    var title = options.title,
	        text = options.text;

	    if (title && text && title !== text) {
	      return true;
	    }
	    return false;
	  }

	  // options may be a string or an object.
	  function createQtipContent(options) {
	    if (hasTitleAndText(options)) {
	      return options;
	    }
	    return {text: options.text || options};
	  }

	  return TextBox.extend({

	    template: Handlebars.compile('\
	      {{#if params}}\
	        {{#if params.innerTooltip}}\
	          <span class="input-tooltip icon form-help-16"></span>\
	        {{/if}}\
	        {{#if params.icon}}\
	          <span class="icon input-icon {{params.icon}}"></span>\
	        {{/if}}\
	      {{/if}}\
	      <input type="{{type}}" placeholder="{{placeholder}}" aria-label="{{placeholder}}"\
	        name="{{name}}" id="{{inputId}}" value="{{value}}" autocomplete="off"/>\
	    '),

	    postRender: function () {
	      var params = this.options.params,
	          content;

	      if (this.options.type === 'number') {
	        var input = this.$('input');
	        input.attr({
	          pattern: '[0-9]*',
	          inputmode: 'numeric'
	        });
	      }

	      if (params && params.innerTooltip) {
	        content = createQtipContent(params.innerTooltip);
	        this.$('.input-tooltip').qtip({
	          content: content,
	          style: {classes: 'okta-sign-in-tooltip qtip-custom qtip-shadow'},
	          position: {
	            my: 'bottom left',
	            // Note: qTip2 has a known issue calculating the tooltip offset when:
	            // 1. A container element has both:
	            //    a) position: relative/absolute
	            //    b) overlay: value other than 'visible'
	            // 2. The page is scrolled
	            //
	            // We set position:relative and overlay:auto on the body element,
	            // where both are required for:
	            // - Positioning the footer correctly
	            // - Displaying long pages in embedded browsers
	            //
	            // The original design called for a fixed position relative to the
	            // tooltip icon - this has been switched to "relative to mouse, and
	            // update position when mouse moves" because of this constraint.
	            target: 'mouse',
	            adjust: {
	              method: 'flip',
	              mouse: true,
	              y: -5,
	              x: 5
	            },
	            viewport: $('body')
	          }
	        });
	      }
	    },

	    // Override the focus() to ignore focus in IE. IE (8-11) has a known bug where
	    // the placeholder text disappears when the input field is focused.
	    focus: function () {
	      if (BrowserFeatures.isIE()) {
	        return;
	      }
	      return TextBox.prototype.focus.apply(this, arguments);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* jshint maxparams: 100 */
	// BaseLoginRouter contains the more complicated router logic - rendering/
	// transition, etc. Most router changes should happen in LoginRouter (which is
	// responsible for adding new routes)
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(44),
	  __webpack_require__(14),
	  __webpack_require__(119),
	  __webpack_require__(120),
	  __webpack_require__(121),
	  __webpack_require__(124),
	  __webpack_require__(118),
	  __webpack_require__(125),
	  __webpack_require__(109),
	  __webpack_require__(122),
	  __webpack_require__(113),
	  __webpack_require__(8)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Backbone, BrowserFeatures, RefreshAuthStateController, Settings, Header,
	          SecurityBeacon, AuthContainer, AppState, RouterUtil, Animations, Errors, Bundles) {

	  var _ = Okta._,
	      $ = Okta.$;

	  function isStateLessRouteHandler(router, fn) {
	    return _.find(router.stateLessRouteHandlers, function (routeName) {
	      return fn === router[routeName];
	    });
	  }

	  function beaconIsAvailable(Beacon, settings) {
	    if (!Beacon) {
	      return false;
	    }
	    if (Beacon === SecurityBeacon) {
	      return settings.get('features.securityImage');
	    }
	    return true;
	  }

	  function loadLanguage(appState, i18n, assetBaseUrl, assetRewrite) {
	    var timeout = setTimeout(function () {
	      // Trigger a spinner if we're waiting on a request for a new language.
	      appState.trigger('loading', true);
	    }, 200);
	    return Bundles.loadLanguage(
	      appState.get('languageCode'),
	      i18n,
	      {
	        baseUrl: assetBaseUrl,
	        rewrite: assetRewrite
	      }
	    )
	    .then(function () {
	      clearTimeout(timeout);
	      appState.trigger('loading', false);
	    });
	  }

	  return Okta.Router.extend({
	    Events:  Backbone.Events,

	    initialize: function (options) {
	      this.settings = new Settings(_.omit(options, 'el', 'authClient'), { parse: true });
	      this.settings.setAuthClient(options.authClient);

	      if (!options.el) {
	        this.settings.callGlobalError(new Errors.ConfigError(
	          Okta.loc('error.required.el')
	        ));
	      }

	      $('body > div').on('click', function () {
	        // OKTA-69769 Tooltip wont close on iPhone/iPad
	        // Registering a click handler on the first div
	        // allows a tap that falls outside the tooltip
	        // to be registered as a tap by iOS
	        // and then the open tooltip will lose focus and close.
	      });

	      this.appState = new AppState({
	        baseUrl: this.settings.get('baseUrl'),
	        settings: this.settings
	      }, { parse: true });

	      var wrapper = new AuthContainer({appState: this.appState});
	      Okta.$(options.el).append(wrapper.render().$el);
	      this.el = '#okta-sign-in';

	      this.header = new Header({
	        el: this.el,
	        appState: this.appState,
	        settings: this.settings
	      });

	      this.listenTo(this.appState, 'change:transactionError', function (appState, err) {
	        RouterUtil.routeAfterAuthStatusChange(this, err);
	      });

	      this.listenTo(this.appState, 'change:transaction', function (appState, trans) {
	        RouterUtil.routeAfterAuthStatusChange(this, null, trans.data);
	      });

	      this.listenTo(this.appState, 'navigate', function (url) {
	        this.navigate(url, { trigger: true });
	      });
	    },

	    execute: function (cb, args) {
	      // Recovery flow with a token passed through widget settings
	      var recoveryToken = this.settings.get('recoveryToken');
	      if (recoveryToken) {
	        this.settings.unset('recoveryToken');
	        this.navigate(RouterUtil.createRecoveryUrl(recoveryToken), { trigger: true });
	        return;
	      }

	      // Refresh flow with a stateToken passed through widget settings
	      var stateToken = this.settings.get('stateToken');
	      if (stateToken) {
	        this.settings.unset('stateToken');
	        this.navigate(RouterUtil.createRefreshUrl(stateToken), { trigger: true });
	        return;
	      }

	      // Normal flow - we've either navigated to a stateless page, or are
	      // in the middle of an auth flow
	      var trans = this.appState.get('transaction');
	      if ((trans && trans.data) || isStateLessRouteHandler(this, cb)) {
	        cb.apply(this, args);
	        return;
	      }

	      // StateToken cookie exists on page load, and we are on a stateful url
	      if (this.settings.getAuthClient().tx.exists()) {
	        this.navigate(RouterUtil.createRefreshUrl(), { trigger: true });
	        return;
	      }

	      // We've hit a page that requires state, but have no stateToken - redirect
	      // back to primary auth
	      this.navigate('', { trigger: true });
	    },

	    // Overriding the default navigate method to allow the widget consumer
	    // to "turn off" routing - if features.router is false, the browser
	    // location bar will not update when the router navigates
	    navigate: function (fragment, options) {
	      if (this.settings.get('features.router')) {
	        return Okta.Router.prototype.navigate.apply(this, arguments);
	      }
	      if (options && options.trigger) {
	        return Backbone.history.loadUrl(fragment);
	      }
	    },

	    render: function (Controller, options) {
	      options || (options = {});

	      var Beacon = options.Beacon;
	      var controllerOptions = _.extend(
	        { settings: this.settings, appState: this.appState },
	        _.omit(options, 'Beacon')
	      );

	      // Since we have a wrapper view, render our wrapper and use its content
	      // element as our new el.
	      // Note: Render it here because we know dom is ready at this point
	      if (!this.header.rendered()) {
	        this.el = this.header.render().getContentEl();
	      }

	      // If we need to load a language (or apply custom i18n overrides), do
	      // this now and re-run render after it's finished.
	      if (!Bundles.isLoaded(this.appState.get('languageCode'))) {
	        return loadLanguage(
	          this.appState,
	          this.settings.get('i18n'),
	          this.settings.get('assets.baseUrl'),
	          this.settings.get('assets.rewrite')
	        )
	        .then(_.bind(this.render, this, Controller, options))
	        .done();
	      }

	      var oldController = this.controller;
	      this.controller = new Controller(controllerOptions);

	      // Bubble up all controller events
	      this.listenTo(this.controller, 'all', this.trigger);

	      // First run fetchInitialData, in case the next controller needs data
	      // before it's initial render. This will leave the current page in a
	      // loading state.
	      this.controller.fetchInitialData()
	      .then(_.bind(function () {

	        // Beacon transition occurs in parallel to page swap
	        if (!beaconIsAvailable(Beacon, this.settings)) {
	          Beacon = null;
	        }
	        this.header.setBeacon(Beacon, controllerOptions);

	        this.controller.render();

	        if (!oldController) {
	          this.el.append(this.controller.el);
	          this.controller.postRenderAnimation();
	          return;
	        }

	        return Animations.swapPages({
	          $parent: this.el,
	          $oldRoot: oldController.$el,
	          $newRoot: this.controller.$el,
	          dir: oldController.state.get('navigateDir'),
	          ctx: this,
	          success: function () {
	            var flashError = this.appState.get('flashError'),
	                model = this.controller.model;
	            oldController.remove();
	            oldController.$el.remove();
	            this.controller.postRenderAnimation();
	            if (flashError) {
	              model.trigger('error', model, {
	                responseJSON: {
	                  errorSummary: flashError
	                }
	              });
	              this.appState.unset('flashError');
	            }
	          }
	        });

	      }, this))
	      .fail(function () {
	        // OKTA-69665 - if an error occurs in fetchInitialData, we're left in
	        // a state with two active controllers. Therefore, we clean up the
	        // old one. Note: This explicitly handles the invalid token case -
	        // if we get some other type of error which doesn't force a redirect,
	        // we will probably be left in a bad state. I.e. old controller is
	        // dropped and new controller is not rendered.
	        if (oldController) {
	          oldController.remove();
	          oldController.$el.remove();
	        }
	      })
	      .done();

	    },

	    start: function () {
	      var pushState = false;
	      // Support for browser's back button.
	      if (window.addEventListener) {
	        window.addEventListener('popstate', _.bind(function(e) {
	          if (this.controller.back) {
	            e.preventDefault();
	            e.stopImmediatePropagation();
	            this.controller.back();
	          }
	        }, this));
	        pushState = BrowserFeatures.supportsPushState();
	      }
	      Okta.Router.prototype.start.call(this, { pushState: pushState });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {
	  var CAN_REMOVE_BEACON_CLS = 'can-remove-beacon';
	  return Okta.View.extend({
	    className: 'auth-container main-container',
	    id: 'okta-sign-in',
	    attributes: { 'data-se': 'auth-container' },
	    initialize: function (options) {
	      this.listenTo(options.appState, 'change:beaconType', function (model, type) {
	        this.$el.toggleClass(CAN_REMOVE_BEACON_CLS, type === 'security');
	      });
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(105)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController) {

	  return FormController.extend({
	    className: 'refresh-auth-state',

	    Model: {},

	    Form: {
	      noButtonBar: true
	    },

	    preRender: function () {
	      var token = this.options.token;
	      var appState = this.options.appState;
	      this.model.startTransaction(function(authClient) {
	        if (token) {
	          appState.trigger('loading', true);
	          return authClient.tx.resume({
	            stateToken: token
	          });
	        }

	        if (authClient.tx.exists()) {
	          appState.trigger('loading', true);
	          return authClient.tx.resume();
	        }

	        appState.trigger('navigate', '');
	      });
	    },

	    remove: function () {
	      this.options.appState.trigger('loading', false);
	      return FormController.prototype.remove.apply(this, arguments);
	    }

	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint maxcomplexity:8 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9),
	  __webpack_require__(113),
	  __webpack_require__(14),
	  __webpack_require__(40),
	  __webpack_require__(12),
	  __webpack_require__(1)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, Errors, BrowserFeatures, Util, Logger, config) {

	  var DEFAULT_LANGUAGE = 'en';

	  var supportedIdps = ['facebook', 'google', 'linkedin', 'microsoft'],
	      supportedResponseTypes = ['token', 'id_token', 'code'],
	      oauthRedirectTpl = Okta.tpl('{{origin}}');

	  var _ = Okta._,
	      ConfigError = Errors.ConfigError,
	      UnsupportedBrowserError = Errors.UnsupportedBrowserError;

	  var assetBaseUrlTpl = Okta.tpl(
	    'https://ok1static.oktacdn.com/assets/js/sdk/okta-signin-widget/{{version}}'
	  );

	  return Okta.Model.extend({

	    flat: true,
	    authClient: undefined,

	    local: {
	      'baseUrl': ['string', true],
	      'recoveryToken': ['string', false, undefined],
	      'stateToken': ['string', false, undefined],
	      'username' : ['string', false],

	      // Function to transform the username before passing it to the API
	      // for Primary Auth, Forgot Password and Unlock Account.
	      'transformUsername' : ['function', false],

	      // CALLBACKS
	      'globalSuccessFn': 'function',
	      'globalErrorFn': 'function',
	      'processCreds': 'function',

	      // IMAGES
	      'logo': 'string',
	      'logoText' : ['string', false],
	      'helpSupportNumber': 'string',

	      // FEATURES
	      'features.router': ['boolean', true, false],
	      'features.securityImage': ['boolean', true, false],
	      'features.rememberMe': ['boolean', true, true],
	      'features.autoPush': ['boolean', true, false],
	      'features.smsRecovery': ['boolean', true, false],
	      'features.callRecovery': ['boolean', true, false],
	      'features.windowsVerify': ['boolean', true, false],
	      'features.selfServiceUnlock': ['boolean', true, false],
	      'features.multiOptionalFactorEnroll': ['boolean', true, false],
	      'features.preventBrowserFromSavingOktaPassword': ['boolean', true, true],
	      'features.deviceFingerprinting': ['boolean', false, false],
	      'features.hideSignOutLinkInMFA' : ['boolean', false, false],
	      'features.customExpiredPassword': ['boolean', true, false],

	      // I18N
	      'language': ['any', false], // Can be a string or a function
	      'i18n': ['object', false],

	      // ASSETS
	      'assets.baseUrl': ['string', false],
	      'assets.rewrite': {
	        type: 'function',
	        value: _.identity
	      },

	      // OAUTH2
	      'authScheme': ['string', false, 'OAUTH2'],
	      'authParams.display': {
	        type: 'string',
	        values: ['none', 'popup', 'page']
	      },

	      // Note: It shouldn't be necessary to override/pass in this property -
	      // it will be set correctly depending on what the value of display is
	      // and whether we are using Okta or a social IDP.
	      'authParams.responseMode': {
	        type: 'string',
	        values: ['query', 'fragment', 'form_post', 'okta_post_message']
	      },

	      // Can either be a string or an array, i.e.
	      // - Single value: 'id_token', 'token', or 'code'
	      // - Multiple values: ['id_token', 'token']
	      'authParams.responseType': ['any', false, 'id_token'],
	      'authParams.scopes': ['array', false],

	      'authParams.issuer': ['string', false],
	      'authParams.authorizeUrl': ['string', false],
	      'authParams.state': ['string', false],
	      'authParams.nonce': ['string', false],

	      'clientId': 'string',
	      'redirectUri': 'string',
	      'idps': ['array', false, []],
	      'idpDisplay': {
	        type: 'string',
	        values: ['PRIMARY', 'SECONDARY'],
	        value: 'SECONDARY'
	      },
	      'oAuthTimeout': ['number', false],

	      // HELP LINKS
	      'helpLinks.help': 'string',
	      'helpLinks.forgotPassword': 'string',
	      'helpLinks.unlock': 'string',
	      'helpLinks.custom': 'array'
	    },

	    derived: {
	      supportedLanguages: {
	        deps: ['i18n'],
	        fn: function (i18n) {
	          // Developers can pass in their own languages
	          return _.union(config.supportedLanguages, _.keys(i18n));
	        },
	        cache: true
	      },
	      languageCode: {
	        deps: ['language', 'supportedLanguages'],
	        fn: function (language, supportedLanguages) {
	          var userLanguages = BrowserFeatures.getUserLanguages(),
	              preferred = _.clone(userLanguages),
	              supportedLowerCase = Util.toLower(supportedLanguages),
	              expanded;

	          // Any developer defined "language" takes highest priority:
	          // As a string, i.e. 'en', 'ja', 'zh-CN'
	          if (_.isString(language)) {
	            preferred.unshift(language);
	          }
	          // As a callback function, which is passed the list of supported
	          // languages and detected user languages. This function must return
	          // a languageCode, i.e. 'en', 'ja', 'zh-CN'
	          else if (_.isFunction(language)) {
	            preferred.unshift(language(supportedLanguages, userLanguages));
	          }

	          // Add english as the default, and expand to include any language
	          // codes that do not include region, dialect, etc.
	          preferred.push(DEFAULT_LANGUAGE);
	          expanded = Util.toLower(Util.expandLanguages(preferred));

	          // Perform a case insensitive search - this is necessary in the case
	          // of browsers like Safari
	          var i, supportedPos;
	          for (i = 0; i < expanded.length; i++) {
	            supportedPos = supportedLowerCase.indexOf(expanded[i]);
	            if (supportedPos > -1) {
	              return supportedLanguages[supportedPos];
	            }
	          }
	        }
	      },
	      oauth2Enabled: {
	        deps: ['clientId', 'authScheme', 'authParams.responseType'],
	        fn: function (clientId, authScheme, responseType) {
	          if (!clientId) {
	            return false;
	          }
	          if (authScheme.toLowerCase() !== 'oauth2') {
	            return false;
	          }
	          var responseTypes = _.isArray(responseType) ? responseType : [responseType];
	          return _.intersection(responseTypes, supportedResponseTypes).length > 0;
	        },
	        cache: true
	      },
	      // Redirect Uri to provide in the oauth API
	      oauthRedirectUri: {
	        deps: ['redirectUri'],
	        fn: function (redirectUri) {
	          if (redirectUri) {
	            return redirectUri;
	          }

	          var origin = window.location.origin;
	          // IE8
	          if (!origin) {
	            var href = window.location.href;
	            var path = window.location.pathname;
	            if (path !== '') {
	              origin = href.substring(0, href.lastIndexOf(path));
	            }
	          }

	          return oauthRedirectTpl({
	            origin: origin
	          });
	        }
	      },
	      // filters the idps passed into the widget to include only the ones we support.
	      configuredSocialIdps: {
	        deps: ['idps'],
	        fn: function (idps) {
	          return _.filter(idps, function (idp) {
	            return _.contains(supportedIdps, idp.type.toLowerCase());
	          });
	        },
	        cache: true
	      },
	      // checks if there are any valid configured idps.
	      socialAuthConfigured: {
	        deps: ['configuredSocialIdps'],
	        fn: function (idps) {
	          return !_.isEmpty(idps);
	        },
	        cache: true
	      },
	      // social auth buttons order - 'above'/'below' the primary auth form (boolean)
	      socialAuthPositionTop: {
	        deps: ['socialAuthConfigured', 'idpDisplay'],
	        fn: function (socialAuthConfigured, idpDisplay) {
	          return !!(socialAuthConfigured && idpDisplay.toUpperCase() === 'PRIMARY');
	        },
	        cache: true
	      }
	    },

	    initialize: function (options) {
	      if (!options.baseUrl) {
	        this.callGlobalError(new ConfigError(Okta.loc('error.required.baseUrl')));
	      }
	      else if (!options.globalSuccessFn) {
	        this.callGlobalError(new ConfigError(Okta.loc('error.required.success')));
	      }
	      else if (BrowserFeatures.corsIsNotSupported()) {
	        this.callGlobalError(new UnsupportedBrowserError(Okta.loc('error.unsupported.cors')));
	      }
	    },

	    setAuthClient: function (authClient) {
	      this.authClient = authClient;
	    },

	    getAuthClient: function () {
	      return this.authClient;
	    },

	    set: function () {
	      try {
	        return Okta.Model.prototype.set.apply(this, arguments);
	      }
	      catch (e) {
	        var message = e.message ? e.message : e;
	        this.callGlobalError(new ConfigError(message));
	      }
	    },

	    // Invokes the global success function. This should only be called on a
	    // terminal part of the code (i.e. authStatus SUCCESS or after sending
	    // a recovery email)
	    callGlobalSuccess: function (status, data) {
	      // Defer this to ensure that our functions have rendered completely
	      // before invoking their function
	      var res = _.extend(data, { status: status });
	      _.defer(_.partial(this.get('globalSuccessFn'), res));
	    },

	    // Invokes the global error function. This should only be called on non
	    // recoverable errors (i.e. configuration errors, browser unsupported
	    // errors, etc)
	    callGlobalError: function (err) {
	      // Note: Must use "this.options.globalErrorFn" when they've passed invalid
	      // arguments - globalErrorFn will not have been set yet
	      var globalErrorFn = this.get('globalErrorFn') || this.options.globalErrorFn;
	      if (globalErrorFn) {
	        globalErrorFn(err);
	      }
	      else {
	        // Only throw the error if they have not registered a globalErrorFn
	        throw err;
	      }
	    },

	    // Get the username by applying the transform function if it exists.
	    transformUsername: function (username, operation) {
	      var transformFn = this.get('transformUsername');
	      if (transformFn && _.isFunction(transformFn)) {
	        return transformFn(username, operation);
	      }
	      return username;
	    },

	    processCreds: function (creds) {
	      var processCreds = this.get('processCreds');
	      return Q.Promise(function (resolve) {
	        if (!_.isFunction(processCreds)) {
	          resolve();
	        }
	        else if (processCreds.length === 2) {
	          processCreds(creds, resolve);
	        }
	        else {
	          processCreds(creds);
	          resolve();
	        }
	      });
	    },

	    // Use the parse function to transform config options to the standard
	    // settings we currently support. This is a good place to deprecate old
	    // option formats.
	    parse: function (options) {
	      if (options.authParams && options.authParams.scope) {
	        Logger.deprecate('Use "scopes" instead of "scope"');
	        options.authParams.scopes = options.authParams.scope;
	        delete options.authParams.scope;
	      }

	      if (options.labels || options.country) {
	        Logger.deprecate('Use "i18n" instead of "labels" and "country"');
	        var overrides = options.labels || {};
	        _.each(options.country, function (val, key) {
	          overrides['country.' + key] = val;
	        });
	        // Old behavior is to treat the override as a global override, so we
	        // need to add these overrides to each language
	        options.i18n = {};
	        _.each(config.supportedLanguages, function (language) {
	          options.i18n[language] = overrides;
	        });
	        delete options.labels;
	        delete options.country;
	      }

	      // Default the assets.baseUrl to the cdn, or remove any trailing slashes
	      if (!options.assets) {
	        options.assets = {};
	      }
	      var abu = options.assets.baseUrl;
	      if (!abu) {
	        options.assets.baseUrl = assetBaseUrlTpl({ version: config.version });
	      }
	      else if (abu[abu.length - 1] === '/') {
	        options.assets.baseUrl = abu.substring(0, abu.length - 1);
	      }

	      return options;
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint maxcomplexity:9*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(122),
	  __webpack_require__(123)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Animations, LoadingBeacon) {

	  var NO_BEACON_CLS = 'no-beacon';
	  var LOADING_BEACON_CLS = 'beacon-small beacon-loading';

	  function isLoadingBeacon (beacon) {
	    return beacon && beacon.equals(LoadingBeacon);
	  }

	  function removeBeacon (view) {
	    // There are some timing issues with removing beacons (i.e. the case of
	    // transitioning from loadingBeacon -> loadingBeacon)
	    if (!view.currentBeacon) {
	      return;
	    }
	    view.currentBeacon.remove();
	    view.currentBeacon = null;
	  }

	  function addBeacon (view, NextBeacon, selector, options) {
	    view.add(NextBeacon, {
	      selector: selector,
	      options: options
	    });
	    view.currentBeacon = view.first();
	  }

	  function typeOfTransition (currentBeacon, NextBeacon, options) {
	    if (!currentBeacon && !NextBeacon) {
	      return 'none';
	    }
	    // Show Loading beacon
	    if (!currentBeacon && options.loading) {
	      return 'load';
	    }
	    // Swap/Hide Loading beacon
	    if (currentBeacon && isLoadingBeacon(currentBeacon)) {
	      return NextBeacon ? 'swap' : 'unload';
	    }
	    if (currentBeacon && currentBeacon.equals(NextBeacon, options)) {
	      return 'same';
	    }
	    if (!currentBeacon && NextBeacon) {
	      return 'add';
	    }
	    if (currentBeacon && !NextBeacon) {
	      return 'remove';
	    }
	    if (currentBeacon instanceof NextBeacon) {
	      return 'fade';
	    }
	    // If none of the above
	    // then we are changing the type of beacon
	    // ex. from SecurityBeacon to FactorBeacon
	    return 'swap';
	  }

	  return Okta.View.extend({

	    currentBeacon: null,

	    template: '\
	      <div class="okta-sign-in-header auth-header">\
	        {{#if logo}}\
	        <img src="{{logo}}" class="auth-org-logo" alt="{{logoText}}"/>\
	        {{/if}}\
	        <div data-type="beacon-container" class="beacon-container"></div>\
	      </div>\
	      <div class="auth-content"><div class="auth-content-inner"></div></div>\
	    ',

	    // Attach a 'no-beacon' class if the security image feature
	    // is not passed in to prevent the beacon from jumping.
	    initialize: function (options) {
	      if (!options.settings.get('features.securityImage')) {
	        this.$el.addClass(NO_BEACON_CLS);
	        // To show/hide the spinner when there is no security image,
	        // listen to the appState's loading/removeLoading events.
	        this.listenTo(options.appState, 'loading', this.setLoadingBeacon);
	        this.listenTo(options.appState, 'removeLoading', this.removeLoadingBeacon);
	      }
	    },

	    /* jshint maxcomplexity:false */
	    setBeacon: function (NextBeacon, options) {
	      var selector = '[data-type="beacon-container"]',
	          container = this.$(selector),
	          transition = typeOfTransition(this.currentBeacon, NextBeacon, options),
	          self = this;

	      switch (transition) {
	        case 'none':
	          this.$el.addClass(NO_BEACON_CLS);
	          return;
	        case 'same':
	          return;
	        case 'add':
	          this.$el.removeClass(NO_BEACON_CLS);
	          addBeacon(this, NextBeacon, selector, options);
	          return Animations.explode(container);
	        case 'remove':
	          this.$el.addClass(NO_BEACON_CLS);
	          return Animations.implode(container)
	          .then(function () {
	            removeBeacon(self);
	          })
	          .done();
	        case 'fade':
	          // Other transitions are performed on the beacon container,
	          // but this transition is on the content inside the beacon.
	          // For a SecurityBeacon the username change will update the
	          // AppState and trigger an transition to a new Becon
	          // Since there is no url change this method is not called.
	          // For a FactorBeacon a page refresh has occurred
	          // so we execute the beacon's own transition method.
	          if (!this.currentBeacon.fadeOut) {
	            throw new Error('The current beacon is missing the "fadeOut" method');
	          }
	          options.animate = true;
	          return this.currentBeacon.fadeOut()
	          .then(function () {
	            removeBeacon(self);
	            addBeacon(self, NextBeacon, selector, options);
	          })
	          .done();
	        case 'swap':
	          return Animations.swapBeacons({
	            $el: container,
	            swap: function () {
	              var isLoading = isLoadingBeacon(self.currentBeacon);
	              // Order of these calls is important for -
	              // loader --> security/factor beacon swap.
	              removeBeacon(self);
	              if (isLoading) {
	                container.removeClass(LOADING_BEACON_CLS);
	                self.$el.removeClass(NO_BEACON_CLS);
	              }
	              addBeacon(self, NextBeacon, selector, options);
	            }
	          })
	          .done();
	        case 'load':
	          // Show the loading beacon. Add a couple of classes
	          // before triggering the add beacon code.
	          container.addClass(LOADING_BEACON_CLS);
	          addBeacon(self, NextBeacon, selector, options);
	          return Animations.explode(container);
	        case 'unload':
	          // Hide the loading beacon.
	          return this.removeLoadingBeacon();
	        default:
	          throw new Error('the "' + transition + '" is not recognized');
	      }
	    },

	    // Show the loading beacon when the security image feature is not enabled.
	    setLoadingBeacon: function (isLoading) {
	      if (!isLoading || isLoadingBeacon(this.currentBeacon)) {
	        return;
	      }
	      this.setBeacon(LoadingBeacon, { loading: true });
	    },

	    // Hide the beacon on primary auth failure. On primary auth success, setBeacon does this job.
	    removeLoadingBeacon: function () {
	      var self = this,
	          container = this.$('[data-type="beacon-container"]');

	      return Animations.implode(container)
	      .then(function () {
	        removeBeacon(self);
	        container.removeClass(LOADING_BEACON_CLS);
	      })
	      .done();
	    },

	    getTemplateData: function () {
	      return this.settings.toJSON({ verbose: true });
	    },

	    getContentEl: function () {
	      return this.$('.auth-content-inner');
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Q, Enums) {

	  var SWAP_PAGE_TIME = 200;

	  var fn = {};

	  function zoom ($el, start, finish) {
	    var deferred = Q.defer();
	    $el.animate({
	      'text-indent': 1
	    }, {
	      duration: 200,
	      easing: 'swing',
	      step: function (now, fx) {
	        fx.start = start;
	        fx.end = finish;
	        $el.css('transform', 'scale(' + now + ', ' + now + ')');
	      },
	      always: function () {
	        deferred.resolve($el);
	      }
	    });
	    return deferred.promise;
	  }

	  function rotate ($el, start, finish) {
	    var deferred = Q.defer();
	    $el.animate({
	      'text-indent': 1
	    }, {
	      duration: 150,
	      easing: 'swing',
	      step: function (now, fx) {
	        fx.start = start;
	        fx.end = finish;
	        $el.css('transform', 'rotate(' + now + 'deg)');
	      },
	      always: function () {
	        deferred.resolve($el);
	      }
	    });
	    return deferred.promise;
	  }

	  // Note: It is necessary to pass in a success callback because we must
	  // remove the old dom node (and controller) in the same tick of the event
	  // loop. Waiting for "then" results in a glitchy animation.
	  fn.swapPages = function (options) {
	    var deferred = Q.defer();
	    var $parent = options.$parent;
	    var $oldRoot = options.$oldRoot;
	    var $newRoot = options.$newRoot;
	    var success = options.success;
	    var ctx = options.ctx;
	    var directionClassName = 'transition-from-right';

	    if (options.dir && options.dir === Enums.DIRECTION_BACK) {
	      directionClassName = 'transition-from-left';
	    }

	    $newRoot.addClass(directionClassName);
	    $parent.append($newRoot);

	    $parent.addClass('animation-container-overflow');
	    $newRoot.animate(
	      { left: '0px', top: '0px', opacity: 1 },
	      SWAP_PAGE_TIME,
	      function () {
	        $parent.removeClass('animation-container-overflow');
	        $newRoot.removeClass(directionClassName);
	        $newRoot.removeAttr('style');
	        success.call(ctx);
	        deferred.resolve();
	      }
	    );

	    $oldRoot.animate(
	      { height: $newRoot.height(), opacity: 0 },
	      SWAP_PAGE_TIME * 0.8
	    );

	    return deferred.promise;
	  };

	  fn.swapBeacons = function (options) {
	    var $el = options.$el,
	        swap = options.swap,
	        ctx = options.ctx;

	    return this.implode($el)
	    .then(function () {
	      swap.call(ctx);
	      return $el;
	    })
	    .then(this.explode);
	  };

	  fn.explode = function ($el) {
	    return zoom($el, 0, 1); //zoom in
	  };

	  fn.implode = function ($el) {
	    return zoom($el, 1, 0); //zoom out
	  };

	  fn.radialProgressBar = function (options) {
	    var radialProgressBar = options.$el,
	        swap = options.swap,
	        circles = radialProgressBar.children();

	    return rotate(circles, 0, 180)
	    .then(function () {
	      radialProgressBar.css({'clip': 'auto'});
	    })
	    .then(function () {
	      var leftHalf = circles.eq(0);
	      swap();
	      return rotate(leftHalf, 180, 360);
	    })
	    .then(function () {
	      //reset values to initial state
	      radialProgressBar.css({'clip': 'rect(0px, 96px, 96px, 48px)'});
	      circles.css({
	        'transform': 'rotate(0deg)',
	        'text-indent': '1px'
	      });
	    });
	  };

	  return fn;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  return Okta.View.extend({

	    template: '\
	      <div class="beacon-blank"/>\
	      <div class="bg-helper auth-beacon auth-beacon-security" data-se="loading-beacon">\
	      <div class="okta-sign-in-beacon-border auth-beacon-border js-auth-beacon-border"/>\
	      </div>\
	    ',

	    equals: function (Beacon) {
	      return Beacon && this instanceof Beacon;
	    }

	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(122)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Animations) {

	  var _ = Okta._,
	      $ = Okta.$;

	  function setBackgroundImage (el, appState) {
	    // NOTE: The imgSrc is returned by the server so that every
	    // user has a unique image. However new and undefined user states
	    // are hard coded into the css and the value returned by the server
	    // is ignored.
	    var imgSrc = appState.get('securityImage'),
	        imgDescription = appState.get('securityImageDescription'),
	        isUndefinedUser = appState.get('isUndefinedUser'),
	        isNewUser = appState.get('isNewUser'),
	        isSecurityImage = !isUndefinedUser && !isNewUser;

	    el.css('background-image', '');
	    el.removeClass('new-user undefined-user');
	    if (isNewUser) {
	      el.addClass('new-user');
	      return;
	    }
	    if (isUndefinedUser) {
	      el.addClass('undefined-user');
	      return;
	    }
	    if (isSecurityImage) {
	      // TODO: Newer versions of qtip will remove aria-describedby on their own when destroy() is called.
	      el.removeAttr('aria-describedby');
	      el.find('.accessibility-text').text(imgDescription);
	      el.css('background-image', 'url(' + _.escape(imgSrc) + ')');
	      return;
	    }
	  }

	  function antiPhishingMessage (image, host, shown) {
	    // Show the message that the user has not logged in from this device before.
	    image.qtip({
	      prerender: true,
	      content: {
	        text: Okta.loc('primaryauth.newUser.tooltip', 'login', [_.escape(host)]),
	        button: Okta.loc('primaryauth.newUser.tooltip.close', 'login')
	      },
	      style: {
	        classes: 'okta-security-image-tooltip security-image-qtip qtip-custom qtip-shadow qtip-rounded',
	        tip: {height: 12, width: 16}
	      },
	      position: {
	        my: 'top center',
	        at: 'bottom center',
	        adjust: {method: 'flip', y: -22},
	        viewport: $('body')
	      },
	      hide: {event: false, fixed: true},
	      show: {event: false, delay: 200}
	    });
	    image.qtip('toggle', shown);
	  }

	  function updateSecurityImage($el, appState, animate) {
	    var image = $el.find('.auth-beacon-security'),
	        border = $el.find('.js-auth-beacon-border'),
	        hasBorder = !appState.get('isUndefinedUser'),
	        hasAntiPhishing = appState.get('isNewUser'),
	        radialProgressBar = $el.find('.radial-progress-bar'),
	        host = appState.get('baseUrl').match(/https?:\/\/(.[^\/]+)/)[1],
	        duration = 200;
	    if (!animate) {
	      // Do not animate the security beacon
	      // This occurs when initializing the form
	      setBackgroundImage(image, appState);
	      border.toggleClass('auth-beacon-border', hasBorder);
	      return;
	    }
	    // Animate loading the security beacon
	    if (!hasBorder) {
	      // This occurrs when appState username is blank
	      // we do not yet know if the user is recognized
	      image.qtip('destroy');
	      image.fadeOut(duration, function () {
	        setBackgroundImage(image, appState);
	        border.removeClass('auth-beacon-border');
	        image.fadeIn(duration);
	      });
	    } else {
	      // Animate loading the security beacon with a loading bar for the border
	      // This occurrs when the username has been checked against Okta.
	      image.qtip('destroy');
	      border.removeClass('auth-beacon-border');
	      Animations.radialProgressBar({
	        $el: radialProgressBar,
	        swap: function () {
	          image.fadeOut(duration, function () {
	            setBackgroundImage(image, appState);
	            image.fadeIn(duration);
	          });
	        }
	      }).then(function () {
	        border.addClass('auth-beacon-border');
	      }).then(function () {
	        antiPhishingMessage(image, host, hasAntiPhishing);
	      });
	    }
	  }

	  return Okta.View.extend({

	    template: '\
	    <div class="beacon-blank">\
	      <div class="radial-progress-bar">\
	        <div class="circle left"></div>\
	        <div class="circle right"></div>\
	      </div>\
	    </div>\
	    <div aria-live="polite" role="image" class="bg-helper auth-beacon auth-beacon-security" data-se="security-beacon">\
	      <span class="accessibility-text"></span>\
	      <div class="okta-sign-in-beacon-border auth-beacon-border js-auth-beacon-border">\
	      </div>\
	    </div>\
	    ',
	    className: 'js-security-beacon',

	    initialize: function (options) {
	      this.update = _.partial(updateSecurityImage, this.$el, options.appState);
	      this.listenTo(options.appState, 'change:securityImage', this.update);
	      this.listenTo(options.appState, 'loading', function (isLoading) {
	        this.$el.toggleClass('beacon-loading', isLoading);
	        this.removeAntiPhishingMessage();
	      });
	      this.options.appState.set('beaconType', 'security');

	      this.listenTo(options.appState, 'navigate', this.removeAntiPhishingMessage);
	    },

	    postRender: function () {
	      this.update(false);
	    },

	    equals: function (Beacon) {
	      return Beacon && this instanceof Beacon;
	    },

	    removeAntiPhishingMessage: function () {
	      var image = this.$el.find('.auth-beacon-security');
	      image.qtip('destroy');
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint newcap:false, camelcase:false */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9),
	  __webpack_require__(126),
	  __webpack_require__(14),
	  __webpack_require__(113)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, Factor, BrowserFeatures, Errors) {

	  // Keep track of stateMachine with this special model. Some reasons to not
	  // keep it generic:
	  // 1. We know exactly what we're using appState for by requiring props
	  // 2. Can have some derived functions to help us translate the lastAuthRes

	  var _ = Okta._;
	  var $ = Okta.$;
	  var compile = Okta.Handlebars.compile;

	  var USER_NOT_SEEN_ON_DEVICE = '/img/security/unknown.png';
	  var UNDEFINED_USER = '/img/security/default.png';
	  var NEW_USER = '/img/security/unknown-device.png';
	  var NEW_USER_IMAGE_DESCRIPTION = '';
	  var UNDEFINED_USER_IMAGE_DESCRIPTION = '';
	  var UNKNOWN_IMAGE_DESCRIPTION = '';

	  var securityImageUrlTpl = compile('{{baseUrl}}/login/getimage?username={{username}}');

	  function getSecurityImage(baseUrl, username) {
	    var url = securityImageUrlTpl({ baseUrl: baseUrl, username: username });

	    // When the username is empty, we want to show the default image.
	    if (_.isEmpty(username) || _.isUndefined(username)) {
	      return Q({
	        'securityImage': UNDEFINED_USER,
	        'securityImageDescription': UNDEFINED_USER_IMAGE_DESCRIPTION
	      });
	    }

	    return Q($.get(url)).then(function (res) {
	      if (res.pwdImg === USER_NOT_SEEN_ON_DEVICE) {
	        // When we get an unknown.png security image from OKTA,
	        // we want to show the unknown-device security image.
	        // We are mapping the server's img url to a new one because
	        // we still need to support the original login page.
	        return {
	          'securityImage': NEW_USER,
	          'securityImageDescription': NEW_USER_IMAGE_DESCRIPTION
	        };
	      }
	      return {
	        'securityImage': res.pwdImg,
	        'securityImageDescription':
	            res.imageDescription || UNKNOWN_IMAGE_DESCRIPTION
	      };
	    });
	  }

	  function getMinutesString(factorLifetimeInMinutes) {
	    if (factorLifetimeInMinutes > 60 && factorLifetimeInMinutes <= 1440) {
	      var lifetimeInHours = (factorLifetimeInMinutes / 60);
	      return Okta.loc('hours', 'login', [lifetimeInHours]);
	    } else if (factorLifetimeInMinutes > 1440) {
	      var lifetimeInDays = (factorLifetimeInMinutes / 1440);
	      return Okta.loc('days', 'login', [lifetimeInDays]);
	    }
	    //Use minutes as the time unit by default
	    if (factorLifetimeInMinutes === 1) {
	      return Okta.loc('minutes.oneMinute', 'login');
	    }
	    return Okta.loc('minutes', 'login', [factorLifetimeInMinutes]);
	  }

	  return Okta.Model.extend({

	    initialize: function () {
	      // Handle this in initialize (as opposed to a derived property) because
	      // the operation is asynchronous
	      if (this.settings.get('features.securityImage')) {
	        var self = this;
	        this.listenTo(this, 'change:username', function (model, username) {
	          getSecurityImage(this.get('baseUrl'), username)
	          .then(function (image) {
	            model.set('securityImage', image.securityImage);
	            model.set(
	              'securityImageDescription', image.securityImageDescription);
	          })
	          .fail(function (jqXhr) {
	            // Only notify the consumer on a CORS error
	            if (BrowserFeatures.corsIsNotEnabled(jqXhr)) {
	              self.settings.callGlobalError(new Errors.UnsupportedBrowserError(
	                Okta.loc('error.enabled.cors')
	              ));
	            }
	            else {
	              throw jqXhr;
	            }
	          })
	          .done();
	        });
	      }
	    },

	    local: {
	      baseUrl: 'string',
	      lastAuthResponse: ['object', true, {}],
	      transaction: 'object',
	      transactionError: 'object',
	      username: 'string',
	      factors: 'object',
	      policy: 'object',
	      securityImage: ['string', true, UNDEFINED_USER],
	      securityImageDescription:
	          ['string', true, UNDEFINED_USER_IMAGE_DESCRIPTION],
	      userCountryCode: 'string',
	      userPhoneNumber: 'string',
	      factorActivationType: 'string',
	      flashError: 'object',
	      beaconType: 'string',

	      // Note: languageCode is special in that it is shared between Settings
	      // and AppState. Settings is the *configured* language, and is static.
	      // AppState is the dynamic language state - it can be changed via a
	      // language picker, etc.
	      languageCode: ['string', true]
	    },

	    setAuthResponse: function (res) {
	      // Because of MFA_CHALLENGE (i.e. DUO), we need to remember factors
	      // across auth responses. Not doing this, for example, results in being
	      // unable to switch away from the duo factor dropdown.
	      var self = this;
	      if (res._embedded && res._embedded.policy) {
	        this.set('policy', res._embedded.policy);
	      }
	      if (res._embedded && res._embedded.factors) {
	        var settings = this.settings;
	        var factors = _.map(res._embedded.factors, function (factor) {
	          factor.settings = settings;
	          factor.appState = self;
	          return factor;
	        });
	        this.set('factors', new Factor.Collection(factors, { parse: true }));
	      }
	      this.set('lastAuthResponse', res);
	    },

	    derived: {
	      'isSuccessResponse': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'SUCCESS';
	        }
	      },
	      'isMfaRequired': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'MFA_REQUIRED';
	        }
	      },
	      'isMfaEnroll': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'MFA_ENROLL';
	        }
	      },
	      'isMfaChallenge': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'MFA_CHALLENGE';
	        }
	      },
	      'isMfaRejectedByUser': {
	        // MFA failures are usually error responses
	        // except in the case of Okta Push, when a
	        // user clicks 'deny' on his phone.
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.factorResult === 'REJECTED';
	        }
	      },
	      'isMfaTimeout': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.factorResult === 'TIMEOUT';
	        }
	      },
	      'isMfaEnrollActivate': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'MFA_ENROLL_ACTIVATE';
	        }
	      },
	      'isWaitingForActivation': {
	        deps: ['isMfaEnrollActivate', 'lastAuthResponse'],
	        fn: function (isMfaEnrollActivate, res) {
	          return isMfaEnrollActivate && res.factorResult === 'WAITING';
	        }
	      },
	      'hasMfaRequiredOptions': {
	        deps: ['lastAuthResponse', 'factors'],
	        fn: function (res, factors) {
	          if (res.status !== 'MFA_REQUIRED' && res.status !== 'MFA_CHALLENGE') {
	            return false;
	          }
	          return factors && factors.length > 1;
	        }
	      },
	      'userId': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.user) {
	            return null;
	          }
	          return res._embedded.user.id;
	        }
	      },
	      'isPwdExpiringSoon': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.status === 'PASSWORD_WARN';
	        }
	      },
	      'passwordExpireDays': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.policy || !res._embedded.policy.expiration) {
	            return null;
	          }
	          return res._embedded.policy.expiration.passwordExpireDays;
	        }
	      },
	      'isPwdManagedByOkta': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._links || !res._links.next || !res._links.next.title) {
	            return true;
	          }
	          return false;
	        }
	      },
	      'passwordExpiredWebsiteName': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._links || !res._links.next || !res._links.next.title) {
	            return null;
	          }
	          return res._links.next.title;
	        }
	      },
	      'passwordExpiredLinkUrl': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._links || !res._links.next || !res._links.next.title || !res._links.next.href) {
	            return null;
	          }
	          return res._links.next.href;
	        }
	      },
	      'recoveryType': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.recoveryType;
	        }
	      },
	      'factorType': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          return res.factorType;
	        }
	      },
	      'factor': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.factor) {
	            return null;
	          }
	          return res._embedded.factor;
	        }
	      },
	      'activatedFactorId': {
	        deps: ['factor'],
	        fn: function (factor) {
	          return factor ? factor.id : null;
	        }
	      },
	      'activatedFactorType': {
	        deps: ['factor'],
	        fn: function (factor) {
	          return factor ? factor.factorType : null;
	        }
	      },
	      'activatedFactorProvider': {
	        deps: ['factor'],
	        fn: function (factor) {
	          return factor ? factor.provider : null;
	        }
	      },
	      'qrcode': {
	        deps: ['factor'],
	        fn: function (factor) {
	          try {
	            return factor._embedded.activation._links.qrcode.href;
	          } catch (err) {
	            return null;
	          }
	        }
	      },
	      'activationSendLinks': {
	        deps: ['factor'],
	        fn: function (factor) {
	          var sendLinks;
	          try {
	            sendLinks = factor._embedded.activation._links.send;
	          } catch (err) {
	            sendLinks = [];
	          }
	          return sendLinks;
	        }
	      },
	      'textActivationLinkUrl': {
	        deps: ['activationSendLinks'],
	        fn: function (activationSendLinks) {
	          var item = _.findWhere(activationSendLinks, {name: 'sms'});
	          return item ? item.href : null;
	        }
	      },
	      'emailActivationLinkUrl': {
	        deps: ['activationSendLinks'],
	        fn: function (activationSendLinks) {
	          var item = _.findWhere(activationSendLinks, {name: 'email'});
	          return item ? item.href : null;
	        }
	      },
	      'sharedSecret': {
	        deps: ['factor'],
	        fn: function (factor) {
	          try {
	            return factor._embedded.activation.sharedSecret;
	          } catch (err) {
	            return null;
	          }
	        }
	      },
	      'duoEnrollActivation': {
	        deps: ['factor'],
	        fn: function (factor) {
	          if (!factor || !factor._embedded || !factor._embedded.activation) {
	            return null;
	          }
	          return factor._embedded.activation;
	        }
	      },
	      'prevLink': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (res._links && res._links.prev) {
	            return res._links.prev.href;
	          }
	          return null;
	        }
	      },
	      'user': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.user) {
	            return null;
	          }
	          return res._embedded.user;
	        }
	      },
	      'recoveryQuestion': {
	        deps: ['user'],
	        fn: function (user) {
	          if (!user || !user.recovery_question) {
	            return null;
	          }
	          return user.recovery_question.question;
	        }
	      },
	      'userProfile': {
	        deps: ['user'],
	        fn: function (user) {
	          if (!user || !user.profile) {
	            return null;
	          }
	          return user.profile;
	        }
	      },
	      'userEmail': {
	        deps: ['userProfile'],
	        fn: function (userProfile) {
	          if (!userProfile || !userProfile.login) {
	            return null;
	          }
	          return userProfile.login;
	        }
	      },
	      'userFullName': {
	        deps: ['userProfile'],
	        fn: function (userProfile) {
	          if (!userProfile || (!userProfile.firstName && !userProfile.lastName)) {
	            return '';
	          }
	          return userProfile.firstName + ' ' + userProfile.lastName;
	        }
	      },
	      'hasExistingPhones': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.factors) {
	            return false;
	          }
	          var factors = res._embedded.factors;
	          var factor = _.findWhere(factors, {factorType: 'sms', provider: 'OKTA'});
	          if (!factor || !factor._embedded) {
	            return false;
	          }

	          return !!factor._embedded.phones.length;
	        }
	      },
	      'hasExistingPhonesForCall': {
	        deps: ['lastAuthResponse'],
	        fn: function (res) {
	          if (!res._embedded || !res._embedded.factors) {
	            return false;
	          }
	          var factors = res._embedded.factors;
	          var factor = _.findWhere(factors, {factorType: 'call', provider: 'OKTA'});
	          if (!factor || !factor._embedded) {
	            return false;
	          }

	          return !!factor._embedded.phones.length;
	        }
	      },
	      'isUndefinedUser': {
	        deps: ['securityImage'],
	        fn: function (securityImage) {
	          return (securityImage === UNDEFINED_USER);
	        }
	      },
	      'isNewUser': {
	        deps: ['securityImage'],
	        fn: function (securityImage) {
	          return (securityImage === NEW_USER);
	        }
	      },
	      'allowRememberDevice': {
	        deps: ['policy'],
	        fn: function (policy) {
	          return policy && policy.allowRememberDevice;
	        }
	      },
	      'rememberDeviceLabel': {
	        deps: ['policy'],
	        fn: function (policy) {
	          if (policy && policy.rememberDeviceLifetimeInMinutes > 0) {
	            var timeString = getMinutesString(policy.rememberDeviceLifetimeInMinutes);
	            return Okta.loc('rememberDevice.timebased', 'login', [timeString]);
	          } else if (policy && policy.rememberDeviceLifetimeInMinutes === 0) {
	            return Okta.loc('rememberDevice.devicebased', 'login');
	          }
	          return Okta.loc('rememberDevice', 'login');
	        }
	      },
	      'rememberDeviceByDefault': {
	        deps: ['policy'],
	        fn: function (policy) {
	          return policy && policy.rememberDeviceByDefault;
	        }
	      }
	    },

	    parse: function (options) {
	      this.settings = options.settings;
	      return _.extend(
	        _.omit(options, 'settings'),
	        { languageCode: this.settings.get('languageCode' )}
	      );
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* jshint maxstatements: 18 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9),
	  __webpack_require__(104),
	  __webpack_require__(108)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, factorUtil, BaseLoginModel) {
	  var _ = Okta._;

	  // Note: Keep-alive is set to 5 seconds - using 5 seconds here will result
	  // in network connection lost errors in Safari and IE.
	  var PUSH_INTERVAL = 6000;

	  var Factor = BaseLoginModel.extend({
	    extraProperties: true,
	    flat: false,

	    props: {
	      id: 'string',
	      factorType: {
	        type: 'string',
	        values: [
	          'sms',
	          'call',
	          'token',
	          'token:software:totp',
	          'token:hardware',
	          'question',
	          'push',
	          'u2f'
	        ]
	      },
	      provider: {
	        type: 'string',
	        values: [
	          'OKTA',
	          'RSA',
	          'DEL_OATH',
	          'SYMANTEC',
	          'GOOGLE',
	          'YUBICO',
	          'FIDO'
	        ]
	      },
	      enrollment: {
	        type: 'string',
	        values: [
	          'OPTIONAL',
	          'REQUIRED'
	        ]
	      },
	      status: {
	        type: 'string',
	        values: [
	          'NOT_SETUP',
	          'ACTIVE'
	        ]
	      },
	      profile: ['object'],
	      vendorName: 'string'
	    },

	    local: {
	      'answer': 'string',
	      'backupFactor': 'object',
	      'showAnswer': 'boolean',
	      'rememberDevice': 'boolean',
	      'autoPush': ['boolean', true, false]
	    },

	    derived: {
	      isOktaFactor: {
	        deps: ['provider'],
	        fn: function (provider) {
	          return provider === 'OKTA';
	        }
	      },
	      factorName: {
	        deps: ['provider', 'factorType'],
	        fn: factorUtil.getFactorName
	      },
	      factorLabel: {
	        deps: ['provider', 'factorType', 'vendorName'],
	        fn: function (provider, factorType, vendorName) {
	          if (provider === 'DEL_OATH') {
	            return vendorName;
	          }
	          return factorUtil.getFactorLabel(provider, factorType);
	        }
	      },
	      factorDescription: {
	        deps: ['provider', 'factorType'],
	        fn: factorUtil.getFactorDescription
	      },
	      sortOrder: {
	        deps: ['provider', 'factorType'],
	        fn: factorUtil.getFactorSortOrder
	      },
	      iconClassName: {
	        deps: ['provider', 'factorType'],
	        fn: factorUtil.getFactorIconClassName
	      },
	      securityQuestion: {
	        deps: ['profile', 'factorType'],
	        fn: function (profile, factorType) {
	          if (factorType !== 'question') {
	            return null;
	          }
	          return profile && factorUtil.getSecurityQuestionLabel(profile);
	        }
	      },
	      phoneNumber: {
	        deps: ['profile', 'factorType'],
	        fn: function (profile, factorType) {
	          if (_.contains(['sms', 'call'], factorType)) {
	            return profile && profile.phoneNumber;
	          }
	          return null;
	        }
	      },
	      deviceName: {
	        deps: ['profile', 'factorType'],
	        fn: function (profile, factorType) {
	          if (factorType !== 'push') {
	            return null;
	          }
	          return profile && profile.name;
	        }
	      },
	      enrolled: {
	        deps: ['status'],
	        fn: function (status) {
	          return status === 'ACTIVE';
	        }
	      },
	      required: {
	        deps: ['enrollment'],
	        fn: function (enrollment) {
	          return enrollment === 'REQUIRED';
	        }
	      },
	      canUseResend: {
	        deps: ['provider', 'factorType'],
	        fn: function (provider, factorType) {
	          // Only push and sms have resend links.
	          // However, we currently have a problem with SMS
	          // (no way to know whether we want resend or verifyFactor),
	          // so we're turning it off for now.
	          return (provider === 'OKTA' && factorType === 'push');
	        }
	      },
	      isSMSorCall: {
	        deps: ['factorType'],
	        fn: function (factorType) {
	          return _.contains(['sms', 'call'], factorType);
	        }
	      }
	    },

	    parse: function (attributes) {
	      this.settings = attributes.settings;
	      this.appState = attributes.appState;
	      // set the initial value for remember device.
	      attributes.rememberDevice = factorUtil.getRememberDeviceValue(this.appState);
	      return _.omit(attributes, ['settings', 'appState']);
	    },

	    validate: function () {
	      if (this.get('isSMSorCall') && !this.get('answer')) {
	        return {'answer': Okta.loc('model.validation.field.blank')};
	      }
	    },

	    save: function () {
	      var rememberDevice = !!this.get('rememberDevice');
	      // Set/Remove the remember device cookie based on the remember device input.

	      return this.doTransaction(function (transaction) {
	        var data = {
	          rememberDevice: rememberDevice
	        };
	        if (this.get('factorType') === 'question') {
	          data.answer = this.get('answer');
	        } else {
	          data.passCode = this.get('answer');
	        }

	        var promise;
	        // MFA_REQUIRED
	        if (transaction.status === 'MFA_REQUIRED') {
	          var factor = _.findWhere(transaction.factors, {
	            id: this.get('id')
	          });
	          promise = factor.verify(data);
	        }

	        // MFA_CHALLENGE
	        else if (this.get('canUseResend') && transaction.resend) {
	          var firstLink = transaction.data._links.resend[0];
	          promise = transaction.resend(firstLink.name);
	        } else {
	          promise = transaction.verify(data);
	        }
	        //the 'save' event here is triggered and used in the BaseLoginController
	        //to disable the primary button on the factor form
	        this.trigger('save');

	        return promise
	        .then(function (trans) {
	          if (trans.status === 'MFA_CHALLENGE' && trans.poll) {
	            return Q.delay(PUSH_INTERVAL).then(function() {
	              return trans.poll(PUSH_INTERVAL);
	            });
	          }
	          return trans;
	        })
	        .fail(function (err) {
	          // Clean up the cookie on failure.
	          throw err;
	        });
	      });
	    }
	  });

	  var Factors = Okta.Collection.extend({

	    model: Factor,
	    comparator: 'sortOrder',

	    // One override necessary here - Okta Verify with Push is treated like
	    // one factor. In the beacon menu, there's only one option - only in the
	    // view can you choose to enable the other factor (which will be exposed
	    // by the backupFactor property)
	    parse: function (factors) {
	      // Keep a track of the last used factor, since
	      // we need it to determine the default factor.
	      this.lastUsedFactor = factors[0];

	      var oktaPushFactor = _.findWhere(factors, { provider: 'OKTA', factorType: 'push' });
	      if (!oktaPushFactor) {
	        return factors;
	      }
	      var totpFactor = _.findWhere(factors, { provider: 'OKTA', factorType: 'token:software:totp' });

	      var isTotpFirst = (totpFactor === factors[0]);

	      var parsedFactors = _.reduce(factors, function (memo, factor) {
	        var isOkta = factor.provider === 'OKTA';
	        var isOktaTotp = isOkta && factor.factorType === 'token:software:totp';
	        var isOktaPush = isOkta && factor.factorType === 'push';
	        var notEnrolled = factor.status !== 'ACTIVE';

	        var hideOktaTotp = isOktaTotp && (notEnrolled || oktaPushFactor.status === 'ACTIVE');
	        var hideOktaPush = isOktaPush && notEnrolled && totpFactor.status === 'ACTIVE';

	        if (hideOktaTotp || hideOktaPush) {
	          return memo;
	        }

	        if (isOktaPush) {
	          factor.backupFactor = new Factor(totpFactor, { parse: true });
	        }
	        memo.push(factor);
	        return memo;
	      }, []);

	      // Use push factor instead of TOTP, if TOTP is first in the list
	      // (since it is stored as backupFactor for push).
	      if (isTotpFirst) {
	        this.lastUsedFactor = oktaPushFactor;
	      }

	      return parsedFactors;
	    },

	    // Will need to update this to use HAL link to get last used factor:
	    // https://oktainc.atlassian.net/browse/OKTA-58380
	    // However, current code returns last used factor as first factor in list.
	    // Also, will need to add priority - i.e. if they do not have a last used
	    // factor, should try Okta Verify, then Okta SMS, etc.
	    getDefaultFactor: function () {
	      var factor = _.pick(this.lastUsedFactor, 'factorType', 'provider');
	      return this.findWhere(factor);
	    },

	    getFirstUnenrolledRequiredFactor: function () {
	      return this.findWhere({ required: true, enrolled: false });
	    }

	  });

	  return {
	    Model: Factor,
	    Collection: Factors
	  };

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint camelcase:false, newcap:false */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(128),
	  __webpack_require__(9),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(112),
	  __webpack_require__(106),
	  __webpack_require__(129)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Duo, Q, FactorUtil, FormController, Enums, FormType, FooterSignout) {

	  var $ = Okta.$,
	      _ = Okta._;

	  return FormController.extend({

	    className: 'mfa-verify-duo duo-form',

	    Model: {
	      props: {
	        host: 'string',
	        signature: 'string',
	        postAction: 'string',
	        factorId: 'string',
	        stateToken: 'string',
	        rememberDevice: 'boolean'
	      },

	      initialize: function () {
	        var rememberDevice = FactorUtil.getRememberDeviceValue(this.appState);
	        // set the initial value for remember device (Cannot do this while defining the
	        // local property because this.settings would not be initialized there yet).
	        this.set('rememberDevice', rememberDevice);
	      },

	      getInitOptions: function () {
	        var rememberDevice = !!this.get('rememberDevice');
	        return this.doTransaction(function(transaction) {
	          var data = {
	            rememberDevice: rememberDevice
	          };
	          var factor = _.findWhere(transaction.factors, {
	            provider: 'DUO',
	            factorType: 'web'
	          });
	          return factor.verify(data)
	          .fail(function (err) {
	            // Clean up the cookie on failure.
	            throw err;
	          });
	        });
	      },

	      verify: function (signedResponse) {
	        // Note: We should be doing this in OktaAuth! Fix when it's updated.
	        var url = this.get('postAction'),
	            factorId = this.get('factorId'),
	            self = this,
	            data = {
	              id: factorId,
	              stateToken: this.get('stateToken'),
	              sig_response: signedResponse
	            };
	        // We don't actually use authClient.post() here (unlike all the other cases in the
	        // sign-in widget) since the endpoint is wired to accept serialized form post instead
	        // of a JSON post ($.post() is different from authClient.post() in that in $.post(),
	        // jquery decides the Content-Type instead of it being a JSON type). Enroll/Verify DUO
	        // are the only two places where we actually do this.
	        // NOTE - If we ever decide to change this, we should test this very carefully.
	        var rememberDevice = this.get('rememberDevice');
	        return Q($.post(url, data))
	        .then(function () {
	          return self.doTransaction(function(transaction) {
	            var data;
	            if (rememberDevice) {
	              data = {rememberDevice: rememberDevice};
	            }
	            return transaction.poll(data);
	          });
	        })
	        .fail(function (err) {
	          self.trigger('error', self, err.xhr);
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      noButtonBar: true,
	      title: _.partial(Okta.loc, 'factor.duo'),
	      attributes: { 'data-se': 'factor-duo' },

	      postRender: function () {
	        this.add('<iframe frameborder="0" title="' + this.title() + '"></iframe>');
	        if (this.options.appState.get('allowRememberDevice')) {
	          this.addInput({
	            label: false,
	            'label-top': true,
	            placeholder: this.options.appState.get('rememberDeviceLabel'),
	            className: 'margin-btm-0',
	            name: 'rememberDevice',
	            type: 'checkbox'
	          });
	        }
	        Duo.init({
	          'host': this.model.get('host'),
	          'sig_request': this.model.get('signature'),
	          'iframe': this.$('iframe').get(0),
	          'post_action': _.bind(this.model.verify, this.model)
	        });
	      }
	    },

	    Footer: FooterSignout,

	    fetchInitialData: function () {
	      var self = this;
	      return this.model.getInitOptions()
	      .then(function (trans) {
	        var res = trans.data;
	        if (!res._embedded || !res._embedded.factor || !res._embedded.factor._embedded ||
	            !res._embedded.factor._embedded.verification) {
	          throw new Error('Response does not have duo verification options');
	        }
	        var verification = res._embedded.factor._embedded.verification;
	        self.model.set({
	          host: verification.host,
	          signature: verification.signature,
	          postAction: verification._links.complete.href,
	          factorId: res._embedded.factor.id,
	          stateToken: res.stateToken
	        });
	      });
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaChallenge')) {
	        return true;
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Duo Web SDK v2
	 * Copyright 2015, Duo Security
	 */

	// OKTA: Added define to use with AMD
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

	    var DUO_MESSAGE_FORMAT = /^(?:AUTH|ENROLL)+\|[A-Za-z0-9\+\/=]+\|[A-Za-z0-9\+\/=]+$/;
	    var DUO_ERROR_FORMAT = /^ERR\|[\w\s\.\(\)]+$/;

	    var iframeId = 'duo_iframe',
	        postAction = '',
	        postArgument = 'sig_response',
	        host,
	        sigRequest,
	        duoSig,
	        appSig,
	        iframe;

	    function throwError(message, url) {
	        throw new Error(
	            'Duo Web SDK error: ' + message +
	            (url ? ('\n' + 'See ' + url + ' for more information') : '')
	        );
	    }

	    function hyphenize(str) {
	        return str.replace(/([a-z])([A-Z])/, '$1-$2').toLowerCase();
	    }

	    // cross-browser data attributes
	    function getDataAttribute(element, name) {
	        if ('dataset' in element) {
	            return element.dataset[name];
	        } else {
	            return element.getAttribute('data-' + hyphenize(name));
	        }
	    }

	    // cross-browser event binding/unbinding
	    function on(context, event, fallbackEvent, callback) {
	        if ('addEventListener' in window) {
	            context.addEventListener(event, callback, false);
	        } else {
	            context.attachEvent(fallbackEvent, callback);
	        }
	    }

	    function off(context, event, fallbackEvent, callback) {
	        if ('removeEventListener' in window) {
	            context.removeEventListener(event, callback, false);
	        } else {
	            context.detachEvent(fallbackEvent, callback);
	        }
	    }

	    function onReady(callback) {
	        on(document, 'DOMContentLoaded', 'onreadystatechange', callback);
	    }

	    function offReady(callback) {
	        off(document, 'DOMContentLoaded', 'onreadystatechange', callback);
	    }

	    function onMessage(callback) {
	        on(window, 'message', 'onmessage', callback);
	    }

	    function offMessage(callback) {
	        off(window, 'message', 'onmessage', callback);
	    }

	    /**
	     * Parse the sig_request parameter, throwing errors if the token contains
	     * a server error or if the token is invalid.
	     *
	     * @param {String} sig Request token
	     */
	    function parseSigRequest(sig) {
	        if (!sig) {
	            // nothing to do
	            return;
	        }

	        // see if the token contains an error, throwing it if it does
	        if (sig.indexOf('ERR|') === 0) {
	            throwError(sig.split('|')[1]);
	        }

	        // validate the token
	        if (sig.indexOf(':') === -1 || sig.split(':').length !== 2) {
	            throwError(
	                'Duo was given a bad token.  This might indicate a configuration ' +
	                'problem with one of Duo\'s client libraries.',
	                'https://www.duosecurity.com/docs/duoweb#first-steps'
	            );
	        }

	        var sigParts = sig.split(':');

	        // hang on to the token, and the parsed duo and app sigs
	        sigRequest = sig;
	        duoSig = sigParts[0];
	        appSig = sigParts[1];

	        return {
	            sigRequest: sig,
	            duoSig: sigParts[0],
	            appSig: sigParts[1]
	        };
	    }

	    /**
	     * This function is set up to run when the DOM is ready, if the iframe was
	     * not available during `init`.
	     */
	    function onDOMReady() {
	        iframe = document.getElementById(iframeId);

	        if (!iframe) {
	            throw new Error(
	                'This page does not contain an iframe for Duo to use.' +
	                'Add an element like <iframe id="duo_iframe"></iframe> ' +
	                'to this page.  ' +
	                'See https://www.duosecurity.com/docs/duoweb#3.-show-the-iframe ' +
	                'for more information.'
	            );
	        }

	        // we've got an iframe, away we go!
	        ready();

	        // always clean up after yourself
	        offReady(onDOMReady);
	    }

	    /**
	     * Validate that a MessageEvent came from the Duo service, and that it
	     * is a properly formatted payload.
	     *
	     * The Google Chrome sign-in page injects some JS into pages that also
	     * make use of postMessage, so we need to do additional validation above
	     * and beyond the origin.
	     *
	     * @param {MessageEvent} event Message received via postMessage
	     */
	    function isDuoMessage(event) {
	        return Boolean(
	            event.origin === ('https://' + host) &&
	            typeof event.data === 'string' &&
	            (
	                event.data.match(DUO_MESSAGE_FORMAT) ||
	                event.data.match(DUO_ERROR_FORMAT)
	            )
	        );
	    }

	    /**
	     * Validate the request token and prepare for the iframe to become ready.
	     *
	     * All options below can be passed into an options hash to `Duo.init`, or
	     * specified on the iframe using `data-` attributes.
	     *
	     * Options specified using the options hash will take precedence over
	     * `data-` attributes.
	     *
	     * Example using options hash:
	     * ```javascript
	     * Duo.init({
	     *     iframe: "some_other_id",
	     *     host: "api-main.duo.test",
	     *     sig_request: "...",
	     *     post_action: "/auth",
	     *     post_argument: "resp"
	     * });
	     * ```
	     *
	     * Example using `data-` attributes:
	     * ```
	     * <iframe id="duo_iframe"
	     *         data-host="api-main.duo.test"
	     *         data-sig-request="..."
	     *         data-post-action="/auth"
	     *         data-post-argument="resp"
	     *         >
	     * </iframe>
	     * ```
	     *
	     * @param {Object} options
	     * @param {String} options.iframe                         The iframe, or id of an iframe to set up
	     * @param {String} options.host                           Hostname
	     * @param {String} options.sig_request                    Request token
	     * @param {String} [options.post_action='']               URL to POST back to after successful auth
	     * @param {String} [options.post_argument='sig_response'] Parameter name to use for response token
	     */
	    function init(options) {
	        if (options) {
	            if (options.host) {
	                host = options.host;
	            }

	            if (options.sig_request) {
	                parseSigRequest(options.sig_request);
	            }

	            if (options.post_action) {
	                postAction = options.post_action;
	            }

	            if (options.post_argument) {
	                postArgument = options.post_argument;
	            }

	            if (options.iframe) {
	                if ('tagName' in options.iframe) {
	                    iframe = options.iframe;
	                } else if (typeof options.iframe === 'string') {
	                    iframeId = options.iframe;
	                }
	            }
	        }

	        // if we were given an iframe, no need to wait for the rest of the DOM
	        if (iframe) {
	            ready();
	        } else {
	            // try to find the iframe in the DOM
	            iframe = document.getElementById(iframeId);

	            // iframe is in the DOM, away we go!
	            if (iframe) {
	                ready();
	            } else {
	                // wait until the DOM is ready, then try again
	                onReady(onDOMReady);
	            }
	        }

	        // always clean up after yourself!
	        offReady(init);
	    }

	    /**
	     * This function is called when a message was received from another domain
	     * using the `postMessage` API.  Check that the event came from the Duo
	     * service domain, and that the message is a properly formatted payload,
	     * then perform the post back to the primary service.
	     *
	     * @param event Event object (contains origin and data)
	     */
	    function onReceivedMessage(event) {
	        if (isDuoMessage(event)) {
	            // the event came from duo, do the post back
	            doPostBack(event.data);

	            // always clean up after yourself!
	            offMessage(onReceivedMessage);
	        }
	    }

	    /**
	     * Point the iframe at Duo, then wait for it to postMessage back to us.
	     */
	    function ready() {
	        if (!host) {
	            host = getDataAttribute(iframe, 'host');

	            if (!host) {
	                throwError(
	                    'No API hostname is given for Duo to use.  Be sure to pass ' +
	                    'a `host` parameter to Duo.init, or through the `data-host` ' +
	                    'attribute on the iframe element.',
	                    'https://www.duosecurity.com/docs/duoweb#3.-show-the-iframe'
	                );
	            }
	        }

	        if (!duoSig || !appSig) {
	            parseSigRequest(getDataAttribute(iframe, 'sigRequest'));

	            if (!duoSig || !appSig) {
	                throwError(
	                    'No valid signed request is given.  Be sure to give the ' +
	                    '`sig_request` parameter to Duo.init, or use the ' +
	                    '`data-sig-request` attribute on the iframe element.',
	                    'https://www.duosecurity.com/docs/duoweb#3.-show-the-iframe'
	                );
	            }
	        }

	        // if postAction/Argument are defaults, see if they are specified
	        // as data attributes on the iframe
	        if (postAction === '') {
	            postAction = getDataAttribute(iframe, 'postAction') || postAction;
	        }

	        if (postArgument === 'sig_response') {
	            postArgument = getDataAttribute(iframe, 'postArgument') || postArgument;
	        }

	        // point the iframe at Duo
	        iframe.src = [
	            'https://', host, '/frame/web/v1/auth?tx=', duoSig,
	            '&parent=', document.location.href
	        ].join('');

	        // listen for the 'message' event
	        onMessage(onReceivedMessage);
	    }

	    /**
	     * We received a postMessage from Duo.  POST back to the primary service
	     * with the response token, and any additional user-supplied parameters
	     * given in form#duo_form.
	     */
	    // function doPostBack(response) {
	    //     // create a hidden input to contain the response token
	    //     var input = document.createElement('input');
	    //     input.type = 'hidden';
	    //     input.name = postArgument;
	    //     input.value = response + ':' + appSig;
	    //
	    //     // user may supply their own form with additional inputs
	    //     var form = document.getElementById('duo_form');
	    //
	    //     // if the form doesn't exist, create one
	    //     if (!form) {
	    //         form = document.createElement('form');
	    //
	    //         // insert the new form after the iframe
	    //         iframe.parentElement.insertBefore(form, iframe.nextSibling);
	    //     }
	    //
	    //     // make sure we are actually posting to the right place
	    //     form.method = 'POST';
	    //     form.action = postAction;
	    //
	    //     // add the response token input to the form
	    //     form.appendChild(input);
	    //
	    //     // away we go!
	    //     form.submit();
	    // }

	    // OKTA: Overriding their doPostBack logic because we want to submit this
	    // through ajax, not a postBack
	    function doPostBack(response) {
	        postAction(response + ':' + appSig);
	    }

	    // when the DOM is ready, initialize
	    // note that this will get cleaned up if the user calls init directly!
	    onReady(init);

	    return {
	        init: init,
	        _parseSigRequest: parseSigRequest,
	        _isDuoMessage: isDuoMessage
	    };

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums) {

	  var _ = Okta._;

	  return Okta.View.extend({
	    template: '\
	      <a href="#" class="link {{linkClassName}}" data-se="signout-link">\
	        {{linkText}}\
	      </a>\
	    ',
	    className: 'auth-footer clearfix',
	    events: {
	      'click a' : function (e) {
	        e.preventDefault();
	        var self = this;
	        this.model.doTransaction(function(transaction) {
	          return transaction.cancel();
	        })
	        .then(function() {
	          self.state.set('navigateDir', Enums.DIRECTION_BACK);
	          self.options.appState.trigger('navigate', '');
	        });
	      }
	    },
	    getTemplateData: function () {
	      return {
	        linkClassName: _.isUndefined(this.options.linkClassName) ? 'goto' : this.options.linkClassName,
	        linkText: this.options.linkText || Okta.loc('signout', 'login')
	      };
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint maxcomplexity:13, maxparams:11 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(71),
	  __webpack_require__(107),
	  __webpack_require__(133),
	  __webpack_require__(136),
	  __webpack_require__(137),
	  __webpack_require__(131),
	  __webpack_require__(138),
	  __webpack_require__(139),
	  __webpack_require__(140),
	  __webpack_require__(129)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Checkbox, BaseLoginController, CookieUtil, TOTPForm, YubikeyForm, SecurityQuestionForm, CallAndSMSForm,
	          PushForm, InlineTOTPForm, FooterSignout) {

	  return BaseLoginController.extend({
	    className: 'mfa-verify',

	    initialize: function (options) {
	      var factors = options.appState.get('factors');
	      var factorType = options.factorType;
	      var provider = options.provider;

	      var View;
	      switch (factorType) {
	      case 'question':
	        View = SecurityQuestionForm;
	        break;
	      case 'sms':
	      case 'call':
	        View = CallAndSMSForm;
	        break;
	      case 'token':
	      case 'token:software:totp':
	        View = TOTPForm;
	        break;
	      case 'token:hardware':
	        View = YubikeyForm;
	        break;
	      case 'push':
	        View = PushForm;
	        break;
	      default:
	        throw new Error('Unrecognized factor type');
	      }

	      this.model = factors.findWhere({ provider: provider, factorType: factorType });
	      if (!this.model) {
	        // TODO: recover from this more gracefully - probably to redirect
	        // to default factor
	        throw new Error('Unrecognized factor/provider');
	      }

	      this.addListeners();
	      this.add(new View(this.toJSON()));

	      // Okta Push is different from the other factors - it has a backup
	      // totp factor that can be chosen with the InlineTOTPForm
	      if (factorType === 'push' && this.model.get('isOktaFactor')) {
	        this.add(InlineTOTPForm, {
	          options: { model: this.model.get('backupFactor') }
	        });

	        if (this.settings.get('features.autoPush')) {
	          this.add(Checkbox, {
	            options: {
	              model: this.model,
	              name: 'autoPush',
	              placeholder: Okta.loc('autoPush', 'login'),
	              label: false,
	              'label-top': false,
	              className: 'margin-btm-0'
	            }
	          });
	        }

	        // Remember Device checkbox resides outside of the Push and TOTP forms.
	        if (this.options.appState.get('allowRememberDevice')) {
	          this.add(Checkbox, {
	            options: {
	              model: this.model,
	              name: 'rememberDevice',
	              placeholder: this.options.appState.get('rememberDeviceLabel'),
	              label: false,
	              'label-top': true,
	              className: 'margin-btm-0'
	            }
	          });
	        }
	        // Set the rememberDevice on the TOTP factor since it is stored as backupFactor.
	        this.listenTo(this.model, 'change:rememberDevice', function (model, rememberDevice) {
	          model.get('backupFactor').set('rememberDevice', rememberDevice);
	        });
	      }

	      if (!this.settings.get('features.hideSignOutLinkInMFA')) {
	        this.add(new FooterSignout(this.toJSON()));
	      }
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaChallenge') ||
	          this.options.appState.get('isMfaRequired')) {
	        return true;
	      }
	      // update auto push cookie after user accepts Okta Verify MFA
	      if (this.options.factorType == 'push') {
	        if (this.settings.get('features.autoPush') && this.model.get('autoPush')) {
	          CookieUtil.setAutoPushCookie(this.options.appState.get('userId'));
	        } else {
	          CookieUtil.removeAutoPushCookie(this.options.appState.get('userId'));
	        }
	      }
	      return false;
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(132)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, PasswordBox) {

	  var _ = Okta._;

	  return Okta.Form.extend({
	    className: 'mfa-verify-question',
	    autoSave: true,
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	    scrollOnError: false,
	    layout: 'o-form-theme',
	    attributes: { 'data-se': 'factor-question' },

	    initialize: function () {
	      this.title = this.model.get('factorLabel');

	      this.addInput({
	        label: this.model.get('securityQuestion'),
	        'label-top': true,
	        placeholder: Okta.loc('mfa.challenge.answer.placeholder', 'login'),
	        className: 'auth-passcode',
	        name: 'answer',
	        type: 'password',
	        input: PasswordBox
	      });

	      if (this.options.appState.get('allowRememberDevice')) {
	        this.addInput({
	          label: false,
	          'label-top': true,
	          placeholder: this.options.appState.get('rememberDeviceLabel'),
	          className: 'margin-btm-0',
	          name: 'rememberDevice',
	          type: 'checkbox'
	        });
	      }
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    __webpack_require__(41),
	    __webpack_require__(116)
	  ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox) {

	    return TextBox.extend({
	      template: Okta.tpl('\
	        <input type="password" placeholder="{{placeholder}}" name="{{name}}" id="{{inputId}}" value="{{value}}"/>\
	        <span class="password-toggle">\
	          <span class="button button-dark button-show">\
	            {{i18n code="mfa.challenge.answer.showAnswer" bundle="login"}}</span>\
	          <span class="button button-hide">{{i18n code="mfa.challenge.answer.hideAnswer" bundle="login"}}</span>\
	        </span>'),

	      initialize: function () {
	        this.events['click .password-toggle .button-show'] = '_showPassword';
	        this.events['click .password-toggle .button-hide'] = '_hidePassword';

	        this.delegateEvents();
	      },

	      changeType: function (type) {
	        TextBox.prototype.changeType.apply(this, arguments);
	        this.$('.password-toggle').toggleClass('password-toggle-on', type !== 'password');
	      },

	      _showPassword: function () {
	        this.changeType('text');
	      },

	      _hidePassword: function () {
	        this.changeType('password');
	      }

	    });

	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(134), __webpack_require__(135)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, CryptoUtil) {

	  var $ = Okta.$;
	  var LAST_USERNAME_COOKIE_NAME = 'ln';
	  var AUTO_PUSH_COOKIE_PREFIX  = 'auto_push_';
	  var DAYS_SAVE_REMEMBER = 365;

	  function removeCookie (name) {
	    $.removeCookie(name, { path: '/' });
	  }

	  function setCookie (name, value) {
	    $.cookie(name, value, {
	      expires: DAYS_SAVE_REMEMBER,
	      path: '/'
	    });
	  }

	  function getAutoPushKey(userId) {
	    return AUTO_PUSH_COOKIE_PREFIX + CryptoUtil.getStringHash(userId);
	  }

	  var fn = {};

	  fn.getCookieUsername = function () {
	    return $.cookie(LAST_USERNAME_COOKIE_NAME);
	  };

	  fn.setUsernameCookie = function (username) {
	    setCookie(LAST_USERNAME_COOKIE_NAME, username);
	  };

	  fn.removeUsernameCookie = function () {
	    removeCookie(LAST_USERNAME_COOKIE_NAME);
	  };

	  fn.isAutoPushEnabled = function (userId) {
	    if (userId === undefined) {
	      return false;
	    }
	    return $.cookie(getAutoPushKey(userId)) === 'true';
	  };

	  fn.setAutoPushCookie = function (userId) {
	    if (userId === undefined) {
	      return;
	    }
	    setCookie(getAutoPushKey(userId), true);
	  };

	  fn.removeAutoPushCookie = function (userId) {
	    if (userId === undefined) {
	      return;
	    }
	    removeCookie(getAutoPushKey(userId));
	  };

	  return fn;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  var fn = {};
	  
	   // Light weight hashing algorithm that hashes string into an integer between 0 and 4294967295
	   // Not recommended for data set of size greater than 10000
	   // https://www.npmjs.com/package/string-hash
	  fn.getStringHash = function (str) {
	    var hash = 5381,
	        i = str.length;
	    while(i) {
	      hash = (hash * 33) ^ str.charCodeAt(--i);
	    }
	    return hash >>> 0;
	  };
	  
	  return fn;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery Cookie Plugin v1.4.1
	 * https://github.com/carhartl/jquery-cookie
	 *
	 * Copyright 2013 Klaus Hartl
	 * Released under the MIT license
	 */
	(function (factory) {
		if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			// CommonJS
			factory(require('jquery'));
		} else {
			// Browser globals
			factory(jQuery);
		}
	}(function ($) {

		var pluses = /\+/g;

		function encode(s) {
			return config.raw ? s : encodeURIComponent(s);
		}

		function decode(s) {
			return config.raw ? s : decodeURIComponent(s);
		}

		function stringifyCookieValue(value) {
			return encode(config.json ? JSON.stringify(value) : String(value));
		}

		function parseCookieValue(s) {
			if (s.indexOf('"') === 0) {
				// This is a quoted cookie as according to RFC2068, unescape...
				s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
			}

			try {
				// Replace server-side written pluses with spaces.
				// If we can't decode the cookie, ignore it, it's unusable.
				// If we can't parse the cookie, ignore it, it's unusable.
				s = decodeURIComponent(s.replace(pluses, ' '));
				return config.json ? JSON.parse(s) : s;
			} catch(e) {}
		}

		function read(s, converter) {
			var value = config.raw ? s : parseCookieValue(s);
			return $.isFunction(converter) ? converter(value) : value;
		}

		var config = $.cookie = function (key, value, options) {

			// Write

			if (value !== undefined && !$.isFunction(value)) {
				options = $.extend({}, config.defaults, options);

				if (typeof options.expires === 'number') {
					var days = options.expires, t = options.expires = new Date();
					t.setTime(+t + days * 864e+5);
				}

				return (document.cookie = [
					encode(key), '=', stringifyCookieValue(value),
					options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
					options.path    ? '; path=' + options.path : '',
					options.domain  ? '; domain=' + options.domain : '',
					options.secure  ? '; secure' : ''
				].join(''));
			}

			// Read

			var result = key ? undefined : {};

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling $.cookie().
			var cookies = document.cookie ? document.cookie.split('; ') : [];

			for (var i = 0, l = cookies.length; i < l; i++) {
				var parts = cookies[i].split('=');
				var name = decode(parts.shift());
				var cookie = parts.join('=');

				if (key && key === name) {
					// If second argument (value) is a function it's a converter...
					result = read(cookie, value);
					break;
				}

				// Prevent storing a cookie that we couldn't decode.
				if (!key && (cookie = read(cookie)) !== undefined) {
					result[name] = cookie;
				}
			}

			return result;
		};

		config.defaults = {};

		$.removeCookie = function (key, options) {
			if ($.cookie(key) === undefined) {
				return false;
			}

			// Must not alter options, thus extending a fresh object...
			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
			return !$.cookie(key);
		};

	}));


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox) {

	  var _ = Okta._;

	  return Okta.Form.extend({
	    className: 'mfa-verify-totp',
	    autoSave: true,
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	    scrollOnError: false,
	    layout: 'o-form-theme',
	    attributes: { 'data-se': 'factor-totp' },

	    initialize: function () {
	      var factorName = this.model.get('factorLabel');
	      var maskPasswordField = this.model.get('provider') === 'RSA' || this.model.get('provider') === 'DEL_OATH';

	      this.title = factorName;
	      this.subtitle = Okta.loc('mfa.challenge.title', 'login', [factorName]);

	      this.addInput({
	        label: false,
	        'label-top': true,
	        placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	        className: 'o-form-fieldset o-form-label-top auth-passcode',
	        name: 'answer',
	        input: TextBox,
	        type: maskPasswordField ? 'password' : 'text'
	      });

	      if (this.options.appState.get('allowRememberDevice')) {
	        this.addInput({
	          label: false,
	          'label-top': true,
	          placeholder: this.options.appState.get('rememberDeviceLabel'),
	          className: 'margin-btm-0',
	          name: 'rememberDevice',
	          type: 'checkbox'
	        });
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox) {

	  var _ = Okta._;

	  return Okta.Form.extend({
	    className: 'mfa-verify-yubikey',
	    autoSave: true,
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	    scrollOnError: false,
	    layout: 'o-form-theme',
	    attributes: { 'data-se': 'factor-yubikey' },

	    initialize: function () {
	      var factorName = this.model.get('factorLabel');

	      this.title = factorName;
	      this.subtitle = Okta.loc('factor.totpHard.yubikey.description', 'login');

	      this.addInput({
	        label: false,
	        'label-top': true,
	        className: 'o-form-fieldset o-form-label-top auth-passcode',
	        name: 'answer',
	        input: TextBox,
	        type: 'password',
	        placeholder: Okta.loc('factor.totpHard.yubikey.placeholder','login')
	      });

	      if (this.options.appState.get('allowRememberDevice')) {
	        this.addInput({
	          label: false,
	          'label-top': true,
	          className: 'margin-btm-0',
	          placeholder: this.options.appState.get('rememberDeviceLabel'),
	          name: 'rememberDevice',
	          type: 'checkbox'
	        });
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(9), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, TextBox) {

	  var subtitleTpl = Okta.Handlebars.compile('({{phoneNumber}})');
	  var _ = Okta._;
	  var API_RATE_LIMIT = 30000; //milliseconds

	  function isCallFactor(factorType) {
	    return factorType === 'call';
	  }

	  return Okta.Form.extend({
	    className: 'mfa-verify-sms-call',
	    autoSave: true,
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	    scrollOnError: false,
	    layout: 'o-form-theme',

	    disableSubmitButton: function () {
	      return this.model.appState.get('isMfaChallenge');
	    },

	    initialize: function () {
	      /*jshint maxcomplexity:7*/
	      var self = this;
	      this.title = this.model.get('factorLabel');

	      var factorType = this.model.get('factorType');
	      var isCall = isCallFactor(factorType);
	      this.$el.attr('data-se', 'factor-' + factorType);
	      var buttonDataSe = isCall ? 'make-call' : 'sms-send-code';
	      var buttonClassName = isCall ? 'call-request-button' : 'sms-request-button';

	      var formSubmit = Okta.loc(isCall ? 'mfa.call' : 'mfa.sendCode', 'login');
	      var formRetry = Okta.loc(isCall ? 'mfa.redial' : 'mfa.resendCode', 'login');
	      var formSubmitted = Okta.loc(isCall ? 'mfa.calling' : 'mfa.sent', 'login');

	      this.subtitle = subtitleTpl({
	        phoneNumber: this.model.get('phoneNumber')
	      });
	      this.listenTo(this.model, 'error', function () {
	        this.clearErrors();
	      });
	      this.add(Okta.createButton({
	        attributes: { 'data-se': buttonDataSe },
	        className: 'button ' + buttonClassName,
	        title: formSubmit,
	        click: function () {
	          self.clearErrors();
	          // To send an OTP to the device, make the same request but use
	          // an empty passCode
	          this.model.set('answer', '');
	          this.model.save()
	          .then(_.bind(function () {
	            this.options.title = formSubmitted;
	            this.disable();
	            this.render();
	            // render and focus on the passcode input field.
	            self.getInputs().first().render().focus();
	            return Q.delay(API_RATE_LIMIT);
	          }, this))
	          .then(_.bind(function () {
	            this.options.title = formRetry;
	            this.enable();
	            this.render();
	          }, this));
	        }
	      }));
	      this.addInput({
	        label: false,
	        'label-top': true,
	        placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	        className: 'o-form-fieldset o-form-label-top auth-passcode',
	        name: 'answer',
	        input: TextBox,
	        type: 'text'
	      });
	      if (this.options.appState.get('allowRememberDevice')) {
	        this.addInput({
	          label: false,
	          'label-top': true,
	          placeholder: this.options.appState.get('rememberDeviceLabel'),
	          className: 'margin-btm-0',
	          name: 'rememberDevice',
	          type: 'checkbox'
	        });
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(133)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, CookieUtil) {

	  var _ = Okta._;
	  // deviceName is escaped on BaseForm (see BaseForm's template)
	  var titleTpl = Okta.Handlebars.compile('{{factorName}} ({{{deviceName}}})');

	  return Okta.Form.extend({
	    className: 'mfa-verify-push',
	    autoSave: true,
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'oktaverify.send', 'login'),
	    scrollOnError: false,
	    layout: 'o-form-theme',
	    attributes: { 'data-se': 'factor-push' },
	    events: {
	      submit: 'submit'
	    },

	    initialize: function () {
	      this.enabled = true;
	      this.listenTo(this.options.appState, 'change:isMfaRejectedByUser',
	        function (state, isMfaRejectedByUser) {
	          this.setSubmitState(isMfaRejectedByUser);
	          if (isMfaRejectedByUser) {
	            this.showError(Okta.loc('oktaverify.rejected', 'login'));
	          }
	        }
	      );
	      this.listenTo(this.options.appState, 'change:isMfaTimeout',
	        function (state, isMfaTimeout) {
	          this.setSubmitState(isMfaTimeout);
	          if (isMfaTimeout) {
	            this.showError(Okta.loc('oktaverify.timeout', 'login'));
	          }
	        }
	      );
	      this.listenTo(this.options.appState, 'change:isMfaRequired',
	        function (state, isMfaRequired) {
	          if (isMfaRequired) {
	            this.clearErrors();
	          }
	        }
	      );
	      this.title = titleTpl({
	        factorName: this.model.get('factorLabel'),
	        deviceName: this.model.get('deviceName')
	      });
	    },
	    setSubmitState: function (ableToSubmit) {
	      var button = this.$el.find('.button');
	      this.enabled = ableToSubmit;
	      if (ableToSubmit) {
	        button.removeClass('link-button-disabled');
	        button.prop('value', Okta.loc('oktaverify.send', 'login'));
	      } else {
	        button.addClass('link-button-disabled');
	        button.prop('value', Okta.loc('oktaverify.sent', 'login'));
	      }
	    },
	    submit: function (e) {
	      if (e !== undefined) {
	        e.preventDefault();
	      }
	      if (this.enabled) {
	        this.setSubmitState(false);
	        this.doSave();
	      }
	    },
	    postRender: function() {
	      if (this.settings.get('features.autoPush') && CookieUtil.isAutoPushEnabled(this.options.appState.get('userId'))) {
	        this.model.set('autoPush', true);
	        // bind after $el has been rendered, and trigger push once DOM is fully loaded
	        _.defer(_.bind(this.submit, this));
	      }
	    },
	    doSave: function () {
	      this.clearErrors();
	      if (this.model.isValid()) {
	        this.listenToOnce(this.model, 'error', this.setSubmitState, true);
	        this.trigger('save', this.model);
	      }
	    },
	    showError: function (msg) {
	      this.model.trigger('error', this.model, {responseJSON: {errorSummary: msg}});
	    }
	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox) {

	  function addInlineTotp(form) {
	    form.addDivider();
	    form.addInput({
	      label: false,
	      'label-top': true,
	      placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	      className: 'o-form-fieldset o-form-label-top inline-input auth-passcode',
	      name: 'answer',
	      input: TextBox,
	      type: 'text'
	    });
	    form.add(Okta.createButton({
	      attributes: { 'data-se': 'inline-totp-verify' },
	      className: 'button inline-totp-verify',
	      title: Okta.loc('mfa.challenge.verify', 'login'),
	      click: function () {
	        form.model.manageTransaction(function (transaction, setTransaction) {
	          // This is the case where we enter the TOTP code and verify while there is an
	          // active Push request (or polling) running. We need to invoke previous() on authClient
	          // and then call model.save(). If not, we would still be in MFA_CHALLENGE state and
	          // verify would result in a wrong request (push verify instead of a TOTP verify).
	          if (transaction.status === 'MFA_CHALLENGE' && transaction.prev) {
	            return transaction.prev().then(function (trans) {
	              setTransaction(trans);
	              form.model.save();
	            });
	          } else {
	            // Push is not active and we enter the code to verify.
	            form.model.save();
	          }
	        });
	      }
	    }));
	    form.at(1).focus();
	  }

	  return Okta.Form.extend({
	    autoSave: true,
	    noButtonBar: true,
	    scrollOnError: false,
	    layout: 'o-form-theme',

	    className: 'mfa-verify-totp-inline',

	    attributes: { 'data-se': 'factor-inline-totp' },

	    initialize: function () {
	      var form = this;
	      this.listenTo(this.model, 'error', function () {
	        this.clearErrors();
	      });
	      this.add(Okta.createButton({
	        className: 'link',
	        attributes: { 'data-se': 'inline-totp-add' },
	        title: Okta.loc('mfa.challenge.orEnterCode', 'login'),
	        click: function () {
	          this.remove();
	          addInlineTotp(form);
	        }
	      }));
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(142),
	  __webpack_require__(143),
	  __webpack_require__(129),
	  __webpack_require__(144)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, webauthn, Spinner, FooterSignout, HtmlErrorMessageView) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'mfa-verify verify-windows-hello',
	    Model: {
	      local: {
	        __autoTriggered__: 'boolean'
	      },

	      save: function () {
	        if (!webauthn.isAvailable()) {
	          return;
	        }

	        this.trigger('request');
	        var model = this;

	        return this.doTransaction(function (transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'webauthn',
	            provider: 'FIDO'
	          });

	          return factor.verify()
	          .then(function (verifyData) {
	            var factorData = verifyData.factor;

	            return webauthn.getAssertion(
	              factorData.challenge.nonce,
	              [{ id: factorData.profile.credentialId }]
	            )
	            .then(function (assertion) {
	              return factor.verify({
	                authenticatorData: assertion.authenticatorData,
	                clientData: assertion.clientData,
	                signatureData: assertion.signature
	              });
	            })
	            .then(function (data) {
	              model.trigger('sync');
	              model.trigger('signIn');
	              return data;
	            })
	            .fail(function (error) {
	              switch (error.message) {
	              case 'AbortError':
	              case 'NotFoundError':
	              case 'NotSupportedError':
	                model.trigger('abort', error.message);
	                return transaction;
	              }

	              throw error;
	            });
	          });
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      hasSavingState: false,
	      title: _.partial(Okta.loc, 'factor.windowsHello', 'login'),
	      subtitle: function () {
	        return webauthn.isAvailable() ? Okta.loc('verify.windowsHello.subtitle', 'login') : '';
	      },
	      save: _.partial(Okta.loc, 'verify.windowsHello.save', 'login'),

	      customSavingState:{
	        stop: 'abort'
	      },

	      modelEvents: function () {
	        if (!webauthn.isAvailable()) {
	          return {};
	        }

	        return {
	          'request': '_startEnrollment',
	          'error': '_stopEnrollment',
	          'abort': '_stopEnrollment',
	          'signIn': '_successEnrollment'
	        };
	      },

	      noButtonBar: function () {
	        return !webauthn.isAvailable();
	      },

	      formChildren: function () {
	        var result = [];
	        if (!webauthn.isAvailable()) {
	          result.push(
	            FormType.View(
	              { View: new HtmlErrorMessageView(
	                { message: Okta.loc('enroll.windowsHello.error.notWindows', 'login') })},
	              { selector: '.o-form-error-container' }
	            )
	          );
	        }

	        result.push(FormType.View({ View: new Spinner({ model: this.model, visible: false }) }));

	        return result;
	      },

	      postRender: function () {
	        if (this.options.appState.get('factors').length === 1 && !this.model.get('__autoTriggered__')) {
	          this.model.set('__autoTriggered__', true);
	          this.model.save();
	        }
	      },

	      _startEnrollment: function () {
	        this.subtitle = Okta.loc('verify.windowsHello.subtitle.loading', 'login');

	        this.model.trigger('spinner:show');
	        this._resetErrorMessage();

	        this.render();
	        this.$('.o-form-button-bar').addClass('hide');
	      },


	      _stopEnrollment: function (errorMessage) {
	        this.subtitle = Okta.loc('verify.windowsHello.subtitle', 'login');

	        this.model.trigger('spinner:hide');
	        this.$('.o-form-button-bar').removeClass('hide');

	        var message;
	        switch (errorMessage) {
	        case 'NotFoundError':
	          message = this.options.appState.get('factors').length > 1 ?
	            Okta.loc('verify.windowsHello.error.notFound.selectAnother', 'login') :
	            Okta.loc('verify.windowsHello.error.notFound', 'login');
	          break;

	        case 'NotSupportedError':
	          message = Okta.loc('enroll.windowsHello.error.notConfiguredHtml', 'login');
	          break;
	        }

	        this._resetErrorMessage();

	        if (message) {
	          var messageView = new HtmlErrorMessageView({
	            message: message
	          });

	          this.$('.o-form-error-container').addClass('o-form-has-errors');
	          this.add(messageView, {selector: '.o-form-error-container'});
	          this._errorMessageView = this.last();
	        }

	        this.render();
	      },

	      _successEnrollment: function () {
	        this.subtitle = Okta.loc('verify.windowsHello.subtitle.signingIn', 'login');
	        this.render();
	        this.$('.o-form-button-bar').addClass('hide');
	      },

	      _resetErrorMessage: function () {
	        this._errorMessageView && this._errorMessageView.remove();
	        this._errorMessageView = undefined;
	        this.clearErrors();
	      }
	    },

	    Footer: FooterSignout
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* globals JSON */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    __webpack_require__(41),
	    __webpack_require__(9)
	  ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q) {

	  function adaptToOkta(promise) {
	    return new Q(promise);
	  }

	  function makeCredential(accountInfo, cryptoParams, challenge) {
	    cryptoParams = cryptoParams.map(function (param) {
	      return {type: 'FIDO_2_0', algorithm: param.algorithm};
	    });

	    var promise = window.msCredentials.makeCredential(accountInfo, cryptoParams, challenge)
	    .then(function (cred) {
	      return Object.freeze({
	        credential: {id: cred.id},
	        publicKey: JSON.parse(cred.publicKey),
	        attestation: cred.attestation
	      });
	    });

	    return adaptToOkta(promise);
	  }

	  function getAssertion(challenge, allowList) {
	    var accept = allowList.map(function (item) {
	      return {type: 'FIDO_2_0', id: item.id};
	    });
	    var filters = {accept: accept};

	    var promise = window.msCredentials.getAssertion(challenge, filters)
	    .then(function (attestation) {
	      var signature = attestation.signature;
	      return Object.freeze({
	        credential: {id: attestation.id},
	        clientData: signature.clientData,
	        authenticatorData: signature.authnrData,
	        signature: signature.signature
	      });
	    });

	    return adaptToOkta(promise);
	  }

	  return {
	    makeCredential: makeCredential,
	    getAssertion: getAssertion,
	    isAvailable: function () {
	      return window.hasOwnProperty('msCredentials');
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  return Okta.View.extend({
	    className: 'okta-waiting-spinner',
	    attributes: {
	      'data-se': 'o-form-okta-waiting-spinner'
	    },
	    modelEvents: {
	      'spinner:show': 'show',
	      'spinner:hide': 'hide'
	    },

	    initialize: function (options) {
	      if(options && options.visible === false){
	        this.hide();
	      }
	    },

	    show: function () {
	      this.$el.removeClass('hide');
	    },

	    hide: function () {
	      this.$el.addClass('hide');
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    __webpack_require__(41),
	    __webpack_require__(48)
	  ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, BaseView) {

	    // Have to be unescaped for the html in enroll.windowsHello.error.notConfiguredHtml
	    var template = '\
	      <span class="icon error-24"></span>\
	      <h4><strong>{{{message}}}</strong></h4>\
	    ';

	    return BaseView.extend({
	      template: template,
	      className: 'okta-infobox-error infobox infobox-error infobox-md margin-btm-25',
	      attributes: {
	        'data-se': 'o-form-error-html'
	      },

	      message: '',

	      initialize: function (options) {
	        if (options && options.message) {
	          this.message = options.message;
	        }
	      },

	      getTemplateData: function () {
	        return {
	          message: this.message
	        };
	      }
	    });
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* global u2f */
	/* jshint maxcomplexity:9 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(129),
	  __webpack_require__(9),
	  __webpack_require__(144),
	  __webpack_require__(14),
	  __webpack_require__(146)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, FooterSignout, Q, HtmlErrorMessageView, BrowserFeatures) {

	  var _ = Okta._;

	  function getErrorMessageKeyByCode(errorCode, isOneFactor) {
	    switch (errorCode){
	    case 1: // OTHER_ERROR
	      return isOneFactor ? 'u2f.error.other.oneFactor' : 'u2f.error.other';
	    case 2: // BAD_REQUEST
	    case 3: // CONFIGURATION_UNSUPPORTED
	      return isOneFactor ? 'u2f.error.badRequest.oneFactor' : 'u2f.error.badRequest';
	    case 4: // DEVICE_INELIGIBLE
	      return isOneFactor ? 'u2f.error.unsupported.oneFactor' : 'u2f.error.unsupported';
	    case 5: // TIMEOUT
	      return 'u2f.error.timeout';
	    }
	  }

	  return FormController.extend({
	    className: 'verify-u2f',
	    Model: {
	      save: function () {
	        this.trigger('request');

	        return this.doTransaction(function (transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'u2f',
	            provider: 'FIDO'
	          });
	          var self = this;
	          return factor.verify()
	          .then(function (transaction) {
	            var factorData = transaction.factor;
	            var appId = factorData.profile.appId;
	            var registeredKeys = [{version: factorData.profile.version, keyHandle: factorData.profile.credentialId }];
	            self.trigger('request');

	            var deferred = Q.defer();
	            u2f.sign(appId, factorData.challenge.nonce, registeredKeys, function (data) {
	              self.trigger('errors:clear');
	              if (data.errorCode && data.errorCode !== 0) {
	                var isOneFactor = self.options.appState.get('factors').length === 1;
	                deferred.reject({xhr: {responseJSON:
	                  {errorSummary: Okta.loc(getErrorMessageKeyByCode(data.errorCode, isOneFactor), 'login')}}});
	              } else {
	                return factor.verify({
	                  clientData: data.clientData,
	                  signatureData: data.signatureData
	                })
	                .then(deferred.resolve);
	              }
	            });
	            return deferred.promise;
	          });
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      hasSavingState: false,
	      title: _.partial(Okta.loc, 'factor.u2f', 'login'),
	      className: 'verify-u2f-form',
	      noCancelButton: true,
	      save: _.partial(Okta.loc, 'verify.u2f.retry', 'login'),
	      noButtonBar: function () {
	        return !window.hasOwnProperty('u2f');
	      },
	      modelEvents: {
	        'request': '_startEnrollment',
	        'error': '_stopEnrollment'
	      },

	      formChildren: function () {
	        var result = [];

	        if (!window.hasOwnProperty('u2f')) {
	          var errorMessageKey = 'u2f.error.notSupportedBrowser';

	          if (BrowserFeatures.isFirefox()) {
	            errorMessageKey = 'u2f.error.noFirefoxExtension';
	          }
	          else if (this.options.appState.get('factors').length === 1) {
	            errorMessageKey = 'u2f.error.notSupportedBrowser.oneFactor';
	          }

	          result.push(FormType.View(
	            {View: new HtmlErrorMessageView({message: Okta.loc(errorMessageKey, 'login')})},
	            {selector: '.o-form-error-container'}
	          ));
	        }
	        else {
	          result.push(FormType.View({
	            View: '\
	            <div class="u2f-verify-text">\
	              <p>{{i18n code="verify.u2f.instructions" bundle="login"}}</p>\
	              <p>{{i18n code="verify.u2f.instructionsBluetooth" bundle="login"}}</p>\
	              <div data-se="u2f-waiting" class="okta-waiting-spinner"></div>\
	            </div>'
	          }));
	        }

	        return result;
	      },

	      postRender: function () {
	        _.defer(_.bind(function () {
	          if (window.hasOwnProperty('u2f')) {
	            this.model.save();
	          }
	          else {
	            this.$('[data-se="u2f-waiting"]').addClass('hide');
	          }
	        }, this));
	      },

	      _startEnrollment: function () {
	        this.$('.okta-waiting-spinner').removeClass('hide');
	        this.$('.o-form-button-bar').hide();
	      },

	      _stopEnrollment: function () {
	        this.$('.okta-waiting-spinner').addClass('hide');
	        this.$('.o-form-button-bar').show();
	      }
	    },

	    Footer: FooterSignout
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 146 */
/***/ function(module, exports) {

	
	//Copyright 2014-2015 Google Inc. All rights reserved.

	//Use of this source code is governed by a BSD-style
	//license that can be found in the LICENSE file or at
	//https://developers.google.com/open-source/licenses/bsd

	/**
	 * @fileoverview The U2F api.
	 */
	'use strict';

	(function (){
	  if ('u2f' in window || !('chrome' in window)) {
	    return;
	  }

	  /** Namespace for the U2F api.
	   * @type {Object}
	   */
	  var u2f = window.u2f = {};

	  /**
	   * FIDO U2F Javascript API Version
	   * @number
	   */
	  var js_api_version;

	  /**
	   * The U2F extension id
	   * @const {string}
	   */
	  // The Chrome packaged app extension ID.
	  // Uncomment this if you want to deploy a server instance that uses
	  // the package Chrome app and does not require installing the U2F Chrome extension.
	   u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';
	  // The U2F Chrome extension ID.
	  // Uncomment this if you want to deploy a server instance that uses
	  // the U2F Chrome extension to authenticate.
	  // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';


	  /**
	   * Message types for messsages to/from the extension
	   * @const
	   * @enum {string}
	   */
	  u2f.MessageTypes = {
	      'U2F_REGISTER_REQUEST': 'u2f_register_request',
	      'U2F_REGISTER_RESPONSE': 'u2f_register_response',
	      'U2F_SIGN_REQUEST': 'u2f_sign_request',
	      'U2F_SIGN_RESPONSE': 'u2f_sign_response',
	      'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',
	      'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'
	  };


	  /**
	   * Response status codes
	   * @const
	   * @enum {number}
	   */
	  u2f.ErrorCodes = {
	      'OK': 0,
	      'OTHER_ERROR': 1,
	      'BAD_REQUEST': 2,
	      'CONFIGURATION_UNSUPPORTED': 3,
	      'DEVICE_INELIGIBLE': 4,
	      'TIMEOUT': 5
	  };


	  /**
	   * A message for registration requests
	   * @typedef {{
	   *   type: u2f.MessageTypes,
	   *   appId: ?string,
	   *   timeoutSeconds: ?number,
	   *   requestId: ?number
	   * }}
	   */
	  u2f.U2fRequest;


	  /**
	   * A message for registration responses
	   * @typedef {{
	   *   type: u2f.MessageTypes,
	   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),
	   *   requestId: ?number
	   * }}
	   */
	  u2f.U2fResponse;


	  /**
	   * An error object for responses
	   * @typedef {{
	   *   errorCode: u2f.ErrorCodes,
	   *   errorMessage: ?string
	   * }}
	   */
	  u2f.Error;

	  /**
	   * Data object for a single sign request.
	   * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}
	   */
	  u2f.Transport;


	  /**
	   * Data object for a single sign request.
	   * @typedef {Array<u2f.Transport>}
	   */
	  u2f.Transports;

	  /**
	   * Data object for a single sign request.
	   * @typedef {{
	   *   version: string,
	   *   challenge: string,
	   *   keyHandle: string,
	   *   appId: string
	   * }}
	   */
	  u2f.SignRequest;


	  /**
	   * Data object for a sign response.
	   * @typedef {{
	   *   keyHandle: string,
	   *   signatureData: string,
	   *   clientData: string
	   * }}
	   */
	  u2f.SignResponse;


	  /**
	   * Data object for a registration request.
	   * @typedef {{
	   *   version: string,
	   *   challenge: string
	   * }}
	   */
	  u2f.RegisterRequest;


	  /**
	   * Data object for a registration response.
	   * @typedef {{
	   *   version: string,
	   *   keyHandle: string,
	   *   transports: Transports,
	   *   appId: string
	   * }}
	   */
	  u2f.RegisterResponse;


	  /**
	   * Data object for a registered key.
	   * @typedef {{
	   *   version: string,
	   *   keyHandle: string,
	   *   transports: ?Transports,
	   *   appId: ?string
	   * }}
	   */
	  u2f.RegisteredKey;


	  /**
	   * Data object for a get API register response.
	   * @typedef {{
	   *   js_api_version: number
	   * }}
	   */
	  u2f.GetJsApiVersionResponse;


	  //Low level MessagePort API support

	  /**
	   * Sets up a MessagePort to the U2F extension using the
	   * available mechanisms.
	   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
	   */
	  u2f.getMessagePort = function(callback) {
	    if (typeof chrome != 'undefined' && chrome.runtime) {
	      // The actual message here does not matter, but we need to get a reply
	      // for the callback to run. Thus, send an empty signature request
	      // in order to get a failure response.
	      var msg = {
	          type: u2f.MessageTypes.U2F_SIGN_REQUEST,
	          signRequests: []
	      };
	      chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {
	        if (!chrome.runtime.lastError) {
	          // We are on a whitelisted origin and can talk directly
	          // with the extension.
	          u2f.getChromeRuntimePort_(callback);
	        } else {
	          // chrome.runtime was available, but we couldn't message
	          // the extension directly, use iframe
	          u2f.getIframePort_(callback);
	        }
	      });
	    } else if (u2f.isAndroidChrome_()) {
	      u2f.getAuthenticatorPort_(callback);
	    } else if (u2f.isIosChrome_()) {
	      u2f.getIosPort_(callback);
	    } else {
	      // chrome.runtime was not available at all, which is normal
	      // when this origin doesn't have access to any extensions.
	      u2f.getIframePort_(callback);
	    }
	  };

	  /**
	   * Detect chrome running on android based on the browser's useragent.
	   * @private
	   */
	  u2f.isAndroidChrome_ = function() {
	    var userAgent = navigator.userAgent;
	    return userAgent.indexOf('Chrome') != -1 &&
	    userAgent.indexOf('Android') != -1;
	  };

	  /**
	   * Detect chrome running on iOS based on the browser's platform.
	   * @private
	   */
	  u2f.isIosChrome_ = function() {
	    return $.inArray(navigator.platform, ["iPhone", "iPad", "iPod"]) > -1;
	  };

	  /**
	   * Connects directly to the extension via chrome.runtime.connect.
	   * @param {function(u2f.WrappedChromeRuntimePort_)} callback
	   * @private
	   */
	  u2f.getChromeRuntimePort_ = function(callback) {
	    var port = chrome.runtime.connect(u2f.EXTENSION_ID,
	        {'includeTlsChannelId': true});
	    setTimeout(function() {
	      callback(new u2f.WrappedChromeRuntimePort_(port));
	    }, 0);
	  };

	  /**
	   * Return a 'port' abstraction to the Authenticator app.
	   * @param {function(u2f.WrappedAuthenticatorPort_)} callback
	   * @private
	   */
	  u2f.getAuthenticatorPort_ = function(callback) {
	    setTimeout(function() {
	      callback(new u2f.WrappedAuthenticatorPort_());
	    }, 0);
	  };

	  /**
	   * Return a 'port' abstraction to the iOS client app.
	   * @param {function(u2f.WrappedIosPort_)} callback
	   * @private
	   */
	  u2f.getIosPort_ = function(callback) {
	    setTimeout(function() {
	      callback(new u2f.WrappedIosPort_());
	    }, 0);
	  };

	  /**
	   * A wrapper for chrome.runtime.Port that is compatible with MessagePort.
	   * @param {Port} port
	   * @constructor
	   * @private
	   */
	  u2f.WrappedChromeRuntimePort_ = function(port) {
	    this.port_ = port;
	  };

	  /**
	   * Format and return a sign request compliant with the JS API version supported by the extension.
	   * @param {Array<u2f.SignRequest>} signRequests
	   * @param {number} timeoutSeconds
	   * @param {number} reqId
	   * @return {Object}
	   */
	  u2f.formatSignRequest_ =
	    function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {
	    if (js_api_version === undefined || js_api_version < 1.1) {
	      // Adapt request to the 1.0 JS API
	      var signRequests = [];
	      for (var i = 0; i < registeredKeys.length; i++) {
	        signRequests[i] = {
	            version: registeredKeys[i].version,
	            challenge: challenge,
	            keyHandle: registeredKeys[i].keyHandle,
	            appId: appId
	        };
	      }
	      return {
	        type: u2f.MessageTypes.U2F_SIGN_REQUEST,
	        signRequests: signRequests,
	        timeoutSeconds: timeoutSeconds,
	        requestId: reqId
	      };
	    }
	    // JS 1.1 API
	    return {
	      type: u2f.MessageTypes.U2F_SIGN_REQUEST,
	      appId: appId,
	      challenge: challenge,
	      registeredKeys: registeredKeys,
	      timeoutSeconds: timeoutSeconds,
	      requestId: reqId
	    };
	  };

	  /**
	   * Format and return a register request compliant with the JS API version supported by the extension..
	   * @param {Array<u2f.SignRequest>} signRequests
	   * @param {Array<u2f.RegisterRequest>} signRequests
	   * @param {number} timeoutSeconds
	   * @param {number} reqId
	   * @return {Object}
	   */
	  u2f.formatRegisterRequest_ =
	    function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {
	    if (js_api_version === undefined || js_api_version < 1.1) {
	      // Adapt request to the 1.0 JS API
	      for (var i = 0; i < registerRequests.length; i++) {
	        registerRequests[i].appId = appId;
	      }
	      var signRequests = [];
	      for (var i = 0; i < registeredKeys.length; i++) {
	        signRequests[i] = {
	            version: registeredKeys[i].version,
	            challenge: registerRequests[0],
	            keyHandle: registeredKeys[i].keyHandle,
	            appId: appId
	        };
	      }
	      return {
	        type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
	        signRequests: signRequests,
	        registerRequests: registerRequests,
	        timeoutSeconds: timeoutSeconds,
	        requestId: reqId
	      };
	    }
	    // JS 1.1 API
	    return {
	      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
	      appId: appId,
	      registerRequests: registerRequests,
	      registeredKeys: registeredKeys,
	      timeoutSeconds: timeoutSeconds,
	      requestId: reqId
	    };
	  };


	  /**
	   * Posts a message on the underlying channel.
	   * @param {Object} message
	   */
	  u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
	    this.port_.postMessage(message);
	  };


	  /**
	   * Emulates the HTML 5 addEventListener interface. Works only for the
	   * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.
	   * @param {string} eventName
	   * @param {function({data: Object})} handler
	   */
	  u2f.WrappedChromeRuntimePort_.prototype.addEventListener =
	      function(eventName, handler) {
	    var name = eventName.toLowerCase();
	    if (name == 'message' || name == 'onmessage') {
	      this.port_.onMessage.addListener(function(message) {
	        // Emulate a minimal MessageEvent object
	        handler({'data': message});
	      });
	    } else {
	      console.error('WrappedChromeRuntimePort only supports onMessage');
	    }
	  };

	  /**
	   * Wrap the Authenticator app with a MessagePort interface.
	   * @constructor
	   * @private
	   */
	  u2f.WrappedAuthenticatorPort_ = function() {
	    this.requestId_ = -1;
	    this.requestObject_ = null;
	  }

	  /**
	   * Launch the Authenticator intent.
	   * @param {Object} message
	   */
	  u2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {
	    var intentUrl =
	      u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +
	      ';S.request=' + encodeURIComponent(JSON.stringify(message)) +
	      ';end';
	    document.location = intentUrl;
	  };

	  /**
	   * Tells what type of port this is.
	   * @return {String} port type
	   */
	  u2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {
	    return "WrappedAuthenticatorPort_";
	  };


	  /**
	   * Emulates the HTML 5 addEventListener interface.
	   * @param {string} eventName
	   * @param {function({data: Object})} handler
	   */
	  u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {
	    var name = eventName.toLowerCase();
	    if (name == 'message') {
	      var self = this;
	      /* Register a callback to that executes when
	       * chrome injects the response. */
	      window.addEventListener(
	          'message', self.onRequestUpdate_.bind(self, handler), false);
	    } else {
	      console.error('WrappedAuthenticatorPort only supports message');
	    }
	  };

	  /**
	   * Callback invoked  when a response is received from the Authenticator.
	   * @param function({data: Object}) callback
	   * @param {Object} message message Object
	   */
	  u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =
	      function(callback, message) {
	    var messageObject = JSON.parse(message.data);
	    var intentUrl = messageObject['intentURL'];

	    var errorCode = messageObject['errorCode'];
	    var responseObject = null;
	    if (messageObject.hasOwnProperty('data')) {
	      responseObject = /** @type {Object} */ (
	          JSON.parse(messageObject['data']));
	    }

	    callback({'data': responseObject});
	  };

	  /**
	   * Base URL for intents to Authenticator.
	   * @const
	   * @private
	   */
	  u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =
	    'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';

	  /**
	   * Wrap the iOS client app with a MessagePort interface.
	   * @constructor
	   * @private
	   */
	  u2f.WrappedIosPort_ = function() {};

	  /**
	   * Launch the iOS client app request
	   * @param {Object} message
	   */
	  u2f.WrappedIosPort_.prototype.postMessage = function(message) {
	    var str = JSON.stringify(message);
	    var url = "u2f://auth?" + encodeURI(str);
	    location.replace(url);
	  };

	  /**
	   * Tells what type of port this is.
	   * @return {String} port type
	   */
	  u2f.WrappedIosPort_.prototype.getPortType = function() {
	    return "WrappedIosPort_";
	  };

	  /**
	   * Emulates the HTML 5 addEventListener interface.
	   * @param {string} eventName
	   * @param {function({data: Object})} handler
	   */
	  u2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {
	    var name = eventName.toLowerCase();
	    if (name !== 'message') {
	      console.error('WrappedIosPort only supports message');
	    }
	  };

	  /**
	   * Sets up an embedded trampoline iframe, sourced from the extension.
	   * @param {function(MessagePort)} callback
	   * @private
	   */
	  u2f.getIframePort_ = function(callback) {
	    // Create the iframe
	    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;
	    var iframe = document.createElement('iframe');
	    iframe.src = iframeOrigin + '/u2f-comms.html';
	    iframe.setAttribute('style', 'display:none');
	    document.body.appendChild(iframe);

	    var channel = new MessageChannel();
	    var ready = function(message) {
	      if (message.data == 'ready') {
	        channel.port1.removeEventListener('message', ready);
	        callback(channel.port1);
	      } else {
	        console.error('First event on iframe port was not "ready"');
	      }
	    };
	    channel.port1.addEventListener('message', ready);
	    channel.port1.start();

	    iframe.addEventListener('load', function() {
	      // Deliver the port to the iframe and initialize
	      iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);
	    });
	  };


	  //High-level JS API

	  /**
	   * Default extension response timeout in seconds.
	   * @const
	   */
	  u2f.EXTENSION_TIMEOUT_SEC = 30;

	  /**
	   * A singleton instance for a MessagePort to the extension.
	   * @type {MessagePort|u2f.WrappedChromeRuntimePort_}
	   * @private
	   */
	  u2f.port_ = null;

	  /**
	   * Callbacks waiting for a port
	   * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}
	   * @private
	   */
	  u2f.waitingForPort_ = [];

	  /**
	   * A counter for requestIds.
	   * @type {number}
	   * @private
	   */
	  u2f.reqCounter_ = 0;

	  /**
	   * A map from requestIds to client callbacks
	   * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))
	   *                       |function((u2f.Error|u2f.SignResponse)))>}
	   * @private
	   */
	  u2f.callbackMap_ = {};

	  /**
	   * Creates or retrieves the MessagePort singleton to use.
	   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
	   * @private
	   */
	  u2f.getPortSingleton_ = function(callback) {
	    if (u2f.port_) {
	      callback(u2f.port_);
	    } else {
	      if (u2f.waitingForPort_.length == 0) {
	        u2f.getMessagePort(function(port) {
	          u2f.port_ = port;
	          u2f.port_.addEventListener('message',
	              /** @type {function(Event)} */ (u2f.responseHandler_));

	          // Careful, here be async callbacks. Maybe.
	          while (u2f.waitingForPort_.length)
	            u2f.waitingForPort_.shift()(u2f.port_);
	        });
	      }
	      u2f.waitingForPort_.push(callback);
	    }
	  };

	  /**
	   * Handles response messages from the extension.
	   * @param {MessageEvent.<u2f.Response>} message
	   * @private
	   */
	  u2f.responseHandler_ = function(message) {
	    var response = message.data;
	    var reqId = response['requestId'];
	    if (!reqId || !u2f.callbackMap_[reqId]) {
	      console.error('Unknown or missing requestId in response.');
	      return;
	    }
	    var cb = u2f.callbackMap_[reqId];
	    delete u2f.callbackMap_[reqId];
	    cb(response['responseData']);
	  };

	  /**
	   * Dispatches an array of sign requests to available U2F tokens.
	   * If the JS API version supported by the extension is unknown, it first sends a
	   * message to the extension to find out the supported API version and then it sends
	   * the sign request.
	   * @param {string=} appId
	   * @param {string=} challenge
	   * @param {Array<u2f.RegisteredKey>} registeredKeys
	   * @param {function((u2f.Error|u2f.SignResponse))} callback
	   * @param {number=} opt_timeoutSeconds
	   */
	  u2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
	    if (js_api_version === undefined) {
	      // Send a message to get the extension to JS API version, then send the actual sign request.
	      u2f.getApiVersion(
	          function (response) {
	            js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];
	            console.log("Extension JS API Version: ", js_api_version);
	            u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
	          });
	    } else {
	      // We know the JS API version. Send the actual sign request in the supported API version.
	      u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
	    }
	  };

	  /**
	   * Dispatches an array of sign requests to available U2F tokens.
	   * @param {string=} appId
	   * @param {string=} challenge
	   * @param {Array<u2f.RegisteredKey>} registeredKeys
	   * @param {function((u2f.Error|u2f.SignResponse))} callback
	   * @param {number=} opt_timeoutSeconds
	   */
	  u2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
	    u2f.getPortSingleton_(function(port) {
	      var reqId = ++u2f.reqCounter_;
	      u2f.callbackMap_[reqId] = callback;
	      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?
	          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);
	      var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);
	      port.postMessage(req);
	    });
	  };

	  /**
	   * Dispatches register requests to available U2F tokens. An array of sign
	   * requests identifies already registered tokens.
	   * If the JS API version supported by the extension is unknown, it first sends a
	   * message to the extension to find out the supported API version and then it sends
	   * the register request.
	   * @param {string=} appId
	   * @param {Array<u2f.RegisterRequest>} registerRequests
	   * @param {Array<u2f.RegisteredKey>} registeredKeys
	   * @param {function((u2f.Error|u2f.RegisterResponse))} callback
	   * @param {number=} opt_timeoutSeconds
	   */
	  u2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
	    if (js_api_version === undefined) {
	      // Send a message to get the extension to JS API version, then send the actual register request.
	      u2f.getApiVersion(
	          function (response) {
	            js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];
	            console.log("Extension JS API Version: ", js_api_version);
	            u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,
	                callback, opt_timeoutSeconds);
	          });
	    } else {
	      // We know the JS API version. Send the actual register request in the supported API version.
	      u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,
	          callback, opt_timeoutSeconds);
	    }
	  };

	  /**
	   * Dispatches register requests to available U2F tokens. An array of sign
	   * requests identifies already registered tokens.
	   * @param {string=} appId
	   * @param {Array<u2f.RegisterRequest>} registerRequests
	   * @param {Array<u2f.RegisteredKey>} registeredKeys
	   * @param {function((u2f.Error|u2f.RegisterResponse))} callback
	   * @param {number=} opt_timeoutSeconds
	   */
	  u2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
	    u2f.getPortSingleton_(function(port) {
	      var reqId = ++u2f.reqCounter_;
	      u2f.callbackMap_[reqId] = callback;
	      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?
	          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);
	      var req = u2f.formatRegisterRequest_(
	          appId, registeredKeys, registerRequests, timeoutSeconds, reqId);
	      port.postMessage(req);
	    });
	  };


	  /**
	   * Dispatches a message to the extension to find out the supported
	   * JS API version.
	   * If the user is on a mobile phone and is thus using Google Authenticator instead
	   * of the Chrome extension, don't send the request and simply return 0.
	   * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback
	   * @param {number=} opt_timeoutSeconds
	   */
	  u2f.getApiVersion = function(callback, opt_timeoutSeconds) {
	   u2f.getPortSingleton_(function(port) {
	     // If we are using Android Google Authenticator or iOS client app,
	     // do not fire an intent to ask which JS API version to use.
	     if (port.getPortType) {
	       var apiVersion;
	       switch (port.getPortType()) {
	         case 'WrappedIosPort_':
	         case 'WrappedAuthenticatorPort_':
	           apiVersion = 1.1;
	           break;

	         default:
	           apiVersion = 0;
	           break;
	       }
	       callback({ 'js_api_version': apiVersion });
	       return;
	     }
	      var reqId = ++u2f.reqCounter_;
	      u2f.callbackMap_[reqId] = callback;
	      var req = {
	        type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,
	        timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
	            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
	        requestId: reqId
	      };
	      port.postMessage(req);
	    });
	  };
	})();


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint maxcomplexity:9*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(112),
	  __webpack_require__(109),
	  __webpack_require__(99),
	  __webpack_require__(148),
	  __webpack_require__(149)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, Enums, RouterUtil, Toolbar, FactorList,
	          RequiredFactorList) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-choices',
	    state: {
	      pageType: null
	    },

	    Model: {},

	    Form: {
	      noCancelButton: true,

	      title: _.partial(Okta.loc, 'enroll.choices.title', 'login'),

	      noButtonBar: function () {
	        return this.state.get('pageType') === Enums.ALL_OPTIONAL_NONE_ENROLLED;
	      },

	      subtitle: function () {
	        switch (this.state.get('pageType')) {
	        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
	        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
	          return Okta.loc('enroll.choices.optional', 'login');
	        default:
	          return Okta.loc('enroll.choices.description', 'login');
	        }
	      },

	      save: function () {
	        switch (this.state.get('pageType')) {
	        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
	        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
	          return Okta.loc('enroll.choices.submit.finish', 'login');
	        case Enums.HAS_REQUIRED_NONE_ENROLLED:
	          return Okta.loc('enroll.choices.submit.configure', 'login');
	        case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
	          return Okta.loc('enroll.choices.submit.next', 'login');
	        default:
	          return '';
	        }
	      },

	      initialize: function (options) {
	        this.listenTo(this, 'save', function () {
	          var current;
	          switch (this.state.get('pageType')) {
	          case Enums.HAS_REQUIRED_NONE_ENROLLED:
	          case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
	            current = options.appState.get('factors').getFirstUnenrolledRequiredFactor();
	            options.appState.trigger('navigate', RouterUtil.createEnrollFactorUrl(
	              current.get('provider'),
	              current.get('factorType')
	            ));
	            break;
	          default:
	            return this.model.doTransaction(function(transaction) {
	              return transaction.skip();
	            });
	          }
	        });
	      },

	      preRender: function () {
	        var factors = this.options.appState.get('factors');
	        switch(this.state.get('pageType')) {
	        case Enums.HAS_REQUIRED_NONE_ENROLLED:
	        case Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED:
	          this.add(new RequiredFactorList({
	            minimize: true,
	            collection: new Okta.Collection(factors.where({ required: true })),
	            appState: this.options.appState
	          }));
	          break;
	        case Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED:
	        case Enums.ALL_OPTIONAL_SOME_ENROLLED:
	        case Enums.ALL_OPTIONAL_NONE_ENROLLED:
	          var enrolled = factors.where({ enrolled: true }),
	              notEnrolled = factors.where({ enrolled: false }),
	              notEnrolledListTitle;
	          if (enrolled.length > 0) {
	            notEnrolledListTitle = Okta.loc('enroll.choices.list.optional', 'login');
	            this.add(new FactorList({
	              listTitle: Okta.loc('enroll.choices.list.enrolled', 'login'),
	              minimize: true,
	              collection: new Okta.Collection(enrolled),
	              appState: this.options.appState
	            }));
	          }
	          this.add(new FactorList({
	            listTitle: notEnrolledListTitle,
	            collection: new Okta.Collection(notEnrolled),
	            appState: this.options.appState
	          }));
	          break;
	        }
	      }

	    },

	    initialize: function (options) {
	      var numRequiredEnrolled = 0,
	          numRequiredNotEnrolled = 0,
	          numOptionalEnrolled = 0,
	          numOptionalNotEnrolled = 0,
	          hasRequired,
	          pageType;

	      options.appState.get('factors').each(function (factor) {
	        var required = factor.get('required'),
	            enrolled = factor.get('enrolled');
	        if (required && enrolled) {
	          numRequiredEnrolled++;
	        }
	        else if (required && !enrolled) {
	          numRequiredNotEnrolled++;
	        }
	        else if (!required && enrolled) {
	          numOptionalEnrolled++;
	        }
	        else if (!required && !enrolled) {
	          numOptionalNotEnrolled++;
	        }
	      });

	      hasRequired = numRequiredEnrolled > 0 || numRequiredNotEnrolled > 0;

	      // There are 5 possible states this screen can be in:

	      // 1. Has required, but none have been enrolled. Wizard start page.
	      if (hasRequired && numRequiredEnrolled === 0) {
	        pageType = Enums.HAS_REQUIRED_NONE_ENROLLED;
	      }

	      // 2. Has required, and have enrolled at least one. The page layout
	      //    to configure the remaining required factors.
	      else if (hasRequired && numRequiredNotEnrolled > 0) {
	        pageType = Enums.HAS_REQUIRED_SOME_REQUIRED_ENROLLED;
	      }

	      // 3. Has required, and finished enrolling all required factors. The
	      //    page layout you see to configure any optional factors or skip.
	      else if (hasRequired && numOptionalNotEnrolled > 0) {
	        pageType = Enums.HAS_REQUIRED_ALL_REQUIRED_ENROLLED;
	      }

	      // 4. Factors are all optional, no factors enrolled.
	      else if (numOptionalEnrolled === 0 && numOptionalNotEnrolled > 0) {
	        pageType = Enums.ALL_OPTIONAL_NONE_ENROLLED;
	      }

	      // 5. Factors are all optional, some factors have already been
	      //    enrolled (can either enroll more or skip).
	      else if (numOptionalNotEnrolled > 0) {
	        pageType = Enums.ALL_OPTIONAL_SOME_ENROLLED;
	      }

	      // 6. Factors are all optional, all factors have already been
	      //    enrolled, among them there is OktaVerify with Push enrolled as totp
	      //    (API return OktaVerify push factor as unenrolled in this case and as we always merge
	      //    push and totp in UI so we redirect to skip link here).
	      else {
	        this.model.doTransaction(function(transaction) {
	          return transaction.skip();
	        });
	      }

	      this.state.set('pageType', pageType);
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(109)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, RouterUtil) {

	  var _ = Okta._;

	  var FactorRow = Okta.View.extend({
	    className: 'enroll-factor-row clearfix',

	    template: '\
	      <div class="enroll-factor-icon-container">\
	        <div class="factor-icon enroll-factor-icon {{iconClassName}}">\
	        </div>\
	      </div>\
	      <div class="enroll-factor-description">\
	        <h3 class="enroll-factor-label">{{factorLabel}}</h3>\
	        {{#if factorDescription}}\
	          <p>{{factorDescription}}</p>\
	        {{/if}}\
	        <div class="enroll-factor-button"></div>\
	      </div>\
	    ',

	    attributes: function () {
	      return { 'data-se': this.model.get('factorName') };
	    },

	    children: function () {
	      if (this.model.get('enrolled')) {
	        return [['<span class="icon success-16-green"></span>', '.enroll-factor-label']];
	      }
	      else if (this.model.get('enrollment') === 'REQUIRED') {
	        return [['<span class="icon success-16-gray"></span>', '.enroll-factor-label']];
	      }

	      return [[Okta.createButton({
	        className: 'button',
	        title: Okta.loc('enroll.choices.setup', 'login'),
	        click: function () {
	          this.options.appState.trigger('navigate', RouterUtil.createEnrollFactorUrl(
	            this.model.get('provider'),
	            this.model.get('factorType')
	          ));
	        }
	      }), '.enroll-factor-button']];
	    },

	    minimize: function () {
	      this.$el.addClass('enroll-factor-row-min');
	    },

	    maximize: function () {
	      this.$el.removeClass('enroll-factor-row-min');
	    }
	  });

	  return Okta.ListView.extend({

	    className: 'enroll-factor-list',

	    item: FactorRow,

	    itemSelector: '.list-content',

	    template: '\
	      {{#if listSubtitle}}\
	        <div class="list-subtitle">{{listSubtitle}}</div>\
	      {{/if}}\
	      {{#if listTitle}}\
	        <div class="list-title">{{listTitle}}</div>\
	      {{/if}}\
	      <div class="list-content"></div>\
	    ',

	    getTemplateData: function () {
	      var json = Okta.ListView.prototype.getTemplateData.call(this);
	      _.extend(json, this);
	      return json;
	    },

	    postRender: function () {
	      if (this.options.minimize) {
	        this.invoke('minimize');
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(148)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorList) {

	  var _ = Okta._;

	  return FactorList.extend({

	    listTitle: _.partial(Okta.loc, 'enroll.choices.list.setup', 'login'),

	    className: function () {
	      return FactorList.prototype.className + ' enroll-required-factor-list';
	    },

	    initialize: function () {
	      var numRequired = this.collection.length,
	          numCompleted = this.collection.where({ enrolled: true }).length,
	          currentStep = numCompleted + 1;
	      this.listSubtitle = Okta.loc('enroll.choices.step', 'login', [currentStep, numRequired]);
	    },

	    postRender: function () {
	      var currentModel, currentRow;
	      FactorList.prototype.postRender.apply(this, arguments);
	      currentModel = this.options.appState.get('factors').getFirstUnenrolledRequiredFactor();
	      currentRow = this.find(function (view) {
	        return view.model === currentModel;
	      });
	      currentRow.maximize();
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint camelcase:false, newcap:false */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(128),
	  __webpack_require__(9),
	  __webpack_require__(105),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Duo, Q, FormController, Footer) {

	  var $ = Okta.$,
	      _ = Okta._;

	  return FormController.extend({

	    className: 'enroll-duo duo-form',

	    Model: {
	      props: {
	        host: 'string',
	        signature: 'string',
	        postAction: 'string',
	        factorId: 'string',
	        stateToken: 'string'
	      },

	      getInitOptions: function () {
	        return this.doTransaction(function (transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'web',
	            provider: 'DUO'
	          });
	          return factor.enroll();
	        });
	      },

	      activate: function (signedResponse) {
	        // Note: We should be doing this in OktaAuth! Fix when it's updated.
	        var url = this.get('postAction'),
	            factorId = this.get('factorId'),
	            self = this,
	            data = {
	              id: factorId,
	              stateToken: this.get('stateToken'),
	              sig_response: signedResponse
	            };
	        // We don't actually use authClient.post() here (unlike all the other cases in the
	        // sign-in widget) since the endpoint is wired to accept serialized form post instead
	        // of a JSON post ($.post() is different from authClient.post() in that in $.post(),
	        // jquery decides the Content-Type instead of it being a JSON type). Enroll/Verify DUO
	        // are the only two places where we actually do this.
	        // NOTE - If we ever decide to change this, we should test this very carefully.
	        return Q($.post(url, data))
	        .then(function () {
	          return self.doTransaction(function (transaction) {
	            return transaction.poll();
	          });
	        })
	        .fail(function (err) {
	          self.trigger('error', self, err.xhr);
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      noButtonBar: true,
	      title: _.partial(Okta.loc, 'enroll.duo.title', 'login'),

	      postRender: function () {
	        this.add('<iframe frameborder="0" title="' + this.title() + '"></iframe>');
	        Duo.init({
	          'host': this.model.get('host'),
	          'sig_request': this.model.get('signature'),
	          'iframe': this.$('iframe').get(0),
	          'post_action': _.bind(this.model.activate, this.model)
	        });
	      }
	    },

	    Footer: Footer,

	    fetchInitialData: function () {
	      var self = this;
	      return this.model.getInitOptions(this.options.appState)
	      .then(function (trans) {
	        var res = trans.data;
	        if (!res ||
	            !res._embedded ||
	            !res._embedded.factor ||
	            !res._embedded.factor._embedded ||
	            !res._embedded.factor._embedded.activation) {
	          throw new Error('Response does not have duo activation options');
	        }

	        var factor = res._embedded.factor;
	        var activation = factor._embedded.activation;
	        self.model.set({
	          host: activation.host,
	          signature: activation.signature,
	          postAction: activation._links.complete.href,
	          factorId: factor.id,
	          stateToken: res.stateToken
	        });
	      });
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate')) {
	        return true;
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums) {

	  return Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="mfa.backToFactors" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      }
	    },

	    back: function () {
	      this.state.set('navigateDir', Enums.DIRECTION_BACK);
	      if (this.options.appState.get('prevLink')) {
	        // Once we are in the MFA_ENROLL_ACTIVATE, we need to reset to the
	        // correct state. Fortunately, this means that the router will
	        // handle navigation once the request is finished.
	        this.model.doTransaction(function (transaction) {
	          return transaction.prev();
	        });
	      }
	      else {
	        this.options.appState.trigger('navigate', 'signin/enroll');
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(104),
	  __webpack_require__(151),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FactorUtil, Footer, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-question',
	    Model: {
	      props: {
	        question: 'string',
	        answer: ['string', true]
	      },
	      local: {
	        securityQuestions: 'object'
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'question',
	            provider: 'OKTA'
	          });
	          return factor.enroll({
	            profile: {
	              question: this.get('question'),
	              answer: this.get('answer')
	            }
	          });
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      title: _.partial(Okta.loc, 'enroll.securityQuestion.setup', 'login'),
	      inputs: function () {
	        return [
	          {
	            label: false,
	            'label-top': true,
	            name: 'question',
	            type: 'select',
	            wide: true,
	            options: function () {
	              return this.model.get('securityQuestions');
	            },
	            params: {
	              searchThreshold: 25
	            }
	          },
	          {
	            label: false,
	            'label-top': true,
	            placeholder: Okta.loc('mfa.challenge.answer.placeholder', 'login'),
	            className: 'o-form-fieldset o-form-label-top auth-passcode',
	            name: 'answer',
	            input: TextBox,
	            type: 'text',
	            params: {
	              innerTooltip: Okta.loc('mfa.challenge.answer.tooltip', 'login')
	            }
	          }
	        ];
	      }
	    },

	    Footer: Footer,

	    fetchInitialData: function () {
	      var self = this;
	      return this.model.manageTransaction(function(transaction) {
	        var factor = _.findWhere(transaction.factors, {
	          factorType: 'question',
	          provider: 'OKTA'
	        });
	        return factor.questions();
	      })
	      .then(function(questionsRes) {
	        var questions = {};
	        _.each(questionsRes, function (question) {
	          questions[question.question] = FactorUtil.getSecurityQuestionLabel(question);
	        });
	        self.model.set('securityQuestions', questions);
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(142),
	  __webpack_require__(143),
	  __webpack_require__(151),
	  __webpack_require__(144)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, webauthn, Spinner, Footer, HtmlErrorMessageView) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-windows-hello',
	    Model: {
	      local: {
	        __isEnrolled__: 'boolean'
	      },

	      save: function () {
	        if (!webauthn.isAvailable()) {
	          return;
	        }

	        this.trigger('request');

	        if (this.get('__isEnrolled__')) {
	          return this.activate();
	        }

	        return this.doTransaction(function (transaction) {
	          return this._enroll(transaction);
	        });
	      },

	      _enroll: function (transaction) {
	        var factor = _.findWhere(transaction.factors, {
	          factorType: 'webauthn',
	          provider: 'FIDO'
	        });

	        return factor.enroll();
	      },

	      activate: function () {
	        this.set('__isEnrolled__', true);

	        return this.doTransaction(function (transaction) {
	          var activation = transaction.factor.activation;
	          var user = transaction.user;
	          var model = this;

	          var accountInfo = {
	            rpDisplayName: activation.rpDisplayName,
	            userDisplayName: user.profile.displayName,
	            accountName: user.profile.login,
	            userId: user.id
	          };
	          var cryptoParams = [{
	            algorithm: activation.algorithm
	          }];
	          var challenge = activation.nonce;

	          return webauthn.makeCredential(accountInfo, cryptoParams, challenge)
	          .then(function (creds) {
	            return transaction.activate({
	              credentialId: creds.credential.id,
	              publicKey: creds.publicKey,
	              attestation: null
	            });
	          })
	          .fail(function (error) {
	            switch (error.message) {
	            case 'AbortError':
	            case 'NotFoundError':
	            case 'NotSupportedError':
	              model.trigger('abort', error.message);
	              return transaction;
	            }

	            throw error;
	          });
	        });
	      }
	    },

	    Form: {
	      autoSave: true,
	      hasSavingState: false,
	      title: _.partial(Okta.loc, 'enroll.windowsHello.title', 'login'),
	      subtitle: function () {
	        return webauthn.isAvailable() ? Okta.loc('enroll.windowsHello.subtitle', 'login') : '';
	      },
	      save: _.partial(Okta.loc, 'enroll.windowsHello.save', 'login'),

	      customSavingState: {
	        stop: 'abort'
	      },

	      modelEvents: function () {
	        if (!webauthn.isAvailable()) {
	          return {};
	        }

	        return {
	          'request': '_startEnrollment',
	          'error': '_stopEnrollment',
	          'abort': '_stopEnrollment'
	        };
	      },

	      noButtonBar: function () {
	        return !webauthn.isAvailable();
	      },

	      formChildren: function () {
	        var result = [];

	        if (!webauthn.isAvailable()) {
	          result.push(
	            FormType.View(
	              { View: new HtmlErrorMessageView(
	                { message: Okta.loc('enroll.windowsHello.error.notWindows', 'login') }) },
	              { selector: '.o-form-error-container'}
	            )
	          );
	        }

	        result.push(FormType.View({ View: new Spinner({ model: this.model, visible: false }) }));

	        return result;
	      },

	      _startEnrollment: function () {
	        this.subtitle = Okta.loc('enroll.windowsHello.subtitle.loading', 'login');

	        this.model.trigger('spinner:show');
	        this._resetErrorMessage();

	        this.render();
	        this.$('.o-form-button-bar').addClass('hide');
	      },

	      _stopEnrollment: function (errorMessage) {
	        this.subtitle = Okta.loc('enroll.windowsHello.subtitle', 'login');

	        this.model.trigger('spinner:hide');
	        this.$('.o-form-button-bar').removeClass('hide');

	        var message;
	        switch (errorMessage){
	        case 'NotSupportedError':
	          message = Okta.loc('enroll.windowsHello.error.notConfiguredHtml', 'login');
	          break;
	        }

	        this._resetErrorMessage();

	        if (message){
	          var messageView = new HtmlErrorMessageView({
	            message: message
	          });

	          this.$('.o-form-error-container').addClass('o-form-has-errors');
	          this.add(messageView, { selector: '.o-form-error-container' });
	          this._errorMessageView = this.last();
	        }

	        this.render();
	      },


	      _resetErrorMessage: function () {
	        this._errorMessageView && this._errorMessageView.remove();
	        this._errorMessageView = undefined;
	        this.clearErrors();
	      }
	    },

	    Footer: Footer,

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate')) {
	        this.model.activate();
	        return true;
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(151),
	  __webpack_require__(155),
	  __webpack_require__(116),
	  __webpack_require__(156),
	  __webpack_require__(106),
	  __webpack_require__(64)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, Footer, PhoneTextBox, TextBox, CountryUtil, FormType, Keys) {

	  var _ = Okta._;
	  var API_RATE_LIMIT = 30000; //milliseconds

	  var factorIdIsDefined = {
	    factorId: function (val) {
	      return !_.isUndefined(val);
	    }
	  };

	  function isCallFactor(factorType) {
	    return factorType === 'call';
	  }

	  function getClassName(factorType) {
	    return isCallFactor(factorType) ? 'enroll-call' : 'enroll-sms';
	  }

	  function sendCode(e) {
	    if (Keys.isEnter(e)) {
	      e.stopPropagation();
	      e.preventDefault();
	      if (e.type === 'keyup' && e.data && e.data.model) {
	        e.data.model.sendCode();
	      }
	    }
	  }

	  return FormController.extend({
	    className: function () {
	      return getClassName(this.options.factorType);
	    },
	    Model: {
	      props: {
	        countryCode: ['string', true, 'US'],
	        phoneNumber: ['string', true],
	        phoneExtension: ['string', false],
	        lastEnrolledPhoneNumber: 'string',
	        passCode: ['string', true],
	        factorId: 'string'
	      },
	      local: {
	        hasExistingPhones: 'boolean',
	        trapEnrollment: 'boolean',
	        ableToResend: 'boolean',
	        factorType: 'string'
	      },
	      derived: {
	        countryCallingCode: {
	          deps: ['countryCode'],
	          fn: function (countryCode) {
	            return '+' + CountryUtil.getCallingCodeForCountry(countryCode);
	          }
	        },
	        fullPhoneNumber: {
	          deps: ['countryCallingCode', 'phoneNumber'],
	          fn: function (countryCallingCode, phoneNumber) {
	            return phoneNumber ? (countryCallingCode + phoneNumber) : '';
	          }
	        },
	        enrolled: {
	          deps: ['lastEnrolledPhoneNumber', 'fullPhoneNumber'],
	          fn: function (lastEnrolled, current) {
	            return lastEnrolled === current;
	          }
	        }
	      },
	      limitResending: function () {
	        this.set({ableToResend: false});
	        _.delay(_.bind(this.set, this), API_RATE_LIMIT, {ableToResend: true});
	      },
	      sendCode: function () {
	        var self = this;
	        var phoneNumber = this.get('fullPhoneNumber');
	        var phoneExtension = this.get('phoneExtension');

	        self.trigger('errors:clear');

	        if(!phoneNumber.length) {
	          self.trigger('invalid', self, {'phoneNumber': 'model.validation.field.blank'});
	          return;
	        }

	        return this.doTransaction(function(transaction) {
	          var isMfaEnroll = transaction.status === 'MFA_ENROLL';
	          var profileData = {
	            phoneNumber: phoneNumber,
	            updatePhone: isMfaEnroll ? self.get('hasExistingPhones') : true
	          };
	          if (isCallFactor(self.get('factorType'))) {
	            profileData['phoneExtension'] = phoneExtension;
	          }

	          if (isMfaEnroll) {
	            var factor = _.findWhere(transaction.factors, {
	              factorType: self.get('factorType'),
	              provider: 'OKTA'
	            });
	            return factor.enroll({
	              profile: profileData
	            });

	          } else {
	            // We must transition to MfaEnroll before updating the phone number
	            self.set('trapEnrollment', true);
	            return transaction.prev()
	            .then(function (trans) {
	              var factor = _.findWhere(trans.factors, {
	                factorType: self.get('factorType'),
	                provider: 'OKTA'
	              });
	              return factor.enroll({
	                profile: profileData
	             });
	            })
	            .then(function (trans) {
	              self.set('trapEnrollment', false);
	              return trans;
	            });
	          }
	        // Rethrow errors so we can change state
	        // AFTER setting the new transaction
	        }, true)
	        .then(function () {
	          self.set('lastEnrolledPhoneNumber', phoneNumber);
	          self.limitResending();
	        })
	        .fail(function () {
	          self.set('ableToResend', true);
	          self.set('trapEnrollment', false);
	        });
	      },
	      resendCode: function () {
	        this.trigger('errors:clear');
	        this.limitResending();
	        return this.doTransaction(function(transaction) {
	          return transaction.resend(this.get('factorType'));
	        });
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          return transaction.activate({
	            passCode: this.get('passCode')
	          });
	        });
	      }
	    },

	    Form: function () {
	      /*jshint maxcomplexity:8*/
	      var factorType = this.options.factorType;
	      var isCall = isCallFactor(factorType);

	      var formTitle = Okta.loc(isCall ? 'enroll.call.setup' : 'enroll.sms.setup', 'login');
	      var formSubmit = Okta.loc(isCall ? 'mfa.call' : 'mfa.sendCode', 'login');
	      var formRetry = Okta.loc(isCall ? 'mfa.redial' : 'mfa.resendCode', 'login');
	      var formSubmitted = Okta.loc(isCall ? 'mfa.calling' : 'mfa.sent', 'login');

	      var numberFieldClassName = isCall ? 'enroll-call-phone' : 'enroll-sms-phone';
	      var buttonClassName = isCall ? 'call-request-button' : 'sms-request-button';

	      var formChildren = [
	        FormType.Input({
	          name: 'countryCode',
	          type: 'select',
	          wide: true,
	          options: CountryUtil.getCountries()
	        }),
	        FormType.Input({
	          placeholder: Okta.loc('mfa.phoneNumber.placeholder', 'login'),
	          className: numberFieldClassName,
	          name: 'phoneNumber',
	          input: PhoneTextBox,
	          type: 'text',
	          render: function () {
	            this.$('input[name="phoneNumber"]')
	              .off('keydown keyup', sendCode)
	              .keydown(sendCode)
	              .keyup({model: this.model}, sendCode);
	          }
	        })
	      ];
	      if (isCall) {
	        formChildren.push(FormType.Input({
	          placeholder: Okta.loc('mfa.phoneNumber.ext.placeholder', 'login'),
	          className: 'enroll-call-extension',
	          name: 'phoneExtension',
	          input: TextBox,
	          type: 'text'
	        }));
	      }
	      formChildren.push(
	        FormType.Button({
	          title: formSubmit,
	          attributes: { 'data-se': buttonClassName },
	          className: 'button button-primary js-enroll-phone ' + buttonClassName,
	          click: function () {
	            this.model.sendCode();
	          }
	        }),
	        FormType.Button({
	          title: formRetry,
	          attributes: { 'data-se': buttonClassName },
	          className: 'button js-enroll-phone ' + buttonClassName,
	          click: function () {
	            this.model.resendCode();
	          },
	          initialize: function () {
	            this.$el.css({display: 'none'});
	            this.listenTo(this.model, 'change:ableToResend', function (model, ableToResend) {
	              if (ableToResend) {
	                this.options.title = formRetry;
	                this.enable();
	              } else {
	                this.options.title = formSubmitted;
	                this.disable();
	              }
	              this.render();
	            });
	          }
	        }),
	        FormType.Divider({
	          showWhen: factorIdIsDefined
	        }),
	        FormType.Input({
	          placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	          name: 'passCode',
	          input: TextBox,
	          type: 'number',
	          params: {
	            innerTooltip: Okta.loc('mfa.challenge.enterCode.tooltip', 'login')
	          },
	          showWhen: factorIdIsDefined
	        }),
	        FormType.Toolbar({
	          noCancelButton: true,
	          save: Okta.loc('mfa.challenge.verify', 'login'),
	          showWhen: factorIdIsDefined
	        })
	      );

	      return {
	        title: formTitle,
	        noButtonBar: true,
	        autoSave: true,
	        className: getClassName(factorType),
	        initialize: function () {
	          this.listenTo(this.model, 'error errors:clear', function () {
	            this.clearErrors();
	          });
	          this.listenTo(this.model, 'change:enrolled', function () {
	            this.$('.js-enroll-phone').toggle();
	          });
	        },
	        formChildren: formChildren
	      };
	    },

	    Footer: Footer,

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate')) {
	        this.model.set('factorId', this.options.appState.get('activatedFactorId'));
	        return true;
	      }
	      if (this.options.appState.get('isMfaEnroll') && this.model.get('trapEnrollment')) {
	        return true;
	      }
	    },

	    initialize: function () {
	      if (isCallFactor(this.options.factorType)) {
	        this.model.set('hasExistingPhones', this.options.appState.get('hasExistingPhonesForCall'));
	      } else {
	        this.model.set('hasExistingPhones', this.options.appState.get('hasExistingPhones'));
	      }
	      this.model.set('factorType', this.options.factorType);
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(62)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox) {

	  var _ = Okta._;

	  return TextBox.extend({

	    template: Okta.Handlebars.compile('\
	      <span class="okta-form-label-inline o-form-label-inline">{{countryCallingCode}}</span>\
	      <span class="okta-form-input-field input-fix o-form-control">\
	        <input type="{{type}}" placeholder="{{placeholder}}" name="{{name}}" \
	          id="{{inputId}}" value="{{value}}" autocomplete="off"/>\
	      </span>\
	    '),

	    initialize: function () {
	      this.listenTo(this.model, 'change:countryCallingCode', function () {
	        this.$('.o-form-label-inline').text(this.model.get('countryCallingCode'));
	      });
	    },

	    preRender: function () {
	      this.options.countryCallingCode = this.model.get('countryCallingCode');
	    },

	    postRender: function () {
	      // This is a hack - once inputGroups are done, get rid of it!!
	      this.$el.removeClass('input-fix o-form-control');
	      _.defer(_.bind(function () {
	        this.$el.parent().addClass('o-form-input-group');
	      }, this));
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(8),
	  __webpack_require__(157)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, bundles, countryCallingCodes) {

	  var fn = {};

	  // () => [{ countryCode: countryName }], sorted by countryName
	  fn.getCountries = function () {
	    // HM, BV, and TF do not have phone prefixes, so don't give the
	    // user the option to choose these countries. FYI it appears that these
	    // countries do not have calling codes because they are ~~uninhabited~~
	    var countries = _.omit(bundles.country, 'HM', 'BV', 'TF');

	    // Sort it; figure out if there is a better way to do this (best would
	    // be to sort it in the properties file!!)
	    var collection = _.map(countries, function (name, code) {
	      return { name: name, code: code };
	    });
	    collection = _.sortBy(collection, 'name');
	    var sorted = {};
	    _.each(collection, function (country) {
	      sorted[country.code] = country.name;
	    });

	    return sorted;
	  };

	  fn.getCallingCodeForCountry = function (countryCode) {
	    return countryCallingCodes[countryCode];
	  };

	  return fn;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(module.exports = {"US":"1","AG":"1","AI":"1","AS":"1","BB":"1","BM":"1","BS":"1","CA":"1","DM":"1","DO":"1","GD":"1","GU":"1","JM":"1","KN":"1","KY":"1","LC":"1","MP":"1","MS":"1","PR":"1","SX":"1","TC":"1","TT":"1","VC":"1","VG":"1","VI":"1","RU":"7","KZ":"7","EG":"20","ZA":"27","GR":"30","NL":"31","BE":"32","FR":"33","ES":"34","HU":"36","IT":"39","RO":"40","CH":"41","AT":"43","GB":"44","GG":"44","IM":"44","JE":"44","DK":"45","SE":"46","NO":"47","SJ":"47","PL":"48","DE":"49","PE":"51","MX":"52","CU":"53","AR":"54","BR":"55","CL":"56","CO":"57","VE":"58","MY":"60","AU":"61","CC":"61","CX":"61","ID":"62","PH":"63","NZ":"64","SG":"65","TH":"66","JP":"81","KR":"82","VN":"84","CN":"86","TR":"90","IN":"91","PK":"92","AF":"93","LK":"94","MM":"95","IR":"98","SS":"211","MA":"212","EH":"212","DZ":"213","TN":"216","LY":"218","GM":"220","SN":"221","MR":"222","ML":"223","GN":"224","CI":"225","BF":"226","NE":"227","TG":"228","BJ":"229","MU":"230","LR":"231","SL":"232","GH":"233","NG":"234","TD":"235","CF":"236","CM":"237","CV":"238","ST":"239","GQ":"240","GA":"241","CG":"242","CD":"243","AO":"244","GW":"245","IO":"246","AC":"247","SC":"248","SD":"249","RW":"250","ET":"251","SO":"252","DJ":"253","KE":"254","TZ":"255","UG":"256","BI":"257","MZ":"258","ZM":"260","MG":"261","RE":"262","YT":"262","ZW":"263","NA":"264","MW":"265","LS":"266","BW":"267","SZ":"268","KM":"269","SH":"290","TA":"290","ER":"291","AW":"297","FO":"298","GL":"299","GI":"350","PT":"351","LU":"352","IE":"353","IS":"354","AL":"355","MT":"356","CY":"357","FI":"358","AX":"358","BG":"359","LT":"370","LV":"371","EE":"372","MD":"373","AM":"374","BY":"375","AD":"376","MC":"377","SM":"378","VA":"379","UA":"380","RS":"381","ME":"382","HR":"385","SI":"386","BA":"387","MK":"389","CZ":"420","SK":"421","LI":"423","FK":"500","BZ":"501","GT":"502","SV":"503","HN":"504","NI":"505","CR":"506","PA":"507","PM":"508","HT":"509","GP":"590","BL":"590","MF":"590","BO":"591","GY":"592","EC":"593","GF":"594","PY":"595","MQ":"596","SR":"597","UY":"598","CW":"599","BQ":"599","TL":"670","NF":"672","BN":"673","NR":"674","PG":"675","TO":"676","SB":"677","VU":"678","FJ":"679","PW":"680","WF":"681","CK":"682","NU":"683","WS":"685","KI":"686","NC":"687","TV":"688","PF":"689","TK":"690","FM":"691","MH":"692","001":"979","KP":"850","HK":"852","MO":"853","KH":"855","LA":"856","BD":"880","TW":"886","MV":"960","LB":"961","JO":"962","SY":"963","IQ":"964","KW":"965","SA":"966","YE":"967","OM":"968","PS":"970","AE":"971","IL":"972","BH":"973","QA":"974","BT":"975","MN":"976","NP":"977","TJ":"992","TM":"993","AZ":"994","GE":"995","KG":"996","UZ":"998","GS":500,"PN":64,"AQ":672,"UM":1,"AN":599})

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(106),
	  __webpack_require__(105),
	  __webpack_require__(151),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormType, FormController, Footer, TextBox) {

	  var _ = Okta._;

	  function isRSA(provider) {
	    return provider === 'RSA';
	  }

	  function getClassName(provider) {
	    return isRSA(provider) ? 'enroll-rsa' : 'enroll-onprem';
	  }

	  return FormController.extend({
	    className: function () {
	      return getClassName(this.options.provider);
	    },
	    Model: function () {
	      var provider = this.options.provider;
	      return {
	        props: {
	          credentialId: ['string', true],
	          passCode: ['string', true],
	          factorId: 'string'
	        },
	        save: function () {
	          return this.doTransaction(function(transaction) {
	            var factor = _.findWhere(transaction.factors, {
	              factorType: 'token',
	              provider: provider
	            });
	            return factor.enroll({
	              passCode: this.get('passCode'),
	              profile: {credentialId: this.get('credentialId')}
	            });
	          });
	        }
	      };
	    },

	    Form: function () {
	      var provider = this.options.provider;
	      var factors = this.options.appState.get('factors');
	      var factor = factors.findWhere(_.pick(this.options, 'provider', 'factorType'));
	      var vendorName = factor.get('vendorName');
	      var title = isRSA(provider) ? Okta.loc('factor.totpHard.rsaSecurId', 'login') : vendorName;

	      return {
	        title: title,
	        noButtonBar: true,
	        autoSave: true,
	        className: getClassName(provider),
	        formChildren: [
	          FormType.Input({
	            name: 'credentialId',
	            input: TextBox,
	            type: 'text',
	            placeholder: Okta.loc('enroll.onprem.username.placeholder', 'login', [vendorName]),
	            params: {
	              innerTooltip: Okta.loc('enroll.onprem.username.tooltip', 'login', [vendorName])
	            }
	          }),
	          FormType.Input({
	            name: 'passCode',
	            input: TextBox,
	            type: 'password',
	            placeholder: Okta.loc('enroll.onprem.passcode.placeholder', 'login', [vendorName]),
	            params: {
	              innerTooltip: Okta.loc('enroll.onprem.passcode.tooltip', 'login', [vendorName])
	            }
	          }),
	          FormType.Toolbar({
	            noCancelButton: true,
	            save: Okta.loc('mfa.challenge.verify', 'login')
	          })
	        ]
	      };
	    },

	    Footer: Footer

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(106),
	  __webpack_require__(105),
	  __webpack_require__(151),
	  __webpack_require__(116)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormType, FormController, Footer, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-symantec',
	    Model: {
	      props: {
	        credentialId: ['string', true],
	        passCode: ['string', true],
	        nextPassCode: ['string', true],
	        factorId: 'string'
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {

	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'token',
	            provider: 'SYMANTEC'
	          });
	          return factor.enroll({
	            passCode: this.get('passCode'),
	            nextPassCode: this.get('nextPassCode'),
	            profile: {credentialId: this.get('credentialId')}
	          });
	        });
	      }
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'factor.totpHard.symantecVip', 'login'),
	      subtitle: _.partial(Okta.loc, 'enroll.symantecVip.subtitle', 'login'),
	      noButtonBar: true,
	      autoSave: true,
	      className: 'enroll-symantec',
	      formChildren: function () {
	        return [
	          FormType.Input({
	            name: 'credentialId',
	            input: TextBox,
	            type: 'text',
	            placeholder: Okta.loc('enroll.symantecVip.credentialId.placeholder', 'login'),
	            params: {
	              innerTooltip: Okta.loc('enroll.symantecVip.credentialId.tooltip', 'login')
	            }
	          }),
	          FormType.Input({
	            name: 'passCode',
	            input: TextBox,
	            type: 'text',
	            placeholder: Okta.loc('enroll.symantecVip.passcode1.placeholder', 'login'),
	            params: {
	              innerTooltip: Okta.loc('enroll.symantecVip.passcode1.tooltip', 'login')
	            }
	          }),
	          FormType.Input({
	            name: 'nextPassCode',
	            input: TextBox,
	            type: 'text',
	            placeholder: Okta.loc('enroll.symantecVip.passcode2.placeholder', 'login'),
	            params: {
	              innerTooltip: Okta.loc('enroll.symantecVip.passcode2.tooltip', 'login')
	            }
	          }),
	          FormType.Toolbar({
	            noCancelButton: true,
	            save: Okta.loc('mfa.challenge.verify', 'login')
	          })
	        ];
	      }
	    },

	    Footer: Footer

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(106),
	  __webpack_require__(105),
	  __webpack_require__(151),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormType, FormController, Footer, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'enroll-yubikey',
	    Model: {
	      props: {
	        passCode: ['string', true],
	        factorId: 'string'
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'token:hardware',
	            provider: 'YUBICO'
	          });
	          return factor.enroll({
	            passCode: this.get('passCode')
	          });
	        });
	      }
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'enroll.yubikey.title', 'login'),
	      subtitle: _.partial(Okta.loc, 'enroll.yubikey.subtitle', 'login'),
	      noCancelButton: true,
	      save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	      autoSave: true,
	      className: 'enroll-yubikey',
	      formChildren: [
	        FormType.View({
	          View: '<div class="yubikey-demo" data-type="yubikey-example"></div>'
	        }),
	        FormType.Input({
	          name: 'passCode',
	          input: TextBox,
	          type: 'password'
	        })
	      ]
	    },

	    Footer: Footer
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109),
	  __webpack_require__(162),
	  __webpack_require__(163),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, FormController, FormType,
	  RouterUtil, StoreLinks, BarcodeView, Footer) {

	  var _ = Okta._;

	  var showWhenDeviceTypeSelected = {
	    '__deviceType__': function (val) {
	      return val !== undefined;
	    }
	  };

	  var AppDownloadInstructionsView = Okta.View.extend({
	    attributes: { 'data-se': 'app-download-instructions' },
	    className: 'app-download-instructions',
	    template: '\
	      <p class="instructions-title">{{title}}</p>\
	      <span class="app-logo {{appIcon}}"></span>\
	      <p class="instructions">{{{appStoreLinkText}}}</p>\
	    ',
	    initialize: function () {
	      this.listenTo(this.model, 'change:__deviceType__', this.render);
	    },
	    getTemplateData: function () {
	      var appStoreLink, appIcon, appStoreName;
	      var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	      appStoreName = StoreLinks.STORE[this.model.get('__deviceType__')];
	      if (this.model.get('__provider__') === 'GOOGLE') {
	        appStoreLink = StoreLinks.GOOGLE[this.model.get('__deviceType__')];
	        appIcon = 'google-auth-38';
	      } else {
	        appStoreLink = StoreLinks.OKTA[this.model.get('__deviceType__')];
	        appIcon = 'okta-verify-38';
	      }
	      return {
	        title: Okta.loc('enroll.totp.installApp', 'login', [factorName]),
	        appStoreLinkText: Okta.loc('enroll.totp.downloadApp',
	          'login', [appStoreLink, factorName, appStoreName]),
	        appIcon: appIcon
	      };
	    }
	  });

	  var EnrollTotpController = FormController.extend({
	    className: 'enroll-totp',
	    Model: function () {
	      return {
	        local: {
	          '__deviceType__': 'string',
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        },
	        save: function () {
	          return this.doTransaction(function(transaction) {
	            var factor = _.findWhere(transaction.factors, {
	              factorType: this.get('__factorType__'),
	              provider: this.get('__provider__')
	            });
	            return factor.enroll();
	          });
	        }
	      };
	    },

	    Form: {
	      title: function () {
	        var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	        return Okta.loc('enroll.totp.title', 'login', [factorName]);
	      },
	      subtitle: _.partial(Okta.loc, 'enroll.totp.selectDevice', 'login'),
	      autoSave: true,
	      noButtonBar: true,
	      attributes: { 'data-se': 'step-device-type' },

	      formChildren: function () {
	        var inputOptions = {
	          APPLE: '',
	          ANDROID: ''
	        };
	        if (this.settings.get('features.windowsVerify') && this.model.get('__provider__') === 'OKTA') {
	          inputOptions.WINDOWS = '';
	        } else if (this.model.get('__provider__') === 'GOOGLE') {
	          inputOptions.BLACKBERRY = '';
	        }

	        var children = [
	          FormType.Input({
	            name: '__deviceType__',
	            type: 'radio',
	            options: inputOptions,
	            className: 'device-type-input'
	          }),

	          FormType.Divider({showWhen: showWhenDeviceTypeSelected}),

	          FormType.View({
	            View: AppDownloadInstructionsView,
	            showWhen: showWhenDeviceTypeSelected
	          }),

	          FormType.Toolbar({
	            noCancelButton: true,
	            save: Okta.loc('oform.next', 'login'),
	            showWhen: showWhenDeviceTypeSelected
	          })
	        ];

	        return children;
	      }
	    },

	    Footer: Footer

	  });

	  return EnrollTotpController;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(module.exports = {
		OKTA: {
			APPLE: 'https://itunes.apple.com/us/app/okta-verify/id490179405',
			ANDROID: 'https://play.google.com/store/apps/details?id=com.okta.android.auth',
			WINDOWS: 'http://www.windowsphone.com/en-us/store/app/okta-verify/9df0e2c4-7301-411f-80e5-62fcf6679666'
		},
		GOOGLE: {
			APPLE: 'https://itunes.apple.com/us/app/google-authenticator/id388497605',
			ANDROID: 'https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2',
			BLACKBERRY: 'https://support.google.com/accounts/answer/1066447'
		},
		STORE: {
			APPLE: 'App Store',
			ANDROID: 'Google Play Store',
			WINDOWS: 'Windows Store',
			BLACKBERRY: 'Blackberry World Store'
		}
	});


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(109)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, RouterUtil) {

	  var _ = Okta._;

	  return Okta.View.extend({
	    className: 'scan-instructions clearfix',
	    template: '\
	      <div class="scan-instructions-details-wrapper">\
	          <div class="scan-instructions-details">\
	              <p>{{instructions}}</p>\
	          </div>\
	      </div>\
	      <div class="scan-instructions-qrcode-wrapper">\
	          <div class="qrcode-wrap">\
	              <img data-se="qrcode" class="qrcode-image" src="{{qrcode}}">\
	              <div data-se="qrcode-success" class="qrcode-success"></div>\
	              <div data-se="qrcode-error" class="qrcode-error"></div>\
	          </div>\
	          <a href="#" data-type="manual-setup" data-se="manual-setup" class="link manual-setup">\
	            {{i18n code="enroll.totp.cannotScan" bundle="login"}}\
	          </a>\
	          <a href="#" data-type="refresh-qrcode" data-se="refresh-qrcode" class="link refresh-qrcode">\
	            {{i18n code="enroll.totp.refreshBarcode" bundle="login"}}\
	          </a>\
	      </div>\
	    ',

	    events: {
	      'click [data-type="manual-setup"]': function (e) {
	        e.preventDefault();
	        var url = RouterUtil.createActivateFactorUrl(this.model.get('__provider__'),
	          this.model.get('__factorType__'), 'manual');
	        this.options.appState.trigger('navigate', url);
	      },
	      'click [data-type="refresh-qrcode"]': function (e) {
	        e.preventDefault();
	        this.model.trigger('errors:clear');

	        var self = this;
	        this.model.doTransaction(function (transaction) {
	          if (this.appState.get('isWaitingForActivation')) {
	            return transaction.poll();
	          } else {
	            return transaction.activate();
	          }
	        })
	        .then(function (trans) {
	          var res = trans.data;
	          if (res.status === 'MFA_ENROLL_ACTIVATE' && res.factorResult === 'WAITING') {
	            // defer the render here to have a lastResponse set in AppState
	            // so that we get new QRcode rendered
	            _.defer(_.bind(self.render, self));
	          }
	        });
	      }
	    },

	    initialize: function () {
	      this.listenTo(this.options.appState, 'change:lastAuthResponse', function () {
	        if (this.options.appState.get('isMfaEnrollActivate')) {
	          this.$el.toggleClass('qrcode-expired', !this.options.appState.get('isWaitingForActivation'));
	        } else if (this.options.appState.get('isSuccessResponse')) {
	          this.$el.addClass('qrcode-success');
	        }
	      });
	      this.listenTo(this.model, 'error', function () {
	        if (this.options.appState.get('isMfaEnrollActivate')) {
	          this.$el.toggleClass('qrcode-expired', true);
	        }
	      });
	    },

	    getTemplateData: function () {
	      var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	      var instructions;
	      if (this.model.get('__provider__') === 'GOOGLE') {
	        instructions = Okta.loc('enroll.totp.setupGoogleAuthApp', 'login', [factorName]);
	      } else {
	        instructions = Okta.loc('enroll.totp.setupApp', 'login', [factorName]);
	      }
	      return {
	        instructions: instructions,
	        qrcode: this.options.appState.get('qrcode')
	      };
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* global u2f */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(106),
	  __webpack_require__(105),
	  __webpack_require__(151),
	  __webpack_require__(9),
	  __webpack_require__(144),
	  __webpack_require__(14),
	  __webpack_require__(146)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormType, FormController, Footer, Q, HtmlErrorMessageView, BrowserFeatures) {

	  var _ = Okta._;

	  function getErrorMessageKeyByCode(errorCode) {
	    switch (errorCode) {
	    default:
	    case 1:
	      return 'u2f.error.other';
	    case 2:
	    case 3:
	      return 'u2f.error.badRequest';
	    case 4:
	      return 'u2f.error.unsupported';
	    case 5:
	      return 'u2f.error.timeout';
	    }
	  }

	  return FormController.extend({
	    className: 'enroll-u2f',
	    Model: {
	      local: {
	        '__enrolled__': 'boolean'
	      },

	      save: function () {
	        this.trigger('request');

	        if (this.get('__enrolled__')) {
	          return this.activate();
	        }

	        return this.doTransaction(function (transaction) {
	          var factor = _.findWhere(transaction.factors, {
	            factorType: 'u2f',
	            provider: 'FIDO'
	          });
	          return factor.enroll();
	        });
	      },

	      activate: function () {
	        this.set('__enrolled__', true);
	        this.trigger('errors:clear');

	        return this.doTransaction(function (transaction) {
	          var activation = transaction.factor.activation;
	          var appId = activation.appId;
	          var registerRequests = [{
	            version: activation.version,
	            challenge: activation.nonce
	          }];
	          var self = this;
	          var deferred = Q.defer();
	          u2f.register(appId, registerRequests, [], function (data) {
	            self.trigger('errors:clear');
	            if (data.errorCode && data.errorCode !== 0) {
	              deferred.reject({
	                xhr: {responseJSON: {errorSummary: Okta.loc(getErrorMessageKeyByCode(data.errorCode), 'login')}}
	              });
	            } else {
	              deferred.resolve(transaction.activate({
	                registrationData: data.registrationData,
	                version: data.version,
	                challenge: data.challenge,
	                clientData: data.clientData
	              }));
	            }
	          });
	          return deferred.promise;
	        });
	      }
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'enroll.u2f.title', 'login'),
	      save: _.partial(Okta.loc, 'enroll.u2f.save', 'login'),
	      noCancelButton: true,
	      hasSavingState: false,
	      autoSave: true,
	      className: 'enroll-u2f-form',
	      noButtonBar: function () {
	        return !window.hasOwnProperty('u2f');
	      },
	      modelEvents: {
	        'request': '_startEnrollment',
	        'error': '_stopEnrollment'
	      },
	      formChildren: function () {
	        var result = [];

	        if (!window.hasOwnProperty('u2f')) {
	          var errorMessageKey = 'u2f.error.notSupportedBrowser';

	          if (BrowserFeatures.isFirefox()) {
	            errorMessageKey = 'u2f.error.noFirefoxExtension';
	          }

	          result.push(FormType.View(
	            {View: new HtmlErrorMessageView({message: Okta.loc(errorMessageKey, 'login')})},
	            {selector: '.o-form-error-container'}
	          ));
	        }
	        else {
	          //There is html in enroll.u2f.general2 in our properties file, reason why is unescaped
	          result.push(FormType.View({
	            View: '<div class="u2f-instructions"><ol>\
	          <li>{{i18n code="enroll.u2f.general1" bundle="login"}}</li>\
	          <li>{{{i18n code="enroll.u2f.general2" bundle="login"}}}</li>\
	          <li>{{i18n code="enroll.u2f.general3" bundle="login"}}</li>\
	          </ol></div>'
	          }));

	          result.push(FormType.View({
	            View: '\
	          <div class="u2f-enroll-text hide">\
	            <p>{{i18n code="enroll.u2f.instructions" bundle="login"}}</p>\
	            <p>{{i18n code="enroll.u2f.instructionsBluetooth" bundle="login"}}</p>\
	            <div data-se="u2f-devices" class="u2f-devices-images">\
	              <div class="u2f-usb"></div>\
	              <div class="u2f-bluetooth"></div>\
	            </div>\
	            <div data-se="u2f-waiting" class="okta-waiting-spinner"></div>\
	          </div>'
	          }));
	        }

	        return result;
	      },

	      _startEnrollment: function () {
	        this.$('.u2f-instructions').addClass('hide');
	        this.$('.u2f-enroll-text').removeClass('hide');
	        this.$('.o-form-button-bar').hide();
	      },

	      _stopEnrollment: function () {
	        this.$('.u2f-instructions').removeClass('hide');
	        this.$('.u2f-enroll-text').addClass('hide');
	        this.$('.o-form-button-bar').show();
	      }
	    },

	    Footer: Footer,

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate')) {
	        this.model.activate();
	        return true;
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109),
	  __webpack_require__(163),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, FormController, FormType, RouterUtil, BarcodeView, Footer) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'barcode-totp',
	    Model: function () {
	      return {
	        local: {
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        }
	      };
	    },

	    Form: {
	      title: function () {
	        var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	        return Okta.loc('enroll.totp.title', 'login', [factorName]);
	      },
	      subtitle: _.partial(Okta.loc, 'mfa.scanBarcode', 'login'),
	      save: _.partial(Okta.loc, 'oform.next', 'login'),
	      noCancelButton: true,
	      attributes: { 'data-se': 'step-scan' },
	      className: 'barcode-scan',

	      formChildren: [
	        FormType.View({View: BarcodeView})
	      ]
	    },

	    Footer: Footer,

	    initialize: function () {
	      this.listenTo(this.form, 'save', function () {
	        var url = RouterUtil.createActivateFactorUrl(this.model.get('__provider__'),
	          this.model.get('__factorType__'), 'activate');
	        this.options.appState.trigger('navigate', url);
	      });
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109),
	  __webpack_require__(163),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, FormController, FormType, RouterUtil, BarcodeView, Footer) {

	  var _ = Okta._;

	  // Note: Keep-alive is set to 5 seconds - using 5 seconds here will result
	  // in network connection lost errors in Safari and IE.
	  var PUSH_INTERVAL = 6000;

	  return FormController.extend({
	    className: 'barcode-push',
	    Model: function () {
	      return {
	        local: {
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        }
	      };
	    },

	    Form: {
	      title: function () {
	        var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	        return Okta.loc('enroll.totp.title', 'login', [factorName]);
	      },
	      subtitle: _.partial(Okta.loc, 'mfa.scanBarcode', 'login'),
	      noButtonBar: true,
	      attributes: { 'data-se': 'step-scan' },
	      className: 'barcode-scan',
	      initialize: function () {
	        this.listenTo(this.model, 'error errors:clear', function () {
	          this.clearErrors();
	        });
	      },

	      formChildren: [
	        FormType.View({View: BarcodeView})
	      ]
	    },

	    Footer: Footer,

	    initialize: function () {
	      this.pollForEnrollment();
	    },

	    pollForEnrollment: function () {
	      return this.model.doTransaction(function(transaction) {
	        return transaction.poll(PUSH_INTERVAL);
	      });
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate')) {
	        return true;
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(168),
	  __webpack_require__(151)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, EnterPasscodeForm, Footer) {

	  return FormController.extend({
	    className: 'activate-totp',
	    Model: function () {
	      return {
	        props: {
	          factorId: ['string', true, this.options.appState.get('activatedFactorId')],
	          passCode: ['string', true]
	        },
	        local: {
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        },
	        save: function () {
	          return this.doTransaction(function(transaction) {
	            return transaction.activate({
	              passCode: this.get('passCode')
	            });
	          });
	        }
	      };
	    },

	    Form: EnterPasscodeForm,

	    Footer: Footer

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(104),
	  __webpack_require__(106),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorUtil, FormType, TextBox) {

	  var _ = Okta._;

	  var form = {
	    title: function () {
	      var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	      return Okta.loc('enroll.totp.title', 'login', [factorName]);
	    },
	    subtitle: _.partial(Okta.loc, 'enroll.totp.enterCode', 'login'),
	    autoSave: true,
	    noButtonBar: true,
	    attributes: { 'data-se': 'step-sendcode' },

	    formChildren: function () {
	      return [
	        FormType.Input({
	          name: 'passCode',
	          input: TextBox,
	          type: 'number',
	          placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	          params: {
	            innerTooltip: Okta.loc('mfa.challenge.enterCode.tooltip', 'login')
	          }
	        }),

	        FormType.Toolbar({
	          noCancelButton: true,
	          save: Okta.loc('oform.verify', 'login')
	        })
	      ];
	    }
	  };

	  return form;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(170),
	  __webpack_require__(172),
	  __webpack_require__(173),
	  __webpack_require__(110),
	  __webpack_require__(107)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, PrimaryAuthForm, SocialAuth, PrimaryAuthModel, Util, BaseLoginController) {

	  var compile = Okta.Handlebars.compile;
	  var _ = Okta._;
	  var $ = Okta.$;

	  var Footer = Okta.View.extend({
	    template: '\
	      <p><a href="#" class="link help js-qr-login">QR Login</a></p>\
	      <a href="#" data-se="needhelp" class="link help js-help">\
	      {{i18n code="needhelp" bundle="login"}}\
	      </a>\
	      <ul class="help-links js-help-links">\
	        <li>\
	        <a href="#" data-se="forgot-password" class="link js-forgot-password">\
	        {{i18n code="forgotpassword" bundle="login"}}\
	        </a>\
	        </li>\
	        {{#if features.selfServiceUnlock}}\
	          <li>\
	          <a href="#" data-se="unlock" class="link js-unlock">\
	          {{i18n code="unlockaccount" bundle="login"}}\
	          </a>\
	          </li>\
	        {{/if}}\
	        {{#each helpLinks.custom}}\
	          <li>\
	          <a href="{{href}}" class="link js-custom">{{text}}</a></li>\
	        {{/each}}\
	        <li>\
	        <a href="{{helpLinkUrl}}" data-se="help-link" class="link js-help-link" target="_blank">\
	        {{i18n code="help" bundle="login"}}\
	        </a>\
	        </li>\
	      </ul>\
	    ',
	    className: 'auth-footer',

	    initialize: function () {
	      this.listenTo(this.state, 'change:enabled', function(model, enable) {
	        this.$(':link').toggleClass('o-form-disabled', !enable);
	      });
	    },

	    getTemplateData: function () {
	      var helpLinkUrl;
	      var customHelpPage = this.settings.get('helpLinks.help');
	      if (customHelpPage) {
	        helpLinkUrl = customHelpPage;
	      } else {
	        helpLinkUrl = compile('{{baseUrl}}/help/login')({baseUrl: this.settings.get('baseUrl')});
	      }
	      return _.extend(this.settings.toJSON({verbose: true}), {helpLinkUrl: helpLinkUrl});
	    },
	    postRender: function () {
	      this.$('.js-help-links').hide();
	    },
	    toggleLinks: function (e) {
	      e.preventDefault();
	      this.$('.js-help-links').slideToggle(200);
	    },
	    events: {
	      'click .js-help': function (e) {
	        e.preventDefault();
	        if(!this.state.get('enabled')) {
	          return;
	        }

	        this.toggleLinks(e);
	      },
	      'click .js-qr-login': function (e) {
	        e.preventDefault();
	        this.options.appState.trigger('navigate', 'signin/qr-login');
	      },
	      'click .js-forgot-password' : function (e) {
	        e.preventDefault();
	        if(!this.state.get('enabled')) {
	          return;
	        }

	        var customResetPasswordPage = this.settings.get('helpLinks.forgotPassword');
	        if (customResetPasswordPage) {
	          Util.redirect(customResetPasswordPage);
	        }
	        else {
	          this.options.appState.trigger('navigate', 'signin/forgot-password');
	        }
	      },
	      'click .js-unlock' : function (e) {
	        e.preventDefault();
	        if(!this.state.get('enabled')) {
	          return;
	        }

	        var customUnlockPage = this.settings.get('helpLinks.unlock');
	        if (customUnlockPage) {
	          Util.redirect(customUnlockPage);
	        }
	        else {
	          this.options.appState.trigger('navigate', 'signin/unlock');
	        }
	      }
	    }
	  });

	  return BaseLoginController.extend({
	    className: 'primary-auth',

	    state: { enabled: true },

	    View: PrimaryAuthForm,

	    constructor: function (options) {
	      var username;
	      options.appState.unset('username');

	      this.model = new PrimaryAuthModel({
	        multiOptionalFactorEnroll: options.settings.get('features.multiOptionalFactorEnroll'),
	        settings: options.settings,
	        appState: options.appState
	      }, { parse: true });

	      BaseLoginController.apply(this, arguments);

	      this.addListeners();

	      // Add SocialAuth view only when the idps are configured. If configured, 'socialAuthPositionTop'
	      // will determine the order in which the social auth and primary auth are shown on the screen.
	      if (options.settings.get('socialAuthConfigured')) {
	        this.add(SocialAuth, {prepend: options.settings.get('socialAuthPositionTop')});
	      }
	      this.add(new Footer(this.toJSON({appState: options.appState})));

	      username = this.model.get('username');
	      if (username) {
	        this.options.appState.set('username', username);
	      }
	    },

	    events: {
	      'focusout input[name=username]': function () {
	        this.options.appState.set('username', this.model.get('username'));
	      },
	      'focusin input': function (e) {
	        $(e.target.parentElement).addClass('focused-input');
	      },
	      'focusout input': function (e) {
	        $(e.target.parentElement).removeClass('focused-input');
	      }
	    },

	    // This model and the AppState both have a username property.
	    // The controller updates the AppState's username when the user is
	    // done editing (on blur) or deletes the username (see below).
	    initialize: function () {
	      this.listenTo(this.model, 'change:username', function (model, value) {
	        if (!value) {
	          // reset AppState to an undefined user.
	          this.options.appState.set('username', '');
	        }
	      });
	      this.listenTo(this.model, 'save', function () {
	        this.state.set('enabled', false);
	      });
	      this.listenTo(this.model, 'error', function () {
	        this.state.set('enabled', true);
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(116),
	  __webpack_require__(171)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, TextBox, DeviceFingerprint) {

	  var _ = Okta._;

	  return Okta.Form.extend({
	    className: 'primary-auth-form',
	    noCancelButton: true,
	    save: _.partial(Okta.loc, 'primaryauth.submit', 'login'),
	    layout: 'o-form-theme',

	    // If socialAuth is configured, the title moves from the form to
	    // the top of the container (and is rendered in socialAuth).
	    title: function () {
	      var formTitle = Okta.loc('primaryauth.title', 'login');
	      if (this.settings.get('socialAuthConfigured') &&
	          this.settings.get('socialAuthPositionTop')) {
	        formTitle = '';
	      }
	      return formTitle;
	    },

	    initialize: function () {
	      this.listenTo(this, 'save', function () {
	        var self = this;
	        var creds = {
	          username: this.model.get('username'),
	          password: this.model.get('password')
	        };
	        this.settings.processCreds(creds)
	        .then(function() {
	          if (!self.settings.get('features.deviceFingerprinting')) {
	            return;
	          }
	          return DeviceFingerprint.generateDeviceFingerprint(self.settings.get('baseUrl'), self.$el)
	          .then(function (fingerprint) {
	            self.model.set('deviceFingerprint', fingerprint);
	          })
	          .fail(function () {
	            // Keep going even if device fingerprint fails
	          });
	        })
	        .then(_.bind(this.model.save, this.model));
	      });
	      this.listenTo(this.state, 'change:enabled', function (model, enable) {
	        if (enable) {
	          this.enable();
	        }
	        else {
	          this.disable();
	        }
	      });
	    },

	    inputs: function () {
	      var inputs = [
	        {
	          label: false,
	          'label-top': true,
	          placeholder: Okta.loc('primaryauth.username.placeholder', 'login'),
	          name: 'username',
	          input: TextBox,
	          type: 'text',
	          params: {
	            innerTooltip: {
	              title: Okta.loc('primaryauth.username.placeholder', 'login'),
	              text: Okta.loc('primaryauth.username.tooltip', 'login')
	            },
	            icon: 'person-16-gray'
	          }
	        },
	        {
	          label: false,
	          'label-top': true,
	          placeholder: Okta.loc('primaryauth.password.placeholder', 'login'),
	          name: 'password',
	          input: TextBox,
	          type: 'password',
	          params: {
	            innerTooltip: {
	              title: Okta.loc('primaryauth.password.placeholder', 'login'),
	              text: Okta.loc('primaryauth.password.tooltip', 'login')
	            },
	            icon: 'remote-lock-16'
	          }
	        }
	      ];
	      if (this.settings.get('features.rememberMe')) {
	        inputs.push({
	          label: false,
	          placeholder: Okta.loc('remember', 'login'),
	          name: 'remember',
	          type: 'checkbox',
	          'label-top': true,
	          className: 'margin-btm-0',
	          initialize: function () {
	            this.listenTo(this.model, 'change:remember', function (model, val) {
	              // OKTA-98946: We normally re-render on changes to model values,
	              // but in this case we will manually update the checkbox due to
	              // iOS Safari and how it handles autofill - it will autofill the
	              // form anytime the dom elements are re-rendered, which prevents
	              // the user from editing their username.
	              this.$(':checkbox').prop('checked', val).trigger('updateState');
	            });
	          }
	        });
	      }

	      return inputs;
	    },

	    focus: function () {
	      if (!this.model.get('username')) {
	        this.getInputs().first().focus();
	      } else {
	        this.getInputs().toArray()[1].focus();
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/*jshint latedef:false */
	/*global JSON */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Q, $) {

	  return {
	    generateDeviceFingerprint: function (oktaDomainUrl, element) {
	      var deferred = Q.defer();

	      // Create iframe
	      var $iframe = $('<iframe>', {
	        style: 'display: none;'
	      });
	      $iframe.appendTo(element);

	      function removeIframe() {
	        $iframe.off();
	        $iframe.remove();
	        window.removeEventListener('message', onMessageReceivedFromOkta, false);
	      }

	      function handleError(reason) {
	        removeIframe();
	        deferred.reject(reason);
	      }

	      function onMessageReceivedFromOkta(event) {
	        /*jshint maxcomplexity:7*/
	        if (!event || !event.data || event.origin != oktaDomainUrl) {
	          handleError('no data');
	          return;
	        }
	        try {
	          var message = JSON.parse(event.data);
	          if (message && message.type === 'FingerprintServiceReady') {
	            sendMessageToOkta({type: 'GetFingerprint'});
	          } else if (message && message.type === 'FingerprintAvailable') {
	            removeIframe();
	            deferred.resolve(message.fingerprint);
	          } else {
	            handleError('no data');
	          }
	        } catch (error) {
	          //Ignore any errors since we could get other messages too
	        }
	      }

	      function sendMessageToOkta(message) {
	        var win = $iframe[0].contentWindow;
	        if (win) {
	          win.postMessage(JSON.stringify(message), oktaDomainUrl);
	        }
	      }

	      // Attach listener
	      window.addEventListener('message', onMessageReceivedFromOkta, false);
	      // Load devicefingerprint page inside the iframe
	      $iframe.attr('src', oktaDomainUrl + '/auth/services/devicefingerprint');

	      return deferred.promise;
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(111)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, OAuth2Util) {

	  var _ = Okta._;

	  var dividerTpl = Okta.tpl(
	    '<div class="auth-divider">\
	      <span class="auth-divider-text">{{text}}</span>\
	    </div>');
	  var formTitleTpl = Okta.tpl(
	    '<h2 data-se="o-form-head" class="okta-form-title o-form-head">{{title}}</h2>'
	  );

	  return Okta.View.extend({

	    className: 'social-auth',

	    children: function () {
	      var children = [],
	          idProviders = this.settings.get('configuredSocialIdps'),
	          divider = dividerTpl({text: Okta.loc('socialauth.divider.text', 'login')});

	      // Social Auth IDPs.
	      _.each(idProviders, function (provider) {
	        children.push(this._createButton(provider));
	      }, this);

	      // If the social auth buttons have to be above the Okta form, the title moves from
	      // primary auth form to the social auth (above the buttons) and the divider goes below
	      // the buttons (in between social auth and primary auth). If social auth needs to go below
	      // Okta form, just add the divider at the top of the social auth container. The title still
	      // lives in primary auth form.
	      if (this.settings.get('socialAuthPositionTop')) {
	        children.unshift(formTitleTpl({title: Okta.loc('primaryauth.title', 'login')}));
	        // Divider between Primary Auth and the Social Auth
	        children.push(divider);
	      } else {
	        children.unshift(divider);
	      }

	      return children;
	    },

	    _createButton: function (options) {
	      var type = options.type.toLowerCase(),
	          attr = 'social-auth-' + type + '-button';

	      return Okta.createButton({
	        attributes: {
	          'data-se': attr
	        },
	        className: 'social-auth-button ' + attr,
	        title: Okta.loc('socialauth.' + type + '.label'),
	        events: {
	          'click': function (e) {
	            e.preventDefault();
	            OAuth2Util.getTokens(this.settings, {idp: options.id});
	          }
	        }
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(108),
	  __webpack_require__(133),
	  __webpack_require__(112)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, BaseLoginModel, CookieUtil, Enums) {

	  var _ = Okta._;

	  return BaseLoginModel.extend({

	    props: function () {
	      var settingsUsername = this.settings && this.settings.get('username'),
	          cookieUsername = CookieUtil.getCookieUsername(),
	          remember = false,
	          username;
	      if (settingsUsername) {
	        username = settingsUsername;
	        remember = username === cookieUsername;
	      }
	      else if (cookieUsername) {
	        username = cookieUsername;
	        remember = true;
	      }

	      return {
	        username: ['string', true, username],
	        lastUsername: ['string', false, cookieUsername],
	        password: ['string', true],
	        context: ['object', false],
	        remember: ['boolean', true, remember],
	        multiOptionalFactorEnroll: ['boolean', true]
	      };
	    },

	    local: {
	      deviceFingerprint: ['string', false]
	    },

	    constructor: function (options) {
	      this.settings = options && options.settings;
	      this.appState = options && options.appState;
	      Okta.Model.apply(this, arguments);
	      this.listenTo(this, 'change:username', function (model, username) {
	        this.set({remember: username === this.get('lastUsername')});
	      });
	    },
	    parse: function (options) {
	      return _.omit(options, ['settings', 'appState']);
	    },

	    save: function () {
	      var username = this.settings.transformUsername(this.get('username'), Enums.PRIMARY_AUTH),
	          password = this.get('password'),
	          remember = this.get('remember'),
	          lastUsername = this.get('lastUsername'),
	          multiOptionalFactorEnroll = this.get('multiOptionalFactorEnroll'),
	          deviceFingerprintEnabled = this.settings.get('features.deviceFingerprinting');

	      // Only delete the cookie if its owner says so. This allows other
	      // users to log in on a one-off basis.
	      if (!remember && lastUsername === username) {
	        CookieUtil.removeUsernameCookie();
	      }
	      else if (remember) {
	        CookieUtil.setUsernameCookie(username);
	      }

	      //the 'save' event here is triggered and used in the BaseLoginController
	      //to disable the primary button on the primary auth form
	      this.trigger('save');

	      this.appState.trigger('loading', true);
	      return this.startTransaction(function (authClient) {

	        // Add the custom header for fingerprint if needed, and then remove it afterwards
	        // Since we only need to send it for primary auth
	        if (deviceFingerprintEnabled) {
	          authClient.options.headers['X-Device-Fingerprint'] = this.get('deviceFingerprint');
	        }
	        return authClient.signIn({
	          username: username,
	          password: password,
	          options: {
	            warnBeforePasswordExpired: true,
	            multiOptionalFactorEnroll: multiOptionalFactorEnroll
	          }
	        })
	        .fin(function () {
	          if (deviceFingerprintEnabled) {
	            delete authClient.options.headers['X-Device-Fingerprint'];
	          }
	        });
	      })
	      .fail(_.bind(function () {
	        this.trigger('error');
	        // Specific event handled by the Header for the case where the security image is not
	        // enabled and we want to show a spinner. (Triggered only here and handled only by Header).
	        this.appState.trigger('removeLoading');
	        CookieUtil.removeUsernameCookie();
	      }, this))
	      .fin(_.bind(function () {
	        this.appState.trigger('loading', false);
	      }, this));
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(156),
	  __webpack_require__(104),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109),
	  __webpack_require__(175),
	  __webpack_require__(155),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, CountryUtil, FactorUtil, FormController, FormType, RouterUtil,
	          Footer, PhoneTextBox, TextBox) {

	  var _ = Okta._;

	  function goToFactorActivation(view, step) {
	    var url = RouterUtil.createActivateFactorUrl(view.options.appState.get('activatedFactorProvider'),
	      view.options.appState.get('activatedFactorType'), step);
	    view.options.appState.trigger('navigate', url);
	  }

	  function setStateValues(view) {
	    var userPhoneNumber, userCountryCode;
	    if (view.model.get('activationType') === 'SMS') {
	      userCountryCode = view.model.get('countryCode');
	      userPhoneNumber = view.model.get('phoneNumber');
	    }
	    view.options.appState.set({
	      factorActivationType: view.model.get('activationType'),
	      userCountryCode: userCountryCode,
	      userPhoneNumber: userPhoneNumber
	    });
	  }

	  function enrollFactor(view, factorType) {
	    return view.model.doTransaction(function(transaction) {
	      return transaction.prev()
	      .then(function (trans) {
	        var factor = _.findWhere(trans.factors, {
	          factorType: factorType,
	          provider: 'OKTA'
	        });
	        return factor.enroll();
	      })
	      .then(function (trans) {
	        var textActivationLinkUrl,
	            emailActivationLinkUrl,
	            sharedSecret,
	            res = trans.data;

	        if (res &&
	            res._embedded &&
	            res._embedded.factor &&
	            res._embedded.factor._embedded &&
	            res._embedded.factor._embedded.activation) {

	          var factor = res._embedded.factor;

	          // Shared secret
	          sharedSecret = factor._embedded.activation.sharedSecret;

	          if (factor._embedded.activation._links &&
	              factor._embedded.activation._links.send) {

	            var activationSendLinks = factor._embedded.activation._links.send;

	            // SMS activation url
	            var smsItem = _.findWhere(activationSendLinks, {name: 'sms'});
	            textActivationLinkUrl = smsItem ? smsItem.href : null;

	            // Email activation url
	            var emailItem = _.findWhere(activationSendLinks, {name: 'email'});
	            emailActivationLinkUrl = emailItem ? emailItem.href : null;
	          }
	        }

	        view.model.set({
	          'SMS': textActivationLinkUrl,
	          'EMAIL': emailActivationLinkUrl,
	          'sharedSecret': sharedSecret
	        });

	        return trans;
	      });
	    });
	  }

	  return FormController.extend({
	    className: 'enroll-manual-push',
	    Model: function () {
	      return {
	        local: {
	          activationType: ['string', true, this.options.appState.get('factorActivationType') || 'SMS'],
	          countryCode: ['string', false, 'US'],
	          phoneNumber: 'string',
	          'SMS': ['string', false, this.options.appState.get('textActivationLinkUrl')],
	          'EMAIL': ['string', false, this.options.appState.get('emailActivationLinkUrl')],
	          'sharedSecret': ['string', false, this.options.appState.get('sharedSecret')],
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        },
	        derived: {
	          countryCallingCode: {
	            deps: ['countryCode'],
	            fn: function (countryCode) {
	              return '+' + CountryUtil.getCallingCodeForCountry(countryCode);
	            }
	          },
	          fullPhoneNumber: {
	            deps: ['countryCallingCode', 'phoneNumber'],
	            fn: function (countryCallingCode, phoneNumber) {
	              return countryCallingCode + phoneNumber;
	            }
	          }
	        }
	      };
	    },

	    Form: {
	      title: function () {
	        var factorName = FactorUtil.getFactorLabel(this.model.get('__provider__'), this.model.get('__factorType__'));
	        return Okta.loc('enroll.totp.title', 'login', [factorName]);
	      },
	      subtitle: _.partial(Okta.loc, 'enroll.totp.cannotScanBarcode', 'login'),
	      noButtonBar: true,
	      attributes: { 'data-se': 'step-manual-setup' },

	      formChildren: function () {
	        var children = [
	          FormType.Input({
	            name: 'activationType',
	            type: 'select',
	            wide: true,
	            options: {
	              SMS: Okta.loc('enroll.totp.sendSms', 'login'),
	              EMAIL: Okta.loc('enroll.totp.sendEmail', 'login'),
	              MANUAL: Okta.loc('enroll.totp.setupManually', 'login')
	            }
	          }),

	          FormType.Input({
	            name: 'countryCode',
	            type: 'select',
	            wide: true,
	            options: CountryUtil.getCountries(),
	            showWhen: {activationType: 'SMS'}
	          }),

	          FormType.Input({
	            placeholder: Okta.loc('mfa.phoneNumber.placeholder', 'login'),
	            className: 'enroll-sms-phone',
	            name: 'phoneNumber',
	            input: PhoneTextBox,
	            type: 'text',
	            showWhen: {activationType: 'SMS'}
	          }),

	          FormType.View({
	            View: '\
	              <p class="okta-form-subtitle o-form-explain text-align-c">\
	                {{i18n code="enroll.totp.sharedSecretInstructions" bundle="login"}}\
	              </p>\
	            ',
	            showWhen: {activationType: 'MANUAL'}
	          }),

	          FormType.Input({
	            name: 'sharedSecret',
	            input: TextBox,
	            type: 'text',
	            disabled: true,
	            showWhen: {activationType: 'MANUAL'},
	            initialize: function () {
	              this.listenTo(this.model, 'change:sharedSecret', this.render);
	            }
	          }),

	          FormType.View({
	            View: '<div data-type="next-button-wrap"></div>',
	            showWhen: {activationType: 'MANUAL'}
	          }),

	          FormType.Button({
	            title: Okta.loc('oform.next', 'login'),
	            className: 'button button-primary button-wide button-next',
	            attributes: {'data-se': 'next-button'},
	            click: _.bind(function () {
	              setStateValues(this);
	              goToFactorActivation(this, 'passcode');
	            }, this)
	          }, '[data-type="next-button-wrap"]'),

	          FormType.Toolbar({
	            noCancelButton: true,
	            save: Okta.loc('oform.send', 'login'),
	            showWhen: {
	              activationType: function (val) {
	                return val === 'SMS' || val === 'EMAIL';
	              }
	            }
	          })
	        ];
	        return children;
	      }
	    },

	    Footer: Footer,

	    initialize: function () {
	      this.setInitialModel();
	      // Move this logic to a model when AuthClient supports sending email and sms
	      this.listenTo(this.form, 'save', function () {
	        var self = this;
	        this.model.doTransaction(function(transaction) {
	          var activationType = this.get('activationType').toLowerCase(),
	              opts = {};

	          if (activationType === 'sms') {
	            opts.profile = {phoneNumber: this.get('fullPhoneNumber')};
	          }

	          return transaction.factor.activation.send(activationType, opts)
	          .then(function(trans) {
	            setStateValues(self);
	            // Note: Need to defer because OktaAuth calls our router success
	            // handler on the next tick - if we immediately called, appState would
	            // still be populated with the last response
	            _.defer(function () {
	              goToFactorActivation(self, 'sent');
	            });
	            return trans;
	          });
	        });
	      });

	      this.listenTo(this.model, 'change:activationType', function (model, value) {
	        this.form.clearErrors();
	        if (value === 'MANUAL' && this.options.appState.get('activatedFactorType') !== 'token:software:totp') {
	          enrollFactor(this, 'token:software:totp');
	        } else if (this.options.appState.get('activatedFactorType') !== 'push') {
	          enrollFactor(this, 'push');
	        }
	      });
	    },

	    setInitialModel: function () {
	      if (this.options.appState.get('factorActivationType') === 'SMS') {
	        this.model.set({
	          countryCode: this.options.appState.get('userCountryCode') || 'US',
	          phoneNumber: this.options.appState.get('userPhoneNumber')
	        });
	      }
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isMfaEnrollActivate') ||
	        this.options.appState.get('isMfaEnroll')) {
	        return true;
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(109)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, RouterUtil) {

	  var _ = Okta._;

	  function goToFactorActivation(appState) {
	    var url = RouterUtil.createActivateFactorUrl(appState.get('activatedFactorProvider'),
	      appState.get('activatedFactorType'));
	    appState.trigger('navigate', url);
	  }

	  return Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="mfa.backToFactors" bundle="login"}}\
	      </a>\
	      <a href="#" class="link help goto js-goto" data-se="goto-link">\
	        {{i18n code="mfa.scanBarcode" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      },
	      'click .js-goto' : function (e) {
	        e.preventDefault();
	        var goToFactor = _.partial(goToFactorActivation, this.options.appState);
	        this.options.appState.unset('factorActivationType');
	        if (this.options.appState.get('activatedFactorType') !== 'push') {
	          this.model.doTransaction(function (transaction) {
	            return transaction.prev()
	            .then(function (trans) {
	              var factor = _.findWhere(trans.factors, {
	                factorType: 'push',
	                provider: 'OKTA'
	              });
	              return factor.enroll();
	            });
	          })
	          .then(goToFactor);
	        } else {
	          this.model.startTransaction(function (authClient) {
	            return authClient.tx.resume();
	          })
	          .then(function() {
	            // Sets to trigger on a tick after the appState has been set.
	            // This is due to calling the globalSuccessFn in a callback
	            setTimeout(goToFactor);
	          });
	        }
	      }
	    },
	    back: function () {
	      var self = this;
	      self.options.appState.unset('factorActivationType');
	      if (self.options.appState.get('prevLink')) {
	        this.model.doTransaction(function(transaction) {
	          return transaction.prev();
	        })
	        .then(function() {
	          // we trap 'MFA_ENROLL' response that's why we need to trigger navigation from here
	          self.options.appState.trigger('navigate', 'signin/enroll');
	        });
	      }
	      else {
	        self.options.appState.trigger('navigate', 'signin/enroll');
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(156),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(109)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, CountryUtil, FormController, FormType, RouterUtil) {

	  var _ = Okta._;

	  // Note: Keep-alive is set to 5 seconds - using 5 seconds here will result
	  // in network connection lost errors in Safari and IE.
	  var PUSH_INTERVAL = 6000;

	  var Footer = Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="oform.back" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      }
	    },
	    back: function() {
	      var url = RouterUtil.createActivateFactorUrl(this.options.appState.get('activatedFactorProvider'),
	          this.options.appState.get('activatedFactorType'), 'manual');
	      this.options.appState.trigger('navigate', url);
	    }
	  });

	  var emailSentForm = {
	    title: _.partial(Okta.loc, 'enroll.totp.enrollViaEmail.title', 'login'),
	    noButtonBar: true,
	    attributes: { 'data-se': 'sent-email-activation-link' },
	    formChildren: [
	      FormType.View({
	        View: Okta.View.extend({
	          template: '\
	            <p>{{i18n code="enroll.totp.enrollViaEmail.msg" bundle="login"}}</p>\
	            <p class="email-address">{{email}}</p>\
	          ',
	          getTemplateData: function () {
	            return {email: this.options.appState.get('userEmail')};
	          }
	        })
	      })
	    ]
	  };

	  var smsSentForm = {
	    title: _.partial(Okta.loc, 'enroll.totp.enrollViaSms.title', 'login'),
	    noButtonBar: true,
	    attributes: { 'data-se': 'sent-sms-activation-link' },
	    formChildren: [
	      FormType.View({
	        View: Okta.View.extend({
	          template: '\
	            <p>{{i18n code="enroll.totp.enrollViaSms.msg" bundle="login"}}</p>\
	            <p class="phone-number">{{phoneNumber}}</p>\
	          ',
	          getTemplateData: function () {
	            return {phoneNumber: this.model.get('fullPhoneNumber')};
	          }
	        })
	      })
	    ]
	  };

	  return FormController.extend({
	    className: 'enroll-activation-link-sent',
	    Model: function () {
	      return {
	        local: {
	          countryCode: ['string', false, this.options.appState.get('userCountryCode')],
	          phoneNumber: ['string', false, this.options.appState.get('userPhoneNumber')],
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        },
	        derived: {
	          countryCallingCode: {
	            deps: ['countryCode'],
	            fn: function (countryCode) {
	              return '+' + CountryUtil.getCallingCodeForCountry(countryCode);
	            }
	          },
	          fullPhoneNumber: {
	            deps: ['countryCallingCode', 'phoneNumber'],
	            fn: function (countryCallingCode, phoneNumber) {
	              return countryCallingCode + phoneNumber;
	            }
	          }
	        }
	      };
	    },

	    Form: function () {
	      var activationType = this.options.appState.get('factorActivationType');
	      switch (activationType) {
	      case 'SMS':
	        return smsSentForm;
	      case 'EMAIL':
	        return emailSentForm;
	      default:
	        throw new Error('Unknown activation option: ' + activationType);
	      }
	    },

	    Footer: Footer,

	    initialize: function () {
	      this.pollForEnrollment();
	    },

	    remove: function () {
	      return FormController.prototype.remove.apply(this, arguments);
	    },

	    pollForEnrollment: function () {
	      return this.model.doTransaction(function(transaction) {
	        return transaction.poll(PUSH_INTERVAL);
	      });
	    },

	    trapAuthResponse: function () {
	      if (this.options.appState.get('isWaitingForActivation')) {
	        this.pollForEnrollment();
	        return true;
	      }
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(109),
	  __webpack_require__(168)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, RouterUtil, EnterPasscodeForm) {

	  var Footer = Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="oform.back" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      }
	    },
	    back: function () {
	      var url = RouterUtil.createActivateFactorUrl(this.options.appState.get('activatedFactorProvider'),
	          'push', 'manual');
	      this.options.appState.trigger('navigate', url);
	    }
	  });

	  return FormController.extend({
	    className: 'activate-push',
	    Model: function () {
	      return {
	        props: {
	          factorId: ['string', true, this.options.appState.get('activatedFactorId')],
	          passCode: ['string', true]
	        },
	        local: {
	          '__factorType__': ['string', false, this.options.factorType],
	          '__provider__': ['string', false, this.options.provider]
	        },
	        save: function () {
	          return this.doTransaction(function(transaction) {
	            return transaction.activate({
	              passCode: this.get('passCode')
	            });
	          });
	        }
	      };
	    },

	    Form: EnterPasscodeForm,

	    Footer: Footer

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(112),
	  __webpack_require__(106),
	  __webpack_require__(179),
	  __webpack_require__(104),
	  __webpack_require__(180),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, Enums, FormType, ValidationUtil, FactorUtil, Footer, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'password-expired',
	    Model: {
	      props: {
	        oldPassword: ['string', true],
	        newPassword: ['string', true],
	        confirmPassword: ['string', true]
	      },
	      validate: function () {
	        return ValidationUtil.validatePasswordMatch(this);
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          return transaction.changePassword({
	            oldPassword: this.get('oldPassword'),
	            newPassword: this.get('newPassword')
	          });
	        });
	      }
	    },
	    Form: {
	      save: _.partial(Okta.loc, 'password.expired.submit', 'login'),
	      title: function () {
	        var expiringSoon = this.options.appState.get('isPwdExpiringSoon'),
	            numDays = this.options.appState.get('passwordExpireDays');
	        if (expiringSoon && numDays > 0) {
	          return Okta.loc('password.expiring.title', 'login', [numDays]);
	        }
	        else if (expiringSoon && numDays === 0) {
	          return Okta.loc('password.expiring.today', 'login');
	        }
	        else {
	          return Okta.loc('password.expired.title', 'login');
	        }
	      },
	      subtitle: function () {
	        if (this.options.appState.get('isPwdExpiringSoon')) {
	          return Okta.loc('password.expiring.subtitle', 'login');
	        }

	        var policy = this.options.appState.get('policy');
	        if (!policy || !policy.complexity) {
	          return;
	        }

	        return FactorUtil.getPasswordComplexityDescription(policy.complexity);
	      },
	      formChildren: function () {
	        return [
	          FormType.Input({
	            'label-top': true,
	            label: false,
	            placeholder: Okta.loc('password.oldPassword.placeholder', 'login'),
	            name: 'oldPassword',
	            input: TextBox,
	            type: 'password',
	            params: {
	              innerTooltip: Okta.loc('password.oldPassword.tooltip', 'login'),
	              icon: 'credentials-16'
	            }
	          }),
	          FormType.Divider(),
	          FormType.Input({
	            'label-top': true,
	            label: false,
	            placeholder: Okta.loc('password.newPassword.placeholder', 'login'),
	            name: 'newPassword',
	            input: TextBox,
	            type: 'password',
	            params: {
	              innerTooltip: Okta.loc('password.newPassword.tooltip', 'login'),
	              icon: 'credentials-16'
	            }
	          }),
	          FormType.Input({
	            'label-top': true,
	            label: false,
	            placeholder: Okta.loc('password.confirmPassword.placeholder', 'login'),
	            name: 'confirmPassword',
	            input: TextBox,
	            type: 'password',
	            params: {
	              innerTooltip: Okta.loc('password.confirmPassword.tooltip', 'login'),
	              icon: 'credentials-16'
	            }
	          })
	        ];
	      }
	    },
	    Footer: Footer,

	    initialize: function () {
	      this.listenTo(this.form, 'save', function () {
	        var creds = {
	          username: this.options.appState.get('userEmail'),
	          password: this.model.get('newPassword')
	        };
	        this.settings.processCreds(creds)
	        .then(_.bind(this.model.save, this.model));
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  var fn = {};

	  // Validate the 'username' field on the model.
	  fn.validateUsername = function (model) {
	    var username = model.get('username');
	    if (username && username.length > 256) {
	      return {
	        username: Okta.loc('model.validation.field.username', 'login')
	      };
	    }
	  };

	  // Validate that the 'newPassword' and 'confirmPassword' fields on the model are a match.
	  fn.validatePasswordMatch = function (model) {
	    if (model.get('newPassword') !== model.get('confirmPassword')) {
	      return {
	        confirmPassword: Okta.loc('password.error.match', 'login')
	      };
	    }
	  };

	  return fn;

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2017, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(112)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums) {

	  return Okta.View.extend({
	    template: '\
	      {{#if passwordWarn}}\
	        <a href="#" class="link help js-skip" data-se="skip-link">\
	          {{i18n code="password.expiring.later" bundle="login"}}\
	        </a>\
	      {{/if}}\
	      <a href="#" class="link help goto js-signout" data-se="signout-link">{{i18n code="signout" bundle="login"}}</a>\
	    ',
	    className: 'auth-footer clearfix',
	    events: {
	      'click .js-signout' : function (e) {
	        e.preventDefault();
	        var self = this;
	        this.model.doTransaction(function (transaction) {
	              return transaction.cancel();
	            })
	            .then(function () {
	              self.state.set('navigateDir', Enums.DIRECTION_BACK);
	              self.options.appState.trigger('navigate', '');
	            });
	      },
	      'click .js-skip' : function (e) {
	        e.preventDefault();
	        this.model.doTransaction(function (transaction) {
	          return transaction.skip();
	        });
	      }
	    },
	    getTemplateData: function () {
	      return {passwordWarn: this.options.appState.get('isPwdExpiringSoon')};
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2017, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(180),
	  __webpack_require__(110)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, Footer, Util) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'custom-password-expired',
	    Model: {},
	    Form: {
	      noButtonBar: true,
	      title: function () {
	        var expiringSoon = this.options.appState.get('isPwdExpiringSoon'),
	            numDays = this.options.appState.get('passwordExpireDays');
	        if (expiringSoon && numDays > 0) {
	          return Okta.loc('password.expiring.title', 'login', [numDays]);
	        }
	        else if (expiringSoon && numDays === 0) {
	          return Okta.loc('password.expiring.today', 'login');
	        }
	        else {
	          return Okta.loc('password.expired.title', 'login');
	        }
	      },
	      subtitle: function () {
	        if (this.options.appState.get('isPwdExpiringSoon')) {
	          return Okta.loc('password.expiring.subtitle', 'login') + ' ' +
	                 Okta.loc('password.expired.custom.subtitle', 'login');
	        }

	        return Okta.loc('password.expired.custom.subtitle', 'login');
	      },
	      formChildren: function () {
	        return [
	          FormType.Button({
	            title: _.partial(Okta.loc, 'password.expired.custom.submit', 'login',
	                            [this.options.appState.get('passwordExpiredWebsiteName')]),
	            className: 'button button-primary button-wide',
	            attributes: {'data-se': 'custom-button'},
	            click: function () {
	              Util.redirect(this.options.appState.get('passwordExpiredLinkUrl'));
	            }
	          })
	        ];
	      }
	    },
	    Footer: Footer
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(112),
	  __webpack_require__(106),
	  __webpack_require__(179),
	  __webpack_require__(183),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, Enums, FormType, ValidationUtil, ContactSupport, TextBox) {

	  var _ = Okta._;

	  var Footer = Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="goback" bundle="login"}}\
	      </a>\
	      {{#if helpSupportNumber}}\
	      <a href="#" class="link goto js-contact-support">\
	        {{i18n code="mfa.noAccessToEmail" bundle="login"}}\
	      </a>\
	      {{/if}}\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      },
	      'click .js-contact-support': function (e) {
	        e.preventDefault();
	        this.state.trigger('contactSupport');
	        this.$('.js-contact-support').hide();
	      }
	    },
	    getTemplateData: function () {
	      return this.settings.pick('helpSupportNumber');
	    },
	    back: function () {
	      this.state.set('navigateDir', Enums.DIRECTION_BACK);
	      this.options.appState.trigger('navigate', '');
	    }
	  });

	  return FormController.extend({
	    className: 'forgot-password',
	    Model: {
	      props: {
	        username: ['string', true],
	        factorType: ['string', true, Enums.RECOVERY_FACTOR_TYPE_EMAIL]
	      },
	      validate: function () {
	        return ValidationUtil.validateUsername(this);
	      },
	      save: function () {
	        var self = this;
	        this.startTransaction(function(authClient) {
	          return authClient.forgotPassword({
	            username: self.settings.transformUsername(self.get('username'), Enums.FORGOT_PASSWORD),
	            factorType: self.get('factorType')
	          });
	        })
	        .fail(function () {
	          self.set('factorType', Enums.RECOVERY_FACTOR_TYPE_EMAIL);
	        });
	      }
	    },
	    Form: {
	      autoSave: true,
	      save: _.partial(Okta.loc, 'password.forgot.sendEmail', 'login'),
	      title: _.partial(Okta.loc, 'password.reset', 'login'),
	      formChildren: function () {
	        var formChildren = [
	          FormType.Input({
	            placeholder: Okta.loc('password.forgot.email.or.username.placeholder', 'login'),
	            name: 'username',
	            input: TextBox,
	            type: 'text',
	            params: {
	              innerTooltip: Okta.loc('password.forgot.email.or.username.tooltip', 'login'),
	              icon: 'person-16-gray'
	            }
	          })
	        ];
	        var smsEnabled = this.settings.get('features.smsRecovery');
	        var callEnabled = this.settings.get('features.callRecovery');
	        if (smsEnabled || callEnabled) {
	          formChildren.push(FormType.View({
	            View: Okta.View.extend({
	              template: '\
	                <p class="mobile-recovery-hint">\
	                  {{i18n code="recovery.mobile.hint" bundle="login" arguments="mobileFactors"}}\
	                </p>',
	              getTemplateData: function () {
	                var mobileFactors;
	                if (smsEnabled && callEnabled) {
	                  mobileFactors = Okta.loc('recovery.smsOrCall');
	                }
	                else if (callEnabled) {
	                  mobileFactors = Okta.loc('recovery.call');
	                }
	                else {
	                  mobileFactors = Okta.loc('recovery.sms');
	                }
	                return { mobileFactors : mobileFactors };
	              }
	            })
	          }));
	        }

	        return formChildren;
	      },
	      initialize: function () {
	        var form = this;

	        if (this.settings.get('features.callRecovery')) {
	          this.$el.addClass('forgot-password-call-enabled');
	          this.addRecoveryFactorButton('call-button', 'password.forgot.call',
	            Enums.RECOVERY_FACTOR_TYPE_CALL, form);
	        }
	        if (this.settings.get('features.smsRecovery')) {
	          this.$el.addClass('forgot-password-sms-enabled');
	          this.addRecoveryFactorButton('sms-button', 'password.forgot.sendText',
	            Enums.RECOVERY_FACTOR_TYPE_SMS, form);
	        }

	        this.listenTo(this.state, 'contactSupport', function () {
	          this.add(ContactSupport, '.o-form-error-container');
	        });

	        this.listenTo(this, 'save', function () {
	          this.options.appState.set('username', this.model.get('username'));
	        });
	      },
	      addRecoveryFactorButton: function (className, labelCode, factorType, form) {
	        this.addButton({
	          attributes: { 'data-se': className},
	          type: 'button',
	          className: 'button-primary ' + className,
	          text: Okta.loc(labelCode, 'login'),
	          action: function () {
	            form.clearErrors();
	            if (this.model.isValid()) {
	              this.model.set('factorType', factorType);
	              form.trigger('save', this.model);
	            }
	          }
	        }, { prepend: true });
	      }
	    },
	    Footer: Footer,

	    initialize: function () {
	      this.options.appState.unset('username');
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta) {

	  return Okta.View.extend({
	    template: '\
	      <div class="infobox">\
	        <span class="icon info-16"></span>\
	        <p>{{i18n code="contact.support" bundle="login" arguments="helpSupportNumber"}}</p>\
	      </div>',
	    className: 'contact-support',

	    getTemplateData: function () {
	      return this.settings.pick('helpSupportNumber');
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(112),
	  __webpack_require__(129),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, Enums, FooterSignout, TextBox) {

	  var _ = Okta._;
	  var API_RATE_LIMIT = 30000; //milliseconds

	  return FormController.extend({
	    className: 'recovery-challenge',
	    Model: {
	      props: {
	        passCode: ['string', true]
	      },
	      local: {
	        ableToResend: 'boolean'
	      },
	      resendCode: function () {
	        // Note: This does not require a trapAuthResponse because Backbone's
	        // router will not navigate if the url path is the same
	        this.limitResending();
	        return this.doTransaction(function(transaction) {
	          return transaction.resend();
	        });
	      },
	      limitResending: function () {
	        this.set({ableToResend: false});
	        _.delay(_.bind(this.set, this), API_RATE_LIMIT, {ableToResend: true});
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          return transaction.verify({
	            passCode: this.get('passCode')
	          });
	        });
	      }
	    },
	    Form: {
	      autoSave: true,
	      save: _.partial(Okta.loc, 'mfa.challenge.verify', 'login'),
	      title: function () {
	        if (this.options.appState.get('factorType') === Enums.RECOVERY_FACTOR_TYPE_CALL) {
	          return Okta.loc('recoveryChallenge.call.title', 'login');
	        } else {
	          return Okta.loc('recoveryChallenge.sms.title', 'login');
	        }
	      },
	      className: 'recovery-challenge',
	      initialize: function () {
	        this.listenTo(this.model, 'error', function () {
	          this.clearErrors();
	        });
	      },
	      formChildren: function () {
	        return [
	          FormType.Button({
	            title: Okta.loc('mfa.resendCode', 'login'),
	            attributes: { 'data-se': 'resend-button' },
	            className: 'button sms-request-button',
	            click: function () {
	              this.model.resendCode();
	            },
	            initialize: function () {
	              this.listenTo(this.model, 'change:ableToResend', function (model, ableToResend) {
	                if (ableToResend) {
	                  this.options.title = Okta.loc('mfa.resendCode', 'login');
	                  this.enable();
	                  this.render();
	                } else {
	                  this.options.title = Okta.loc('mfa.sent', 'login');
	                  this.disable();
	                  this.render();
	                }
	              });
	            }
	          }),
	          FormType.Input({
	            placeholder: Okta.loc('mfa.challenge.enterCode.placeholder', 'login'),
	            className: 'enroll-sms-phone',
	            name: 'passCode',
	            input: TextBox,
	            type: 'text'
	          })
	        ];
	      }
	    },

	    events: {
	      'click .send-email-link': function (e) {
	        e.preventDefault();
	        var settings = this.model.settings,
	            username = this.options.appState.get('username'),
	            recoveryType = this.options.appState.get('recoveryType');

	        this.model.startTransaction(function (authClient) {
	          // The user could have landed here via the Forgot Password/Unlock Account flow
	          switch (recoveryType) {
	            case Enums.RECOVERY_TYPE_PASSWORD:
	              return authClient.forgotPassword({
	                username: settings.transformUsername(username, Enums.FORGOT_PASSWORD),
	                factorType: Enums.RECOVERY_FACTOR_TYPE_EMAIL
	              });
	            case Enums.RECOVERY_TYPE_UNLOCK:
	              return authClient.unlockAccount({
	                username: settings.transformUsername(username, Enums.UNLOCK_ACCOUNT),
	                factorType: Enums.RECOVERY_FACTOR_TYPE_EMAIL
	              });
	            default:
	              return;
	          }
	        });
	      }
	    },

	    initialize: function () {
	      var recoveryType = this.options.appState.get('recoveryType'),
	          sendEmailLink;

	      switch (recoveryType) {
	        case Enums.RECOVERY_TYPE_PASSWORD:
	          sendEmailLink = '\
	            <a href="#" class="link send-email-link" data-se="send-email-link">\
	              {{i18n code="password.forgot.code.notReceived" bundle="login"}}\
	            </a>';
	          break;
	        case Enums.RECOVERY_TYPE_UNLOCK:
	          sendEmailLink = '\
	            <a href="#" class="link send-email-link" data-se="send-email-link">\
	              {{i18n code="account.unlock.sms.notReceived" bundle="login"}}\
	            </a>';
	          break;
	        default:
	          break;
	      }

	      if (sendEmailLink) {
	        this.add(sendEmailLink);
	      }

	      this.add(new FooterSignout(_.extend(this.toJSON(), {linkText: Okta.loc('goback', 'login'), linkClassName: ''})));
	    },

	    postRender: function () {
	      this.model.limitResending();
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(112),
	  __webpack_require__(105),
	  __webpack_require__(106)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums, FormController, FormType) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'password-reset-email-sent',
	    Model: function () {
	      return {
	        local: {
	          userFullName: ['string', false, this.options.appState.get('userFullName')]
	        }
	      };
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'password.forgot.emailSent.title', 'login'),
	      subtitle: function () {
	        var username = this.options.appState.get('username');
	        return Okta.loc('password.forgot.emailSent.desc', 'login', [username]);
	      },
	      noButtonBar: true,
	      attributes: { 'data-se': 'pwd-reset-email-sent' },
	      formChildren: function () {
	        return [
	          FormType.View({
	            View: Okta.View.extend({
	              template: '\
	              <span class="accessibility-text" role="status">{{alert}}</span>\
	              ',
	              getTemplateData: function () {
	                return { 'alert': Okta.loc('password.forgot.emailSent.title', 'login') };
	              }
	            })
	          }),

	          FormType.Button({
	            title: Okta.loc('goback', 'login'),
	            className: 'button button-primary button-wide',
	            attributes: {'data-se': 'back-button'},
	            click: function () {
	              var self = this;
	              return this.model.doTransaction(function (transaction) {
	                return transaction.cancel();
	              })
	              .then(function() {
	                self.state.set('navigateDir', Enums.DIRECTION_BACK);
	                self.options.appState.trigger('navigate', '');
	              });
	            }
	          })
	        ];
	      }
	    },

	    initialize: function (options) {
	      this.settings.callGlobalSuccess(Enums.FORGOT_PASSWORD_EMAIL_SENT, {
	        username: options.appState.get('username')
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(129),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, FooterSignout, TextBox) {

	  return FormController.extend({
	    className: 'recovery-question',
	    Model: {
	      props: {
	        answer: ['string', true],
	        showAnswer: 'boolean'
	      },
	      save: function () {
	        return this.doTransaction(function(transaction) {
	          return transaction.answer({ answer: this.get('answer') });
	        });
	      }
	    },
	    Form: {
	      autoSave: true,
	      save: function () {
	        switch (this.options.appState.get('recoveryType')) {
	        case 'PASSWORD':
	          return Okta.loc('password.forgot.question.submit', 'login');
	        case 'UNLOCK':
	          return Okta.loc('account.unlock.question.submit', 'login');
	        default:
	          return Okta.loc('mfa.challenge.verify', 'login');
	        }
	      },
	      title: function () {
	        switch (this.options.appState.get('recoveryType')) {
	        case 'PASSWORD':
	          return Okta.loc('password.forgot.question.title', 'login');
	        case 'UNLOCK':
	          return Okta.loc('account.unlock.question.title', 'login');
	        default:
	          return '';
	        }
	      },
	      formChildren: function () {
	        return [
	          FormType.Input({
	            label: this.options.appState.get('recoveryQuestion'),
	            placeholder: Okta.loc('mfa.challenge.answer.placeholder', 'login'),
	            name: 'answer',
	            input: TextBox,
	            type: 'password',
	            initialize: function () {
	              this.listenTo(this.model, 'change:showAnswer', function () {
	                var type = this.model.get('showAnswer') ? 'text' : 'password';
	                this.getInputs()[0].changeType(type);
	              });
	            }
	          }),
	          FormType.Input({
	            label: false,
	            'label-top': true,
	            placeholder: Okta.loc('mfa.challenge.answer.showAnswer', 'login'),
	            className: 'recovery-question-show margin-btm-0',
	            name: 'showAnswer',
	            type: 'checkbox'
	          })
	        ];
	      }
	    },
	    Footer: FooterSignout

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(179),
	  __webpack_require__(104),
	  __webpack_require__(129),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, FormType, ValidationUtil, FactorUtil, FooterSignout, TextBox) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'password-reset',
	    Model: {
	      props: {
	        newPassword: ['string', true],
	        confirmPassword: ['string', true]
	      },
	      validate: function () {
	        return ValidationUtil.validatePasswordMatch(this);
	      },
	      save: function () {
	        var self = this;
	        return this.doTransaction(function(transaction) {
	          return transaction
	          .resetPassword({
	            newPassword: self.get('newPassword')
	          });
	        });
	      }
	    },
	    Form: {
	      save: _.partial(Okta.loc, 'password.reset', 'login'),
	      title: _.partial(Okta.loc, 'password.reset.title', 'login'),
	      subtitle: function () {
	        var policy = this.options.appState.get('policy');
	        if (!policy || !policy.complexity) {
	          return;
	        }

	        return FactorUtil.getPasswordComplexityDescription(policy.complexity);
	      },
	      formChildren: function () {
	        return [
	          FormType.Input({
	            placeholder: Okta.loc('password.newPassword.placeholder', 'login'),
	            name: 'newPassword',
	            input: TextBox,
	            type: 'password',
	            params: {
	              innerTooltip: Okta.loc('password.newPassword.tooltip', 'login'),
	              icon: 'credentials-16'
	            }
	          }),
	          FormType.Input({
	            placeholder: Okta.loc('password.confirmPassword.placeholder', 'login'),
	            name: 'confirmPassword',
	            input: TextBox,
	            type: 'password',
	            params: {
	              innerTooltip: Okta.loc('password.confirmPassword.tooltip', 'login'),
	              icon: 'credentials-16'
	            }
	          })
	        ];
	      }
	    },
	    Footer: FooterSignout,

	    initialize: function () {
	      this.listenTo(this.form, 'save', function () {
	        var creds = {
	          username: this.options.appState.get('userEmail'),
	          password: this.model.get('newPassword')
	        };
	        this.settings.processCreds(creds)
	        .then(_.bind(this.model.save, this.model));
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(105)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController) {

	  return FormController.extend({
	    className: 'recovery-loading',

	    Model: {},
	    Form: {
	      noButtonBar: true
	    },

	    initialize: function (options) {
	      var self = this;
	      return this.model.startTransaction(function (authClient) {
	        return authClient.verifyRecoveryToken({
	          recoveryToken: options.token
	        });
	      })
	      .fail(function () {
	        self.options.appState.trigger('loading', false);
	      });
	    },

	    preRender: function () {
	      this.options.appState.trigger('loading', true);
	    },

	    trapAuthResponse: function () {
	      this.options.appState.trigger('loading', false);
	      return false;
	    }

	  });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(105),
	  __webpack_require__(112),
	  __webpack_require__(106),
	  __webpack_require__(179),
	  __webpack_require__(183),
	  __webpack_require__(116)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FormController, Enums, FormType, ValidationUtil, ContactSupport, TextBox) {

	  var _ = Okta._;

	  var Footer = Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="goback" bundle="login"}}\
	      </a>\
	      {{#if helpSupportNumber}}\
	      <a href="#" class="link goto js-contact-support">\
	        {{i18n code="mfa.noAccessToEmail" bundle="login"}}\
	      </a>\
	      {{/if}}\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      },
	      'click .js-contact-support': function (e) {
	        e.preventDefault();
	        this.state.trigger('contactSupport');
	        this.$('.js-contact-support').hide();
	      }
	    },
	    getTemplateData: function () {
	      return this.settings.pick('helpSupportNumber');
	    },
	    back: function () {
	      this.state.set('navigateDir', Enums.DIRECTION_BACK);
	      this.options.appState.trigger('navigate', '');
	    }
	  });

	  return FormController.extend({
	    className: 'account-unlock',
	    Model: {
	      props: {
	        username: ['string', true],
	        factorType: ['string', true, Enums.RECOVERY_FACTOR_TYPE_EMAIL]
	      },
	      validate: function () {
	        return ValidationUtil.validateUsername(this);
	      },
	      save: function () {
	        var self = this;
	        return this.startTransaction(function (authClient) {
	          return authClient.unlockAccount({
	            username: self.settings.transformUsername(self.get('username'), Enums.UNLOCK_ACCOUNT),
	            factorType: self.get('factorType')
	          });
	        })
	        .fail(function () {
	          self.set('factorType', Enums.RECOVERY_FACTOR_TYPE_EMAIL);
	        });
	      }
	    },
	    Form: {
	      autoSave: true,
	      save: _.partial(Okta.loc, 'account.unlock.sendEmail', 'login'),
	      title: _.partial(Okta.loc, 'account.unlock.title', 'login'),
	      formChildren: function () {
	        var formChildren = [
	          FormType.Input({
	            placeholder: Okta.loc('account.unlock.email.or.username.placeholder', 'login'),
	            name: 'username',
	            input: TextBox,
	            type: 'text',
	            params: {
	              innerTooltip: Okta.loc('account.unlock.email.or.username.tooltip', 'login'),
	              icon: 'person-16-gray'
	            }
	          })
	        ];
	        if (this.settings.get('features.smsRecovery')) {
	          formChildren.push(FormType.View({View: '\
	            <p class="sms-hint">\
	              {{i18n code="recovery.sms.hint" bundle="login"}}\
	            </p>\
	          '}));
	        }

	        return formChildren;
	      },
	      initialize: function () {
	        var form = this;

	        this.listenTo(this, 'save', function () {
	          this.options.appState.set('username', this.model.get('username'));
	        });

	        if (this.settings.get('features.smsRecovery')) {
	          this.$el.addClass('forgot-password-sms-enabled');
	          this.addButton({
	            attributes: { 'data-se': 'sms-button'},
	            type: 'button',
	            className: 'button-primary sms-button',
	            text: Okta.loc('account.unlock.sendText', 'login'),
	            action: function () {
	              form.clearErrors();
	              if (this.model.isValid()) {
	                this.model.set('factorType', Enums.RECOVERY_FACTOR_TYPE_SMS);
	                form.trigger('save', this.model);
	              }
	            }
	          }, { prepend: true });
	        }

	        this.listenTo(this.state, 'contactSupport', function () {
	          this.add(ContactSupport, '.o-form-error-container');
	        });
	      }
	    },
	    Footer: Footer
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(112),
	  __webpack_require__(105),
	  __webpack_require__(106)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums, FormController, FormType) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'account-unlocked',
	    Model: function () {
	      return {
	        local: {
	          userFullName: ['string', false, this.options.appState.get('userFullName')]
	        }
	      };
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'account.unlock.unlocked.title', 'login'),
	      subtitle: _.partial(Okta.loc, 'account.unlock.unlocked.desc', 'login'),
	      noButtonBar: true,
	      attributes: { 'data-se': 'account-unlocked' },
	      formChildren: function () {
	        return [
	          FormType.Button({
	            title: Okta.loc('goback', 'login'),
	            className: 'button button-primary button-wide',
	            attributes: {'data-se': 'back-button'},
	            click: function () {
	              this.state.set('navigateDir', Enums.DIRECTION_BACK);
	              this.options.appState.trigger('navigate', '');
	            }
	          })
	        ];
	      }
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(112),
	  __webpack_require__(105),
	  __webpack_require__(106)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Enums, FormController, FormType) {

	  var _ = Okta._;

	  return FormController.extend({
	    className: 'account-unlock-email-sent',
	    Model: function () {
	      return {
	        local: {
	          userFullName: ['string', false, this.options.appState.get('userFullName')]
	        }
	      };
	    },

	    Form: {
	      title: _.partial(Okta.loc, 'account.unlock.emailSent.title', 'login'),
	      subtitle: function () {
	        var username = this.options.appState.get('username');
	        return Okta.loc('account.unlock.emailSent.desc', 'login', [username]);
	      },
	      noButtonBar: true,
	      attributes: { 'data-se': 'unlock-email-sent' },
	      formChildren: function () {
	        return [
	          FormType.Button({
	            title: Okta.loc('goback', 'login'),
	            className: 'button button-primary button-wide',
	            attributes: {'data-se': 'back-button'},
	            click: function () {
	              this.state.set('navigateDir', Enums.DIRECTION_BACK);
	              this.options.appState.trigger('navigate', '');
	            }
	          })
	        ];
	      }
	    },

	    initialize: function (options) {
	      this.settings.callGlobalSuccess(Enums.UNLOCK_ACCOUNT_EMAIL_SENT, {
	        username: options.appState.get('username')
	      });
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9),
	  __webpack_require__(112),
	  __webpack_require__(105),
	  __webpack_require__(106),
	  __webpack_require__(110),
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, Enums, FormController, FormType, Util) {

	  var _ = Okta._;
	  var $ = Okta.$;

	  var Footer = Okta.View.extend({
	    template: '\
	      <a href="#" class="link help js-back" data-se="back-link">\
	        {{i18n code="goback" bundle="login"}}\
	      </a>\
	    ',
	    className: 'auth-footer',
	    events: {
	      'click .js-back' : function (e) {
	        e.preventDefault();
	        this.back();
	      }
	    },
	    back: function () {
	      this.state.set('navigateDir', Enums.DIRECTION_BACK);
	      this.options.appState.trigger('navigate', '');
	    }
	  });

	  var sessionCookieRedirectTpl = Okta.tpl(
	    '{{baseUrl}}/login/sessionCookieRedirect?checkAccountSetupComplete=true' +
	    '&token={{{token}}}&redirectUrl={{{redirectUrl}}}'
	  );

	  var BarcodeView = Okta.View.extend({
	    className: 'clearfix',
	    template: '\
	      <div class="">\
	          <style> .qrcode-success .success-16-green::before {font-size: 180px; }</style>\
	          <div class="qrcode-wrap">\
	              <div style="height: 200px; padding-left: 70px; margin: -20px 0 20px;" data-se="qrcode-success" class="qrcode-success hide">\
	              <span class="icon icon-16 icon-only success-16-green"></span>\
	              </div>\
	              <img data-se="qrcode" class="qrcode-image" src="/api/v1/authn/qr/generate?t={{qrtoken}}" > \
	              <!-- img data-se="qrcode" class="qrcode-image" src="{{qrcode}}" --> \
	          </div>\
	      </div>\
	    ',

	    events: {
	      'click [data-type="refresh-qrcode"]': function (e) {
	        e.preventDefault();
	        // TODO
	      }
	    },

	    getTemplateData: function () {
	      var data = {qrtoken: this.model.get('id')};
	      var url = 'https://upload.wikimedia.org/wikipedia/commons/d/d0/QR_code_for_mobile_English_Wikipedia.svg';
	      data.qrcode = url;

	      return data;
	    }
	  });

	  return FormController.extend({
	    className: 'barcode-totp',
	    Model: function () {
	      return {
	        url: function () {
	          return '/api/v1/sso/qr/verify/' +  this.get('id');
	        },
	        props: {
	          id: 'string',
	          status: 'string',
	          stateToken: 'string',
	          expiresAt: 'string',
	          factorResult: 'string',
	          factorResultMessage: 'string',
	          relayState: 'string',
	          recoveryToken: 'string',
	          sessionToken: 'string',
	          idToken: 'string',
	          factorType: 'string',
	          recoveryType: 'string',
	        }
	      };
	    },

	    Form: {
	      title: 'Okta QR Login',
	      noCancelButton: true,
	      className: 'barcode-scan',

	      formChildren: [
	        FormType.View({View: BarcodeView})
	      ],

	      render: function () {
	        Okta.Form.prototype.render.apply(this, arguments);
	        this.$('.o-form-button-bar').remove();
	      }
	    },

	    Footer: Footer,

	    initialize: function () {
	      this.model.set('id', (new Date()).getTime());
	    },

	    postRender: function () {      
	      this.poll();
	    },

	    poll: function () {
	      var self = this;

	      Q.delay(2000)
	      .then(function () {
	        self.form.clearErrors();
	      })
	      .then(function () {
	        return self.model.fetch();
	      })
	      .then(function (res) {
	        /*
	        IF succeed THEN 
	        1. append successful callout to the page
	           slide away qr code and slide in successful icon
	        2. start to redirect to home page
	           delay 1 second
	           this.options.appState.trigger('navigate', '/');
	        ELSE recursively call this.poll
	        */

	        if (res.status === 'SUCCESS') {
	          //self.appState.set('transaction', {data: res});
	          self.$('.qrcode-image').hide("slow", function () {
	            self.$('.qrcode-success').show("slow");
	          });
	          Util.redirect(sessionCookieRedirectTpl({
	            baseUrl: self.settings.get('baseUrl'),
	            token: encodeURIComponent(res.sessionToken),
	            redirectUrl: encodeURIComponent(self.settings.get('redirectUrl') || 'http://haisheng.okta1.com:1802')
	          }));
	        } else {
	          self.poll();
	        }
	      })
	      .fail(function () {
	        // self.$('.qrcode-image').hide("slow", function () {
	        //   self.$('.qrcode-success').show("slow");
	        // });
	      })
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* jshint maxcomplexity: 8 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(9),
	  __webpack_require__(104),
	  __webpack_require__(194),
	  __webpack_require__(126)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, Q, FactorUtil, FactorsDropDown, Factor) {

	  var _ = Okta._;

	  return Okta.View.extend({

	    template: '\
	      <div class="beacon-blank auth-beacon">\
	        <div class="beacon-blank js-blank-beacon-border auth-beacon-border"></div>\
	      </div>\
	      <div class="bg-helper auth-beacon auth-beacon-factor {{className}}" data-se="factor-beacon">\
	        <div class="okta-sign-in-beacon-border auth-beacon-border"></div>\
	      </div>\
	      <div data-type="factor-types-dropdown" class="factors-dropdown-wrap"></div>\
	    ',

	    events: {
	      'click .auth-beacon-factor': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        this.$('.dropdown .options').toggle();
	      }
	    },

	    initialize: function () {
	      this.options.appState.set('beaconType', 'factor');
	    },

	    getTemplateData: function () {
	      var factors = this.options.appState.get('factors'),
	          factor, className;
	      if (factors) {
	        factor = factors.findWhere(_.pick(this.options, 'provider', 'factorType'));
	      } else  {
	        factor = new Factor.Model(this.options.appState.get('factor'), this.toJSON());
	      }
	      className = factor.get('iconClassName');
	      return { className: className || '' };
	    },

	    postRender: function () {
	      if (this.options.animate) {
	        this.$('.auth-beacon-factor').fadeIn(200);
	      }
	      var appState = this.options.appState;
	      if (appState.get('hasMfaRequiredOptions')) {
	        this.add(FactorsDropDown, '[data-type="factor-types-dropdown"]');
	      }
	    },

	    fadeOut: function () {
	      var deferred = Q.defer();
	      this.$('.auth-beacon-factor').fadeOut(200, function () {
	        deferred.resolve();
	      });
	      return deferred.promise;
	    },

	    equals: function (Beacon, options) {
	      return Beacon &&
	        this instanceof Beacon &&
	        options.provider === this.options.provider &&
	        (options.factorType === this.options.factorType ||
	          (FactorUtil.isOktaVerify(options.provider, options.factorType) &&
	          FactorUtil.isOktaVerify(this.options.provider, this.options.factorType)));
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(41),
	  __webpack_require__(195),
	  __webpack_require__(196)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, FactorsDropDownOptions, BaseDropDown) {
	  var _ = Okta._;
	  var $ = Okta.$;

	  $(document).click(function (e) {
	    var $target = $(e.target);
	    var isDropdown = $target.closest('.option-selected').length > 0 && $target.closest('.dropdown').length > 0;
	    if (!isDropdown) {
	      $('.dropdown .options').hide();
	    }
	  });

	  return BaseDropDown.extend({
	    className: 'bg-helper icon-button',
	    events: {
	      'click a.option-selected': function (e) {
	        e.preventDefault();
	        if (_.result(this, 'disabled')) {
	          e.stopPropagation();
	        } else {
	          this.$('.options').toggle();
	        }
	      },
	      'click .dropdown-disabled': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    },
	    initialize: function () {
	      this.addOption(FactorsDropDownOptions.getDropdownOption('TITLE'));
	      this.options.appState.get('factors').each(function (factor) {
	        this.addOption(FactorsDropDownOptions.getDropdownOption(factor.get('factorName')), {model: factor});
	        this.listenTo(this.last(), 'options:toggle', function () {
	          this.$('.options').hide();
	        });
	      }, this);
	    }
	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Copyright (c) 2015-2016, Okta, Inc. and/or its affiliates. All rights reserved.
	 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
	 *
	 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *
	 * See the License for the specific language governing permissions and limitations under the License.
	 */

	/* jshint maxstatements: 16, maxcomplexity: 10 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(41), __webpack_require__(109)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Okta, RouterUtil) {

	  var _ = Okta._;

	  var action = function (model) {
	    var url = RouterUtil.createVerifyUrl(model.get('provider'), model.get('factorType')),
	        self = this;

	    this.model.manageTransaction(function (transaction, setTransaction) {
	      if (transaction.status === 'MFA_CHALLENGE' && transaction.prev) {
	        return transaction.prev()
	        .then(function (trans) {
	          self.trigger('options:toggle');
	          setTransaction(trans);
	          self.options.appState.trigger('navigate', url);
	        });
	      } else {
	        self.trigger('options:toggle');
	        self.options.appState.trigger('navigate', url);
	      }
	    });
	  };

	  var dropdownOptions = {
	    'TITLE': {
	      title: _.partial(Okta.loc, 'mfa.factors.dropdown.title', 'login'),
	      className: 'dropdown-list-title'
	    },

	    'OKTA_VERIFY': {
	      icon: 'factor-icon mfa-okta-verify-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'OKTA_VERIFY_PUSH': {
	      icon: 'factor-icon mfa-okta-verify-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'GOOGLE_AUTH': {
	      icon: 'factor-icon mfa-google-auth-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'SYMANTEC_VIP': {
	      icon: 'factor-icon mfa-symantec-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'RSA_SECURID': {
	      icon: 'factor-icon mfa-rsa-30',
	      title: _.partial(Okta.loc, 'factor.totpHard.rsaSecurId', 'login'),
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'ON_PREM': {
	      icon: 'factor-icon mfa-onprem-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'DUO': {
	      icon: 'factor-icon mfa-duo-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'DUO_PUSH': {
	      icon: 'duo-push-16',
	      className: 'suboption',
	      // TODO: add phone number here
	      title: _.partial(Okta.loc, 'mfa.duoSecurity.push', 'login', ['XXX-XXX-7890'])
	    },

	    'DUO_SMS': {
	      icon: 'duo-sms-16',
	      className: 'suboption',
	      // TODO: add phone number here
	      title: _.partial(Okta.loc, 'mfa.duoSecurity.sms', 'login', ['XXX-XXX-7890'])
	    },

	    'DUO_CALL': {
	      icon: 'duo-call-16',
	      className: 'suboption',
	      // TODO: add phone number here
	      title: _.partial(Okta.loc, 'mfa.duoSecurity.call', 'login', ['XXX-XXX-7890'])
	    },

	    'YUBIKEY': {
	      icon: 'factor-icon mfa-yubikey-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'SMS': {
	      icon: 'factor-icon mfa-sms-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'CALL': {
	      icon: 'factor-icon mfa-call-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'QUESTION': {
	      icon: 'factor-icon mfa-question-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'WINDOWS_HELLO': {
	      icon: 'factor-icon mfa-windows-hello-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    },

	    'U2F': {
	      icon: 'factor-icon mfa-u2f-30',
	      title: function () {
	        return this.model.get('factorLabel');
	      },
	      action: function () {
	        action.call(this, this.model);
	      }
	    }
	  };

	  return {
	    getDropdownOption: function (factorName) {
	      return dropdownOptions[factorName];
	    }
	  };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	  __webpack_require__(2),
	  __webpack_require__(6),
	  __webpack_require__(49),
	  __webpack_require__(48)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, TemplateUtil, BaseView) {

	  var optionsTemplate = TemplateUtil.tpl('\
	    <a class="icon-16 {{className}}" data-se="{{seleniumId}}">\
	      {{#if icon}}\
	      <span class="icon {{icon}}"></span>\
	      {{/if}}\
	      {{#if title}}\
	      {{title}}\
	      {{/if}}\
	      {{#if subtitle}}\
	        <p class="option-subtitle">{{subtitle}}</p>\
	      {{/if}}\
	   </a>\
	   ');

	  var DropDownOption = BaseView.extend({
	    tagName: 'li',

	    events: {
	      click: function (e) {
	        e.preventDefault();
	        this.action && this.action.call(this);
	      }
	    },

	    constructor: function () {
	      BaseView.apply(this, arguments);
	      this.$el.addClass('okta-dropdown-option option');
	    },

	    render: function () {
	      this.$el.html(optionsTemplate({
	        icon: _.result(this, 'icon'),
	        className: _.result(this, 'className') || '',
	        title: _.result(this, 'title'),
	        subtitle: _.result(this, 'subtitle'),
	        seleniumId: _.result(this, 'seleniumId')
	      }));
	      return this;
	    }
	  });

	  return BaseView.extend({

	    events: {
	      'click a.option-selected': function (e) {
	        e.preventDefault();
	        if (_.result(this, 'disabled')) {
	          e.stopPropagation();
	        }
	      },
	      'click .dropdown-disabled': function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    },

	    items: [],

	    constructor: function () {

	      // In this very specific case we want to NOT append className to $el
	      // but to the <a> tag in the template
	      // so we want to disable backbone default functionality.
	      var className = this.className;
	      this.className = null;

	      BaseView.apply(this, arguments);

	      this.className = className;

	      this.$el.addClass('dropdown more-actions float-l');

	      _.each(_.result(this, 'items'), function (option) {
	        this.addOption(option, this.options);
	      }, this);

	    },

	    template: '\
	      <a href="#" class="link-button {{className}} link-button-icon option-selected center">\
	        {{#if icon}}\
	        <span class="icon {{icon}}"></span>\
	        {{/if}}\
	        <span class="option-selected-text">{{title}}</span>\
	        <span class="icon-dm"></span>\
	      </a>\
	      <div class="options clearfix" style="display: none;">\
	      <ul class="okta-dropdown-list options-wrap clearfix"></ul>\
	      </div>\
	    ',

	    getTemplateData: function () {
	      var className = [_.result(this, 'className') || '',
	        _.result(this, 'disabled') ? 'dropdown-disabled' : ''
	      ];
	      return {
	        icon: _.result(this, 'icon'),
	        className: $.trim(className.join(' ')),
	        title: _.result(this, 'title')
	      };
	    },

	    addOption: function (proto, options) {
	      this.add(DropDownOption.extend(proto), 'ul.options-wrap', {options: options || {}});
	    }

	  });

	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }
/******/ ])
});
;